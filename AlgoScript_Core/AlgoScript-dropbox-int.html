<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
<script type="text/javascript" id="globalevalfunction">
//<!--
var globaleval = function(script) {
  if (window.execScript) {
    return window.execScript(script);
  } else if (navigator.userAgent.indexOf('KHTML') != -1) { //safari, konqueror..
    var s = document.createElement('script');
    s.type = 'text/javascript';
    MonInnerHTML(s, script);
    document.getElementsByTagName('head')[0].appendChild(s);
  } else {
    builtin_nbprompt=0; return window.eval(script);
  }
}

var evalligne=17;
var builtin_nbprompt=0; 

var ConfigurationFile,MustCreateAlgoScriptConfigflag=false;
if (typeof(window.localStorage['AlgoScript.config']) != 'undefined')
   ConfigurationFile = window.localStorage['AlgoScript.config'];
else {
   ConfigurationFile = '';
   MustCreateAlgoScriptConfigflag=true;
}
var ConfigTable = ConfigurationFile.split('\n');


//AfficherTableau(ConfigTable);
var AllExtensions = [];
var nbextensions = -1;
for (var i = 0; i < (ConfigTable.length); i++) {
  if (ConfigTable[i].search(/^\[.*\]/) == 0) {
    nbextensions++;
    AllExtensions[nbextensions] = [];
    AllExtensions[nbextensions]['NAME'] = ConfigTable[i].substr(1, ConfigTable[i].length - 2);
  } else {
  	if (ConfigTable[i][0] != '%') {
    var n = ConfigTable[i].search('=');
    if (n > 0) {
      var cle = ConfigTable[i].substr(0, n);
      if (typeof(AllExtensions[nbextensions][cle]) == 'undefined') AllExtensions[nbextensions][cle] = [];
      AllExtensions[nbextensions][cle].push(ConfigTable[i].substr(n + 1));
    }
  	}
  }

}

//Ecrire('Bonjour');
//Ecrire(Taille(AllExtensions));

for (var i = 0; i < (AllExtensions.length); i++) {
  //for (var p in AllExtensions[i]) Ecrire(p + '=' + AllExtensions[i][p]);
  var enabled = (AllExtensions[i]['ENABLED'][0].search(/yes/i) >= 0);
  if (AllExtensions[i]['ENABLED'][0].search(/ask/i) >= 0) enabled = confirm('Do you want to enable\n' + AllExtensions[i]['TITLE'][0] + ' ?');
  if (enabled) {
    if (typeof(AllExtensions[i]['JSURL']) != 'undefined') {
      //for (var j = 0; j < AllExtensions[i]['JSURL'].length; j++) Ecrire('Load ' + AllExtensions[i]['JSURL'][j]);
      for(var j=0; j<AllExtensions[i]['JSURL'].length;j++) document.write('<script src="'+AllExtensions[i]['JSURL'][j]+'"></script>');
    }
    if (typeof(AllExtensions[i]['CSSURL']) != 'undefined') {
      //for (var j = 0; j < AllExtensions[i]['CSSURL'].length; j++) Ecrire('Load ' + AllExtensions[i]['CSSURL'][j]);
      for(var j=0; j<AllExtensions[i]['CSSURL'].length;j++) document.write('<link rel="stylesheet" href="'+AllExtensions[i]['CSSURL'][j]+'" />');
    }
  }
}

function MustCreateAlgoScriptConfig() {
	var initialcontent='';
initialcontent+='% [extension name]\n';
initialcontent+='% TITLE=Extension description\n';
initialcontent+='% ENABLED=yes or no or ask : Extension is enabled\n';
initialcontent+='% JSURL= url of the javascript code of the extension (0, 1 or several JSURL possible)\n';
initialcontent+='% CSSURL=url of the CSS code of the extension (0, 1 or several JSURL possible)\n';
initialcontent+='\n';
initialcontent+='[Openstreetmap extension]\n';
initialcontent+='TITLE=Extension pour OpenStreetMap (leaflet.js)\n';
initialcontent+='ENABLED=no\n';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/leaflet.js\n';
initialcontent+='CSSURL=https://dl.dropboxusercontent.com/u/1961350/leaflet.css\n';
initialcontent+='\n';
initialcontent+='[WebGL extension]\n';
initialcontent+='TITLE=Extension pour WebGL (three.js)\n';
initialcontent+='ENABLED=no\n';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/three.min.js\n';
initialcontent+='\n';
initialcontent+='[Protovis extension]\n';
initialcontent+='TITLE=Extension Protovis pour la visualisation de données http://mbostock.github.io/protovis/\n';
initialcontent+='ENABLED=no\n';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/protovis.min.js\n';
initialcontent+='\n';
initialcontent+='[Sylvester extension]\n';
initialcontent+='TITLE=Extension Sylvester pour le calcul algébrique http://sylvester.jcoglan.com\n';
initialcontent+='ENABLED=no\n';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/sylvester.js\n';
initialcontent+='\n';
initialcontent+='[RSA extension]\n';
initialcontent+='TITLE=Extension Calcul de RSA par Dave Shapiro http://www.ohdave.com/\n';
initialcontent+='ENABLED=no\n';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/BigInt.js\n';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/Barrett.js\n';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/RSA.js\n';
initialcontent+='\n';
initialcontent+='[Arbor extension]\n';
initialcontent+='TITLE=Extension pour la visualisation de graphes (arbor.js)\n';
initialcontent+='ENABLED=no\n';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/jquery-2.0.3.min.js\n';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/arbor.js\n';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/arbor-tween.js\n';
initialcontent+='\n';
initialcontent+='[Processing extension]';
initialcontent+='TITLE=Extension Processing 1.4.1 (processing.js)';
initialcontent+='ENABLED=no';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/processing-1.4.1.min.js';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/Processing_post.js';
initialcontent+='\n';
initialcontent+='[Dracula extension]';
initialcontent+='TITLE=Extension Dracula for drawing graphs';
initialcontent+='ENABLED=no';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/Dracula/raphael-min.js';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/Dracula/dracula_graffle.js';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/Dracula/jquery-1.4.2.min.js';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/Dracula/dracula_graph.js';
initialcontent+='JSURL=https://dl.dropboxusercontent.com/u/1961350/Dracula/dracula_algorithms.js';
	writeFile('AlgoScript.config',initialcontent);
	alert('Creating AlgoScript.config');
}

//-->
</script>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<script src="https://www.dropbox.com/static/api/dropbox-datastores-1.0-latest.js" type="text/javascript" id="dropbox library"></script>

	<title>Make javascript developments simpler</title>
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1"/>

    <style type="text/css">
    .CodeMirror {
  line-height: 1em;
  font-family: monospace;
}

.CodeMirror-scroll {
  overflow: auto;
  height: 100%;
  /* This is needed to prevent an IE[67] bug where the scrolled content
     is visible outside of the scrolling box. */
  position: relative;
  outline: none;
}

.CodeMirror-gutter {
  position: absolute; left: 0; top: 0;
  z-index: 10;
  background-color: #f7f7f7;
  border-right: 1px solid #eee;
  min-width: 2em;
  height: 100%;
}
.CodeMirror-gutter-text {
  color: #aaa;
  text-align: right;
  padding: .4em .2em .4em .4em;
  white-space: pre !important;
}
.CodeMirror-lines {
  padding: .4em;
  white-space: pre;
}

.CodeMirror pre {
  -moz-border-radius: 0;
  -webkit-border-radius: 0;
  -o-border-radius: 0;
  border-radius: 0;
  border-width: 0; margin: 0; padding: 0; background: transparent;
  font-family: inherit;
  font-size: inherit;
  padding: 0; margin: 0;
  white-space: pre;
  word-wrap: normal;
}

.CodeMirror-wrap pre {
  word-wrap: break-word;
  white-space: pre-wrap;
}
.CodeMirror-wrap .CodeMirror-scroll {
  overflow-x: hidden;
}

.CodeMirror textarea {
  outline: none !important;
}

.CodeMirror pre.CodeMirror-cursor {
  z-index: 10;
  position: absolute;
  visibility: hidden;
  border-left: 1px solid black;
  border-right:none;
  width:0;
}
.CodeMirror pre.CodeMirror-cursor.CodeMirror-overwrite {}
.CodeMirror-focused pre.CodeMirror-cursor {
  visibility: visible;
}

div.CodeMirror-selected { background: #d9d9d9; }
.CodeMirror-focused div.CodeMirror-selected { background: #d7d4f0; }

.CodeMirror-searching {
  background: #ffa;
  background: rgba(255, 255, 0, .4);
}

/* Default theme */

.cm-s-default span.cm-keyword {color: #708;}
.cm-s-default span.cm-atom {color: #219;}
.cm-s-default span.cm-number {color: #164;}
.cm-s-default span.cm-def {color: #00f;}
.cm-s-default span.cm-variable {color: black;}
.cm-s-default span.cm-variable-2 {color: #05a;}
.cm-s-default span.cm-variable-3 {color: #085;}
.cm-s-default span.cm-property {color: black;}
.cm-s-default span.cm-operator {color: black;}
.cm-s-default span.cm-comment {color: #a50;}
.cm-s-default span.cm-string {color: #a11;}
.cm-s-default span.cm-string-2 {color: #f50;}
.cm-s-default span.cm-meta {color: #555;}
.cm-s-default span.cm-error {color: #f00;}
.cm-s-default span.cm-qualifier {color: #555;}
.cm-s-default span.cm-builtin {color: #30a;}
.cm-s-default span.cm-bracket {color: #cc7;}
.cm-s-default span.cm-tag {color: #170;}
.cm-s-default span.cm-attribute {color: #00c;}
.cm-s-default span.cm-header {color: #a0a;}
.cm-s-default span.cm-quote {color: #090;}
.cm-s-default span.cm-hr {color: #999;}
.cm-s-default span.cm-link {color: #00c;}

span.cm-header, span.cm-strong {font-weight: bold;}
span.cm-em {font-style: italic;}
span.cm-emstrong {font-style: italic; font-weight: bold;}
span.cm-link {text-decoration: underline;}

div.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}
div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}
    </style>
    
    <script type="text/javascript">







    // codemirror.js
    
    // All functions that need access to the editor's state live inside
// the CodeMirror function. Below that, at the bottom of the file,
// some utilities are defined.

// CodeMirror is the only global var we claim
var CodeMirror = (function() {
  // This is the function that produces an editor instance. Its
  // closure is used to store the editor state.
  function CodeMirror(place, givenOptions) {
    // Determine effective options based on given values and defaults.
    var options = {}, defaults = CodeMirror.defaults;
    for (var opt in defaults)
      if (defaults.hasOwnProperty(opt))
        options[opt] = (givenOptions && givenOptions.hasOwnProperty(opt) ? givenOptions : defaults)[opt];

    // The element in which the editor lives.
    var wrapper = document.createElement("div");
    wrapper.className = "CodeMirror" + (options.lineWrapping ? " CodeMirror-wrap" : "");
    // This mess creates the base DOM structure for the editor.
    wrapper.innerHTML =
      '<div style="overflow: hidden; position: absolute; width: 3px; height: 0px;">' + // Wraps and hides input textarea
        '<textarea style="position: absolute; padding: 0; width: 1px; height: 1em" wrap="off" ' +
          'autocorrect="off" autocapitalize="off"></textarea></div>' +
      '<div class="CodeMirror-scroll" id="resizecode" tabindex="-1">' +
        '<div style="position: relative">' + // Set to the height of the text, causes scrolling
          '<div style="position: relative">' + // Moved around its parent to cover visible view
            '<div class="CodeMirror-gutter"><div class="CodeMirror-gutter-text"></div></div>' +
            // Provides positioning relative to (visible) text origin
            '<div class="CodeMirror-lines"><div style="position: relative; z-index: 0">' +
              '<div style="position: absolute; width: 100%; height: 0; overflow: hidden; visibility: hidden; height: 600px;"></div>' +
              '<pre class="CodeMirror-cursor">&#160;</pre>' + // Absolutely positioned blinky cursor
              '<div style="position: relative; z-index: -1"></div><div></div>' + // DIVs containing the selection and the actual code
            '</div></div></div></div></div>';
    if (place.appendChild) place.appendChild(wrapper); else place(wrapper);
    // I've never seen more elegant code in my life.
    var inputDiv = wrapper.firstChild, input = inputDiv.firstChild,
        scroller = wrapper.lastChild, code = scroller.firstChild,
        mover = code.firstChild, gutter = mover.firstChild, gutterText = gutter.firstChild,
        lineSpace = gutter.nextSibling.firstChild, measure = lineSpace.firstChild,
        cursor = measure.nextSibling, selectionDiv = cursor.nextSibling,
        lineDiv = selectionDiv.nextSibling;
    themeChanged();
    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios) input.style.width = "0px";
    if (!webkit) lineSpace.draggable = true;
    lineSpace.style.outline = "none";
    if (options.tabindex != null) input.tabIndex = options.tabindex;
    if (options.autofocus) focusInput();
    if (!options.gutter && !options.lineNumbers) gutter.style.display = "none";
    // Needed to handle Tab key in KHTML
    if (khtml) inputDiv.style.height = "1px", inputDiv.style.position = "absolute";

    // Check for problem with IE innerHTML not working when we have a
    // P (or similar) parent node.
    try { stringWidth("x"); }
    catch (e) {
      if (e.message.match(/runtime/i))
        e = new Error("A CodeMirror inside a P-style element does not work in Internet Explorer. (innerHTML bug)");
      throw e;
    }

    // Delayed object wrap timeouts, making sure only one is active. blinker holds an interval.
    var poll = new Delayed(), highlight = new Delayed(), blinker;

    // mode holds a mode API object. doc is the tree of Line objects,
    // work an array of lines that should be parsed, and history the
    // undo history (instance of History constructor).
    var mode, doc = new BranchChunk([new LeafChunk([new Line("")])]), work, focused;
    loadMode();
    // The selection. These are always maintained to point at valid
    // positions. Inverted is used to remember that the user is
    // selecting bottom-to-top.
    var sel = {from: {line: 0, ch: 0}, to: {line: 0, ch: 0}, inverted: false};
    // Selection-related flags. shiftSelecting obviously tracks
    // whether the user is holding shift.
    var shiftSelecting, lastClick, lastDoubleClick, lastScrollPos = 0, draggingText,
        overwrite = false, suppressEdits = false;
    // Variables used by startOperation/endOperation to track what
    // happened during the operation.
    var updateInput, userSelChange, changes, textChanged, selectionChanged, leaveInputAlone,
        gutterDirty, callbacks;
    // Current visible range (may be bigger than the view window).
    var displayOffset = 0, showingFrom = 0, showingTo = 0, lastSizeC = 0;
    // bracketHighlighted is used to remember that a bracket has been
    // marked.
    var bracketHighlighted;
    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    var maxLine = "", maxWidth;
    var tabCache = {};

    // Initialize the content.
    operation(function(){setValue(options.value || ""); updateInput = false;})();
    var history = new History();

    // Register our event handlers.
    connect(scroller, "mousedown", operation(onMouseDown));
    connect(scroller, "dblclick", operation(onDoubleClick));
    connect(lineSpace, "dragstart", onDragStart);
    connect(lineSpace, "selectstart", e_preventDefault);
    // Gecko browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for Gecko.
    if (!gecko) connect(scroller, "contextmenu", onContextMenu);
    connect(scroller, "scroll", function() {
      lastScrollPos = scroller.scrollTop;
      updateDisplay([]);
      if (options.fixedGutter) gutter.style.left = scroller.scrollLeft + "px";
      if (options.onScroll) options.onScroll(instance);
    });
    connect(window, "resize", function() {updateDisplay(true);});
    connect(input, "keyup", operation(onKeyUp));
    connect(input, "input", fastPoll);
    connect(input, "keydown", operation(onKeyDown));
    connect(input, "keypress", operation(onKeyPress));
    connect(input, "focus", onFocus);
    connect(input, "blur", onBlur);

    connect(scroller, "dragenter", e_stop);
    connect(scroller, "dragover", e_stop);
    connect(scroller, "drop", operation(onDrop));
    connect(scroller, "paste", function(){focusInput(); fastPoll();});
    connect(input, "paste", fastPoll);
    connect(input, "cut", operation(function(){
      if (!options.readOnly) replaceSelection("");
    }));

    // Needed to handle Tab key in KHTML
    if (khtml) connect(code, "mouseup", function() {
        if (document.activeElement == input) input.blur();
        focusInput();
    });

    // IE throws unspecified error in certain cases, when
    // trying to access activeElement before onload
    var hasFocus; try { hasFocus = (document.activeElement == input); } catch(e) { }
    if (hasFocus || options.autofocus) setTimeout(onFocus, 20);
    else onBlur();

    function isLine(l) {return l >= 0 && l < doc.size;}
    // The instance object that we'll return. Mostly calls out to
    // local functions in the CodeMirror function. Some do some extra
    // range checking and/or clipping. operation is used to wrap the
    // call so that changes it makes are tracked, and the display is
    // updated afterwards.
    var instance = wrapper.CodeMirror = {
      getValue: getValue,
      setValue: operation(setValue),
      getSelection: getSelection,
      replaceSelection: operation(replaceSelection),
      focus: function(){window.focus(); focusInput(); onFocus(); fastPoll();},
      setOption: function(option, value) {
        var oldVal = options[option];
        options[option] = value;
        if (option == "mode" || option == "indentUnit") loadMode();
        else if (option == "readOnly" && value == "nocursor") {onBlur(); input.blur();}
        else if (option == "readOnly" && !value) {resetInput(true);}
        else if (option == "theme") themeChanged();
        else if (option == "lineWrapping" && oldVal != value) operation(wrappingChanged)();
        else if (option == "tabSize") updateDisplay(true);
        if (option == "lineNumbers" || option == "gutter" || option == "firstLineNumber" || option == "theme") {
          gutterChanged();
          updateDisplay(true);
        }
      },
      getOption: function(option) {return options[option];},
      undo: operation(undo),
      redo: operation(redo),
      indentLine: operation(function(n, dir) {
        if (typeof dir != "string") {
          if (dir == null) dir = options.smartIndent ? "smart" : "prev";
          else dir = dir ? "add" : "subtract";
        }
        if (isLine(n)) indentLine(n, dir);
      }),
      indentSelection: operation(indentSelected),
      historySize: function() {return {undo: history.done.length, redo: history.undone.length};},
      clearHistory: function() {history = new History();},
      matchBrackets: operation(function(){matchBrackets(true);}),
      getTokenAt: operation(function(pos) {
        pos = clipPos(pos);
        return getLine(pos.line).getTokenAt(mode, getStateBefore(pos.line), pos.ch);
      }),
      getStateAfter: function(line) {
        line = clipLine(line == null ? doc.size - 1: line);
        return getStateBefore(line + 1);
      },
      cursorCoords: function(start, mode) {
        if (start == null) start = sel.inverted;
        return this.charCoords(start ? sel.from : sel.to, mode);
      },
      charCoords: function(pos, mode) {
        pos = clipPos(pos);
        if (mode == "local") return localCoords(pos, false);
        if (mode == "div") return localCoords(pos, true);
        return pageCoords(pos);
      },
      coordsChar: function(coords) {
        var off = eltOffset(lineSpace);
        return coordsChar(coords.x - off.left, coords.y - off.top);
      },
      markText: operation(markText),
      setBookmark: setBookmark,
      findMarksAt: findMarksAt,
      setMarker: operation(addGutterMarker),
      clearMarker: operation(removeGutterMarker),
      setLineClass: operation(setLineClass),
      hideLine: operation(function(h) {return setLineHidden(h, true);}),
      showLine: operation(function(h) {return setLineHidden(h, false);}),
      onDeleteLine: function(line, f) {
        if (typeof line == "number") {
          if (!isLine(line)) return null;
          line = getLine(line);
        }
        (line.handlers || (line.handlers = [])).push(f);
        return line;
      },
      lineInfo: lineInfo,
      addWidget: function(pos, node, scroll, vert, horiz) {
        pos = localCoords(clipPos(pos));
        var top = pos.yBot, left = pos.x;
        node.style.position = "absolute";
        code.appendChild(node);
        if (vert == "over") top = pos.y;
        else if (vert == "near") {
          var vspace = Math.max(scroller.offsetHeight, doc.height * textHeight()),
              hspace = Math.max(code.clientWidth, lineSpace.clientWidth) - paddingLeft();
          if (pos.yBot + node.offsetHeight > vspace && pos.y > node.offsetHeight)
            top = pos.y - node.offsetHeight;
          if (left + node.offsetWidth > hspace)
            left = hspace - node.offsetWidth;
        }
        node.style.top = (top + paddingTop()) + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = code.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") left = 0;
          else if (horiz == "middle") left = (code.clientWidth - node.offsetWidth) / 2;
          node.style.left = (left + paddingLeft()) + "px";
        }
        if (scroll)
          scrollIntoView(left, top, left + node.offsetWidth, top + node.offsetHeight);
      },

      lineCount: function() {return doc.size;},
      clipPos: clipPos,
      getCursor: function(start) {
        if (start == null) start = sel.inverted;
        return copyPos(start ? sel.from : sel.to);
      },
      somethingSelected: function() {return !posEq(sel.from, sel.to);},
      setCursor: operation(function(line, ch, user) {
        if (ch == null && typeof line.line == "number") setCursor(line.line, line.ch, user);
        else setCursor(line, ch, user);
      }),
      setSelection: operation(function(from, to, user) {
        (user ? setSelectionUser : setSelection)(clipPos(from), clipPos(to || from));
      }),
      getLine: function(line) {if (isLine(line)) return getLine(line).text;},
      getLineHandle: function(line) {if (isLine(line)) return getLine(line);},
      setLine: operation(function(line, text) {
        if (isLine(line)) replaceRange(text, {line: line, ch: 0}, {line: line, ch: getLine(line).text.length});
      }),
      removeLine: operation(function(line) {
        if (isLine(line)) replaceRange("", {line: line, ch: 0}, clipPos({line: line+1, ch: 0}));
      }),
      replaceRange: operation(replaceRange),
      getRange: function(from, to) {return getRange(clipPos(from), clipPos(to));},

      triggerOnKeyDown: operation(onKeyDown),
      execCommand: function(cmd) {return commands[cmd](instance);},
      // Stuff used by commands, probably not much use to outside code.
      moveH: operation(moveH),
      deleteH: operation(deleteH),
      moveV: operation(moveV),
      toggleOverwrite: function() {
        if(overwrite){
          overwrite = false;
          cursor.className = cursor.className.replace(" CodeMirror-overwrite", "");
        } else {
          overwrite = true;
          cursor.className += " CodeMirror-overwrite";
        }
      },

      posFromIndex: function(off) {
        var lineNo = 0, ch;
        doc.iter(0, doc.size, function(line) {
          var sz = line.text.length + 1;
          if (sz > off) { ch = off; return true; }
          off -= sz;
          ++lineNo;
        });
        return clipPos({line: lineNo, ch: ch});
      },
      indexFromPos: function (coords) {
        if (coords.line < 0 || coords.ch < 0) return 0;
        var index = coords.ch;
        doc.iter(0, coords.line, function (line) {
          index += line.text.length + 1;
        });
        return index;
      },
      scrollTo: function(x, y) {
        if (x != null) scroller.scrollLeft = x;
        if (y != null) scroller.scrollTop = y;
        updateDisplay([]);
      },

      operation: function(f){return operation(f)();},
      refresh: function(){
        updateDisplay(true);
        if (scroller.scrollHeight > lastScrollPos)
          scroller.scrollTop = lastScrollPos;
      },
      getInputField: function(){return input;},
      getWrapperElement: function(){return wrapper;},
      getScrollerElement: function(){return scroller;},
      getGutterElement: function(){return gutter;}
    };

    function getLine(n) { return getLineAt(doc, n); }
    function updateLineHeight(line, height) {
      gutterDirty = true;
      var diff = height - line.height;
      for (var n = line; n; n = n.parent) n.height += diff;
    }

    function setValue(code) {
      var top = {line: 0, ch: 0};
      updateLines(top, {line: doc.size - 1, ch: getLine(doc.size-1).text.length},
                  splitLines(code), top, top);
      updateInput = true;
    }
    function getValue(code) {
      var text = [];
      doc.iter(0, doc.size, function(line) { text.push(line.text); });
      return text.join("\n");
    }

    function onMouseDown(e) {
      setShift(e_prop(e, "shiftKey"));
      // Check whether this is a click in a widget
      for (var n = e_target(e); n != wrapper; n = n.parentNode)
        if (n.parentNode == code && n != mover) return;

      // See if this is a click in the gutter
      for (var n = e_target(e); n != wrapper; n = n.parentNode)
        if (n.parentNode == gutterText) {
          if (options.onGutterClick)
            options.onGutterClick(instance, indexOf(gutterText.childNodes, n) + showingFrom, e);
          return e_preventDefault(e);
        }

      var start = posFromMouse(e);

      switch (e_button(e)) {
      case 3:
        if (gecko && !mac) onContextMenu(e);
        return;
      case 2:
        if (start) setCursor(start.line, start.ch, true);
        return;
      }
      // For button 1, if it was clicked inside the editor
      // (posFromMouse returning non-null), we have to adjust the
      // selection.
      if (!start) {if (e_target(e) == scroller) e_preventDefault(e); return;}

      if (!focused) onFocus();

      var now = +new Date;
      if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
        e_preventDefault(e);
        setTimeout(focusInput, 20);
        return selectLine(start.line);
      } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
        lastDoubleClick = {time: now, pos: start};
        e_preventDefault(e);
        return selectWordAt(start);
      } else { lastClick = {time: now, pos: start}; }

      var last = start, going;
      if (dragAndDrop && !options.readOnly && !posEq(sel.from, sel.to) &&
          !posLess(start, sel.from) && !posLess(sel.to, start)) {
        // Let the drag handler handle this.
        if (webkit) lineSpace.draggable = true;
        var up = connect(document, "mouseup", operation(function(e2) {
          if (webkit) lineSpace.draggable = false;
          draggingText = false;
          up();
          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
            e_preventDefault(e2);
            setCursor(start.line, start.ch, true);
            focusInput();
          }
        }), true);
        draggingText = true;
        // IE's approach to draggable
        if (lineSpace.dragDrop) lineSpace.dragDrop();
        return;
      }
      e_preventDefault(e);
      setCursor(start.line, start.ch, true);

      function extend(e) {
        var cur = posFromMouse(e, true);
        if (cur && !posEq(cur, last)) {
          if (!focused) onFocus();
          last = cur;
          setSelectionUser(start, cur);
          updateInput = false;
          var visible = visibleLines();
          if (cur.line >= visible.to || cur.line < visible.from)
            going = setTimeout(operation(function(){extend(e);}), 150);
        }
      }

      function done(e) {
        clearTimeout(going);
        var cur = posFromMouse(e);
        if (cur) setSelectionUser(start, cur);
        e_preventDefault(e);
        focusInput();
        updateInput = true;
        move(); up();
      }
      var move = connect(document, "mousemove", operation(function(e) {
        clearTimeout(going);
        e_preventDefault(e);
        if (!ie && !e_button(e)) done(e);
        else extend(e);
      }), true);
      var up = connect(document, "mouseup", operation(done), true);
    }
    function onDoubleClick(e) {
      for (var n = e_target(e); n != wrapper; n = n.parentNode)
        if (n.parentNode == gutterText) return e_preventDefault(e);
      var start = posFromMouse(e);
      if (!start) return;
      lastDoubleClick = {time: +new Date, pos: start};
      e_preventDefault(e);
      selectWordAt(start);
    }
    function onDrop(e) {
      e.preventDefault();
      var pos = posFromMouse(e, true), files = e.dataTransfer.files;
      if (!pos || options.readOnly) return;
      if (files && files.length && window.FileReader && window.File) {
        function loadFile(file, i) {
          var reader = new FileReader;
          reader.onload = function() {
            text[i] = reader.result;
            if (++read == n) {
	      pos = clipPos(pos);
	      operation(function() {
                var end = replaceRange(text.join(""), pos, pos);
                setSelectionUser(pos, end);
              })();
	    }
          };
          reader.readAsText(file);
        }
        var n = files.length, text = Array(n), read = 0;
        for (var i = 0; i < n; ++i) loadFile(files[i], i);
      }
      else {
        try {
          var text = e.dataTransfer.getData("Text");
          if (text) {
            var curFrom = sel.from, curTo = sel.to;
            setSelectionUser(pos, pos);
            if (draggingText) replaceRange("", curFrom, curTo);
            replaceSelection(text);
	    focusInput();
	  }
        }
        catch(e){}
      }
    }
    function onDragStart(e) {
      var txt = getSelection();
      e.dataTransfer.setData("Text", txt);
      
      // Use dummy image instead of default browsers image.
      if (gecko || chrome) {
        var img = document.createElement('img');
        img.scr = 'data:image/gif;base64,R0lGODdhAgACAIAAAAAAAP///ywAAAAAAgACAAACAoRRADs='; //1x1 image
        e.dataTransfer.setDragImage(img, 0, 0);
      }
    }

    function doHandleBinding(bound, dropShift) {
      if (typeof bound == "string") {
        bound = commands[bound];
        if (!bound) return false;
      }
      var prevShift = shiftSelecting;
      try {
        if (options.readOnly) suppressEdits = true;
        if (dropShift) shiftSelecting = null;
        bound(instance);
      } catch(e) {
        if (e != Pass) throw e;
        return false;
      } finally {
        shiftSelecting = prevShift;
        suppressEdits = false;
      }
      return true;
    }
    function handleKeyBinding(e) {
      // Handle auto keymap transitions
      var startMap = getKeyMap(options.keyMap), next = startMap.auto;
      clearTimeout(maybeTransition);
      if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {
        if (getKeyMap(options.keyMap) == startMap) {
          options.keyMap = (next.call ? next.call(null, instance) : next);
        }
      }, 50);

      var name = keyNames[e_prop(e, "keyCode")], handled = false;
      if (name == null || e.altGraphKey) return false;
      if (e_prop(e, "altKey")) name = "Alt-" + name;
      if (e_prop(e, "ctrlKey")) name = "Ctrl-" + name;
      if (e_prop(e, "metaKey")) name = "Cmd-" + name;

      if (e_prop(e, "shiftKey")) {
        handled = lookupKey("Shift-" + name, options.extraKeys, options.keyMap,
                            function(b) {return doHandleBinding(b, true);})
               || lookupKey(name, options.extraKeys, options.keyMap, function(b) {
                 if (typeof b == "string" && /^go[A-Z]/.test(b)) return doHandleBinding(b);
               });
      } else {
        handled = lookupKey(name, options.extraKeys, options.keyMap, doHandleBinding);
      }
      if (handled) {
        e_preventDefault(e);
        if (ie) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }
      }
      return handled;
    }
    function handleCharBinding(e, ch) {
      var handled = lookupKey("'" + ch + "'", options.extraKeys,
                              options.keyMap, doHandleBinding);
      if (handled) e_preventDefault(e);
      return handled;
    }

    var lastStoppedKey = null, maybeTransition;
    function onKeyDown(e) {
      if (!focused) onFocus();
      if (ie && e.keyCode == 27) { e.returnValue = false; }
      if (pollingFast) { if (readInput()) pollingFast = false; }
      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;
      var code = e_prop(e, "keyCode");
      // IE does strange things with escape.
      setShift(code == 16 || e_prop(e, "shiftKey"));
      // First give onKeyEvent option a chance to handle this.
      var handled = handleKeyBinding(e);
      if (window.opera) {
        lastStoppedKey = handled ? code : null;
        // Opera has no cut event... we try to at least catch the key combo
        if (!handled && code == 88 && e_prop(e, mac ? "metaKey" : "ctrlKey"))
          replaceSelection("");
      }
    }
    function onKeyPress(e) {
      if (pollingFast) readInput();
      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;
      var keyCode = e_prop(e, "keyCode"), charCode = e_prop(e, "charCode");
      if (window.opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
      if (((window.opera && !e.which) || khtml) && handleKeyBinding(e)) return;
      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
      if (options.electricChars && mode.electricChars && options.smartIndent && !options.readOnly) {
        if (mode.electricChars.indexOf(ch) > -1)
          setTimeout(operation(function() {indentLine(sel.to.line, "smart");}), 75);
      }
      if (handleCharBinding(e, ch)) return;
      fastPoll();
    }
    function onKeyUp(e) {
      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;
      if (e_prop(e, "keyCode") == 16) shiftSelecting = null;
    }

    function onFocus() {
      if (options.readOnly == "nocursor") return;
      if (!focused) {
        if (options.onFocus) options.onFocus(instance);
        focused = true;
        if (wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
          wrapper.className += " CodeMirror-focused";
        if (!leaveInputAlone) resetInput(true);
      }
      slowPoll();
      restartBlink();
    }
    function onBlur() {
      if (focused) {
        if (options.onBlur) options.onBlur(instance);
        focused = false;
        if (bracketHighlighted)
          operation(function(){
            if (bracketHighlighted) { bracketHighlighted(); bracketHighlighted = null; }
          })();
        wrapper.className = wrapper.className.replace(" CodeMirror-focused", "");
      }
      clearInterval(blinker);
      setTimeout(function() {if (!focused) shiftSelecting = null;}, 150);
    }

    // Replace the range from from to to by the strings in newText.
    // Afterwards, set the selection to selFrom, selTo.
    function updateLines(from, to, newText, selFrom, selTo) {
      if (suppressEdits) return;
      if (history) {
        var old = [];
        doc.iter(from.line, to.line + 1, function(line) { old.push(line.text); });
        history.addChange(from.line, newText.length, old);
        while (history.done.length > options.undoDepth) history.done.shift();
      }
      updateLinesNoUndo(from, to, newText, selFrom, selTo);
    }
    function unredoHelper(from, to) {
      if (!from.length) return;
      var set = from.pop(), out = [];
      for (var i = set.length - 1; i >= 0; i -= 1) {
        var change = set[i];
        var replaced = [], end = change.start + change.added;
        doc.iter(change.start, end, function(line) { replaced.push(line.text); });
        out.push({start: change.start, added: change.old.length, old: replaced});
        var pos = clipPos({line: change.start + change.old.length - 1,
                           ch: editEnd(replaced[replaced.length-1], change.old[change.old.length-1])});
        updateLinesNoUndo({line: change.start, ch: 0}, {line: end - 1, ch: getLine(end-1).text.length}, change.old, pos, pos);
      }
      updateInput = true;
      to.push(out);
    }
    function undo() {unredoHelper(history.done, history.undone);}
    function redo() {unredoHelper(history.undone, history.done);}

    function updateLinesNoUndo(from, to, newText, selFrom, selTo) {
      if (suppressEdits) return;
      var recomputeMaxLength = false, maxLineLength = maxLine.length;
      if (!options.lineWrapping)
        doc.iter(from.line, to.line, function(line) {
          if (line.text.length == maxLineLength) {recomputeMaxLength = true; return true;}
        });
      if (from.line != to.line || newText.length > 1) gutterDirty = true;

      var nlines = to.line - from.line, firstLine = getLine(from.line), lastLine = getLine(to.line);
      // First adjust the line structure, taking some care to leave highlighting intact.
      if (from.ch == 0 && to.ch == 0 && newText[newText.length - 1] == "") {
        // This is a whole-line replace. Treated specially to make
        // sure line objects move the way they are supposed to.
        var added = [], prevLine = null;
        if (from.line) {
          prevLine = getLine(from.line - 1);
          prevLine.fixMarkEnds(lastLine);
        } else lastLine.fixMarkStarts();
        for (var i = 0, e = newText.length - 1; i < e; ++i)
          added.push(Line.inheritMarks(newText[i], prevLine));
        if (nlines) doc.remove(from.line, nlines, callbacks);
        if (added.length) doc.insert(from.line, added);
      } else if (firstLine == lastLine) {
        if (newText.length == 1)
          firstLine.replace(from.ch, to.ch, newText[0]);
        else {
          lastLine = firstLine.split(to.ch, newText[newText.length-1]);
          firstLine.replace(from.ch, null, newText[0]);
          firstLine.fixMarkEnds(lastLine);
          var added = [];
          for (var i = 1, e = newText.length - 1; i < e; ++i)
            added.push(Line.inheritMarks(newText[i], firstLine));
          added.push(lastLine);
          doc.insert(from.line + 1, added);
        }
      } else if (newText.length == 1) {
        firstLine.replace(from.ch, null, newText[0]);
        lastLine.replace(null, to.ch, "");
        firstLine.append(lastLine);
        doc.remove(from.line + 1, nlines, callbacks);
      } else {
        var added = [];
        firstLine.replace(from.ch, null, newText[0]);
        lastLine.replace(null, to.ch, newText[newText.length-1]);
        firstLine.fixMarkEnds(lastLine);
        for (var i = 1, e = newText.length - 1; i < e; ++i)
          added.push(Line.inheritMarks(newText[i], firstLine));
        if (nlines > 1) doc.remove(from.line + 1, nlines - 1, callbacks);
        doc.insert(from.line + 1, added);
      }
      if (options.lineWrapping) {
        var perLine = scroller.clientWidth / charWidth() - 3;
        doc.iter(from.line, from.line + newText.length, function(line) {
          if (line.hidden) return;
          var guess = Math.ceil(line.text.length / perLine) || 1;
          if (guess != line.height) updateLineHeight(line, guess);
        });
      } else {
        doc.iter(from.line, i + newText.length, function(line) {
          var l = line.text;
          if (l.length > maxLineLength) {
            maxLine = l; maxLineLength = l.length; maxWidth = null;
            recomputeMaxLength = false;
          }
        });
        if (recomputeMaxLength) {
          maxLineLength = 0; maxLine = ""; maxWidth = null;
          doc.iter(0, doc.size, function(line) {
            var l = line.text;
            if (l.length > maxLineLength) {
              maxLineLength = l.length; maxLine = l;
            }
          });
        }
      }

      // Add these lines to the work array, so that they will be
      // highlighted. Adjust work lines if lines were added/removed.
      var newWork = [], lendiff = newText.length - nlines - 1;
      for (var i = 0, l = work.length; i < l; ++i) {
        var task = work[i];
        if (task < from.line) newWork.push(task);
        else if (task > to.line) newWork.push(task + lendiff);
      }
      var hlEnd = from.line + Math.min(newText.length, 500);
      highlightLines(from.line, hlEnd);
      newWork.push(hlEnd);
      work = newWork;
      startWorker(100);
      // Remember that these lines changed, for updating the display
      changes.push({from: from.line, to: to.line + 1, diff: lendiff});
      var changeObj = {from: from, to: to, text: newText};
      if (textChanged) {
        for (var cur = textChanged; cur.next; cur = cur.next) {}
        cur.next = changeObj;
      } else textChanged = changeObj;

      // Update the selection
      function updateLine(n) {return n <= Math.min(to.line, to.line + lendiff) ? n : n + lendiff;}
      setSelection(selFrom, selTo, updateLine(sel.from.line), updateLine(sel.to.line));

      // Make sure the scroll-size div has the correct height.
      if (scroller.clientHeight)
        code.style.height = (doc.height * textHeight() + 2 * paddingTop()) + "px";
    }

    function replaceRange(code, from, to) {
      from = clipPos(from);
      if (!to) to = from; else to = clipPos(to);
      code = splitLines(code);
      function adjustPos(pos) {
        if (posLess(pos, from)) return pos;
        if (!posLess(to, pos)) return end;
        var line = pos.line + code.length - (to.line - from.line) - 1;
        var ch = pos.ch;
        if (pos.line == to.line)
          ch += code[code.length-1].length - (to.ch - (to.line == from.line ? from.ch : 0));
        return {line: line, ch: ch};
      }
      var end;
      replaceRange1(code, from, to, function(end1) {
        end = end1;
        return {from: adjustPos(sel.from), to: adjustPos(sel.to)};
      });
      return end;
    }
    function replaceSelection(code, collapse) {
      replaceRange1(splitLines(code), sel.from, sel.to, function(end) {
        if (collapse == "end") return {from: end, to: end};
        else if (collapse == "start") return {from: sel.from, to: sel.from};
        else return {from: sel.from, to: end};
      });
    }
    function replaceRange1(code, from, to, computeSel) {
      var endch = code.length == 1 ? code[0].length + from.ch : code[code.length-1].length;
      var newSel = computeSel({line: from.line + code.length - 1, ch: endch});
      updateLines(from, to, code, newSel.from, newSel.to);
    }

    function getRange(from, to) {
      var l1 = from.line, l2 = to.line;
      if (l1 == l2) return getLine(l1).text.slice(from.ch, to.ch);
      var code = [getLine(l1).text.slice(from.ch)];
      doc.iter(l1 + 1, l2, function(line) { code.push(line.text); });
      code.push(getLine(l2).text.slice(0, to.ch));
      return code.join("\n");
    }
    function getSelection() {
      return getRange(sel.from, sel.to);
    }

    var pollingFast = false; // Ensures slowPoll doesn't cancel fastPoll
    function slowPoll() {
      if (pollingFast) return;
      poll.set(options.pollInterval, function() {
        startOperation();
        readInput();
        if (focused) slowPoll();
        endOperation();
      });
    }
    function fastPoll() {
      var missed = false;
      pollingFast = true;
      function p() {
        startOperation();
        var changed = readInput();
        if (!changed && !missed) {missed = true; poll.set(60, p);}
        else {pollingFast = false; slowPoll();}
        endOperation();
      }
      poll.set(20, p);
    }

    // Previnput is a hack to work with IME. If we reset the textarea
    // on every change, that breaks IME. So we look for changes
    // compared to the previous content instead. (Modern browsers have
    // events that indicate IME taking place, but these are not widely
    // supported or compatible enough yet to rely on.)
    var prevInput = "";
    function readInput() {
      if (leaveInputAlone || !focused || hasSelection(input) || options.readOnly) return false;
      var text = input.value;
      if (text == prevInput) return false;
      shiftSelecting = null;
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput[same] == text[same]) ++same;
      if (same < prevInput.length)
        sel.from = {line: sel.from.line, ch: sel.from.ch - (prevInput.length - same)};
      else if (overwrite && posEq(sel.from, sel.to))
        sel.to = {line: sel.to.line, ch: Math.min(getLine(sel.to.line).text.length, sel.to.ch + (text.length - same))};
      replaceSelection(text.slice(same), "end");
      prevInput = text;
      return true;
    }
    function resetInput(user) {
      if (!posEq(sel.from, sel.to)) {
        prevInput = "";
        input.value = getSelection();
        selectInput(input);
      } else if (user) prevInput = input.value = "";
    }

    function focusInput() {
      if (options.readOnly != "nocursor") input.focus();
    }

    function scrollEditorIntoView() {
      if (!cursor.getBoundingClientRect) return;
      var rect = cursor.getBoundingClientRect();
      // IE returns bogus coordinates when the instance sits inside of an iframe and the cursor is hidden
      if (ie && rect.top == rect.bottom) return;
      var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
      if (rect.top < 0 || rect.bottom > winH) cursor.scrollIntoView();
    }
    function scrollCursorIntoView() {
      var cursor = localCoords(sel.inverted ? sel.from : sel.to);
      var x = options.lineWrapping ? Math.min(cursor.x, lineSpace.offsetWidth) : cursor.x;
      return scrollIntoView(x, cursor.y, x, cursor.yBot);
    }
    function scrollIntoView(x1, y1, x2, y2) {
      var pl = paddingLeft(), pt = paddingTop();
      y1 += pt; y2 += pt; x1 += pl; x2 += pl;
      var screen = scroller.clientHeight, screentop = scroller.scrollTop, scrolled = false, result = true;
      if (y1 < screentop) {scroller.scrollTop = Math.max(0, y1); scrolled = true;}
      else if (y2 > screentop + screen) {scroller.scrollTop = y2 - screen; scrolled = true;}

      var screenw = scroller.clientWidth, screenleft = scroller.scrollLeft;
      var gutterw = options.fixedGutter ? gutter.clientWidth : 0;
      if (x1 < screenleft + gutterw) {
        if (x1 < 50) x1 = 0;
        scroller.scrollLeft = Math.max(0, x1 - 10 - gutterw);
        scrolled = true;
      }
      else if (x2 > screenw + screenleft - 3) {
        scroller.scrollLeft = x2 + 10 - screenw;
        scrolled = true;
        if (x2 > code.clientWidth) result = false;
      }
      if (scrolled && options.onScroll) options.onScroll(instance);
      return result;
    }

    function visibleLines() {
      var lh = textHeight(), top = scroller.scrollTop - paddingTop();
      var from_height = Math.max(0, Math.floor(top / lh));
      var to_height = Math.ceil((top + scroller.clientHeight) / lh);
      return {from: lineAtHeight(doc, from_height),
              to: lineAtHeight(doc, to_height)};
    }
    // Uses a set of changes plus the current scroll position to
    // determine which DOM updates have to be made, and makes the
    // updates.
    function updateDisplay(changes, suppressCallback) {
      if (!scroller.clientWidth) {
        showingFrom = showingTo = displayOffset = 0;
        return;
      }
      // Compute the new visible window
      var visible = visibleLines();
      // Bail out if the visible area is already rendered and nothing changed.
      if (changes !== true && changes.length == 0 && visible.from > showingFrom && visible.to < showingTo) return;
      var from = Math.max(visible.from - 100, 0), to = Math.min(doc.size, visible.to + 100);
      if (showingFrom < from && from - showingFrom < 20) from = showingFrom;
      if (showingTo > to && showingTo - to < 20) to = Math.min(doc.size, showingTo);

      // Create a range of theoretically intact lines, and punch holes
      // in that using the change info.
      var intact = changes === true ? [] :
        computeIntact([{from: showingFrom, to: showingTo, domStart: 0}], changes);
      // Clip off the parts that won't be visible
      var intactLines = 0;
      for (var i = 0; i < intact.length; ++i) {
        var range = intact[i];
        if (range.from < from) {range.domStart += (from - range.from); range.from = from;}
        if (range.to > to) range.to = to;
        if (range.from >= range.to) intact.splice(i--, 1);
        else intactLines += range.to - range.from;
      }
      if (intactLines == to - from) return;
      intact.sort(function(a, b) {return a.domStart - b.domStart;});

      var th = textHeight(), gutterDisplay = gutter.style.display;
      lineDiv.style.display = "none";
      patchDisplay(from, to, intact);
      lineDiv.style.display = gutter.style.display = "";

      // Position the mover div to align with the lines it's supposed
      // to be showing (which will cover the visible display)
      var different = from != showingFrom || to != showingTo || lastSizeC != scroller.clientHeight + th;
      // This is just a bogus formula that detects when the editor is
      // resized or the font size changes.
      if (different) lastSizeC = scroller.clientHeight + th;
      showingFrom = from; showingTo = to;
      displayOffset = heightAtLine(doc, from);
      mover.style.top = (displayOffset * th) + "px";
      if (scroller.clientHeight)
        code.style.height = (doc.height * th + 2 * paddingTop()) + "px";

      // Since this is all rather error prone, it is honoured with the
      // only assertion in the whole file.
      if (lineDiv.childNodes.length != showingTo - showingFrom)
        throw new Error("BAD PATCH! " + JSON.stringify(intact) + " size=" + (showingTo - showingFrom) +
                        " nodes=" + lineDiv.childNodes.length);

      if (options.lineWrapping) {
        maxWidth = scroller.clientWidth;
        var curNode = lineDiv.firstChild, heightChanged = false;
        doc.iter(showingFrom, showingTo, function(line) {
          if (!line.hidden) {
            var height = Math.round(curNode.offsetHeight / th) || 1;
            if (line.height != height) {
              updateLineHeight(line, height);
              gutterDirty = heightChanged = true;
            }
          }
          curNode = curNode.nextSibling;
        });
        if (heightChanged)
          code.style.height = (doc.height * th + 2 * paddingTop()) + "px";
      } else {
        if (maxWidth == null) maxWidth = stringWidth(maxLine);
        if (maxWidth > scroller.clientWidth) {
          lineSpace.style.width = maxWidth + "px";
          // Needed to prevent odd wrapping/hiding of widgets placed in here.
          code.style.width = "";
          code.style.width = scroller.scrollWidth + "px";
        } else {
          lineSpace.style.width = code.style.width = "";
        }
      }
      gutter.style.display = gutterDisplay;
      if (different || gutterDirty) updateGutter();
      updateSelection();
      if (!suppressCallback && options.onUpdate) options.onUpdate(instance);
      return true;
    }

    function computeIntact(intact, changes) {
      for (var i = 0, l = changes.length || 0; i < l; ++i) {
        var change = changes[i], intact2 = [], diff = change.diff || 0;
        for (var j = 0, l2 = intact.length; j < l2; ++j) {
          var range = intact[j];
          if (change.to <= range.from && change.diff)
            intact2.push({from: range.from + diff, to: range.to + diff,
                          domStart: range.domStart});
          else if (change.to <= range.from || change.from >= range.to)
            intact2.push(range);
          else {
            if (change.from > range.from)
              intact2.push({from: range.from, to: change.from, domStart: range.domStart});
            if (change.to < range.to)
              intact2.push({from: change.to + diff, to: range.to + diff,
                            domStart: range.domStart + (change.to - range.from)});
          }
        }
        intact = intact2;
      }
      return intact;
    }

    function patchDisplay(from, to, intact) {
      // The first pass removes the DOM nodes that aren't intact.
      if (!intact.length) lineDiv.innerHTML = "";
      else {
        function killNode(node) {
          var tmp = node.nextSibling;
          node.parentNode.removeChild(node);
          return tmp;
        }
        var domPos = 0, curNode = lineDiv.firstChild, n;
        for (var i = 0; i < intact.length; ++i) {
          var cur = intact[i];
          while (cur.domStart > domPos) {curNode = killNode(curNode); domPos++;}
          for (var j = 0, e = cur.to - cur.from; j < e; ++j) {curNode = curNode.nextSibling; domPos++;}
        }
        while (curNode) curNode = killNode(curNode);
      }
      // This pass fills in the lines that actually changed.
      var nextIntact = intact.shift(), curNode = lineDiv.firstChild, j = from;
      var scratch = document.createElement("div");
      doc.iter(from, to, function(line) {
        if (nextIntact && nextIntact.to == j) nextIntact = intact.shift();
        if (!nextIntact || nextIntact.from > j) {
          if (line.hidden) var html = scratch.innerHTML = "<pre></pre>";
          else {
            var html = '<pre' + (line.className ? ' class="' + line.className + '"' : '') + '>'
              + line.getHTML(makeTab) + '</pre>';
            // Kludge to make sure the styled element lies behind the selection (by z-index)
            if (line.bgClassName)
              html = '<div style="position: relative"><pre class="' + line.bgClassName +
              '" style="position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: -2">&#160;</pre>' + html + "</div>";
          }
          scratch.innerHTML = html;
          lineDiv.insertBefore(scratch.firstChild, curNode);
        } else {
          curNode = curNode.nextSibling;
        }
        ++j;
      });
    }

    function updateGutter() {
      if (!options.gutter && !options.lineNumbers) return;
      var hText = mover.offsetHeight, hEditor = scroller.clientHeight;
      gutter.style.height = (hText - hEditor < 2 ? hEditor : hText) + "px";
      var html = [], i = showingFrom, normalNode;
      doc.iter(showingFrom, Math.max(showingTo, showingFrom + 1), function(line) {
        if (line.hidden) {
          html.push("<pre></pre>");
        } else {
          var marker = line.gutterMarker;
          var text = options.lineNumbers ? i + options.firstLineNumber : null;
          if (marker && marker.text)
            text = marker.text.replace("%N%", text != null ? text : "");
          else if (text == null)
            text = "\u00a0";
          html.push((marker && marker.style ? '<pre class="' + marker.style + '">' : "<pre>"), text);
          for (var j = 1; j < line.height; ++j) html.push("<br/>&#160;");
          html.push("</pre>");
          if (!marker) normalNode = i;
        }
        ++i;
      });
      gutter.style.display = "none";
      gutterText.innerHTML = html.join("");
      // Make sure scrolling doesn't cause number gutter size to pop
      if (normalNode != null) {
        var node = gutterText.childNodes[normalNode - showingFrom];
        var minwidth = String(doc.size).length, val = eltText(node), pad = "";
        while (val.length + pad.length < minwidth) pad += "\u00a0";
        if (pad) node.insertBefore(document.createTextNode(pad), node.firstChild);
      }
      gutter.style.display = "";
      lineSpace.style.marginLeft = gutter.offsetWidth + "px";
      gutterDirty = false;
    }
    function updateSelection() {
      var collapsed = posEq(sel.from, sel.to);
      var fromPos = localCoords(sel.from, true);
      var toPos = collapsed ? fromPos : localCoords(sel.to, true);
      var headPos = sel.inverted ? fromPos : toPos, th = textHeight();
      var wrapOff = eltOffset(wrapper), lineOff = eltOffset(lineDiv);
      inputDiv.style.top = Math.max(0, Math.min(scroller.offsetHeight, headPos.y + lineOff.top - wrapOff.top)) + "px";
      inputDiv.style.left = Math.max(0, Math.min(scroller.offsetWidth, headPos.x + lineOff.left - wrapOff.left)) + "px";
      if (collapsed) {
        cursor.style.top = headPos.y + "px";
        cursor.style.left = (options.lineWrapping ? Math.min(headPos.x, lineSpace.offsetWidth) : headPos.x) + "px";
        cursor.style.display = "";
        selectionDiv.style.display = "none";
      } else {
        var sameLine = fromPos.y == toPos.y, html = "";
        function add(left, top, right, height) {
          html += '<div class="CodeMirror-selected" style="position: absolute; left: ' + left +
            'px; top: ' + top + 'px; right: ' + right + 'px; height: ' + height + 'px"></div>';
        }
        var clientWidth = lineSpace.clientWidth || lineSpace.offsetWidth;
        var clientHeight = lineSpace.clientHeight || lineSpace.offsetHeight;
        if (sel.from.ch && fromPos.y >= 0) {
          var right = sameLine ? clientWidth - toPos.x : 0;
          add(fromPos.x, fromPos.y, right, th);
        }
        var middleStart = Math.max(0, fromPos.y + (sel.from.ch ? th : 0));
        var middleHeight = Math.min(toPos.y, clientHeight) - middleStart;
        if (middleHeight > 0.2 * th)
          add(0, middleStart, 0, middleHeight);
        if ((!sameLine || !sel.from.ch) && toPos.y < clientHeight - .5 * th)
          add(0, toPos.y, clientWidth - toPos.x, th);
        selectionDiv.innerHTML = html;
        cursor.style.display = "none";
        selectionDiv.style.display = "";
      }
    }

    function setShift(val) {
      if (val) shiftSelecting = shiftSelecting || (sel.inverted ? sel.to : sel.from);
      else shiftSelecting = null;
    }
    function setSelectionUser(from, to) {
      var sh = shiftSelecting && clipPos(shiftSelecting);
      if (sh) {
        if (posLess(sh, from)) from = sh;
        else if (posLess(to, sh)) to = sh;
      }
      setSelection(from, to);
      userSelChange = true;
    }
    // Update the selection. Last two args are only used by
    // updateLines, since they have to be expressed in the line
    // numbers before the update.
    function setSelection(from, to, oldFrom, oldTo) {
      goalColumn = null;
      if (oldFrom == null) {oldFrom = sel.from.line; oldTo = sel.to.line;}
      if (posEq(sel.from, from) && posEq(sel.to, to)) return;
      if (posLess(to, from)) {var tmp = to; to = from; from = tmp;}

      // Skip over hidden lines.
      if (from.line != oldFrom) {
        var from1 = skipHidden(from, oldFrom, sel.from.ch);
        // If there is no non-hidden line left, force visibility on current line
        if (!from1) setLineHidden(from.line, false);
        else from = from1;
      }
      if (to.line != oldTo) to = skipHidden(to, oldTo, sel.to.ch);

      if (posEq(from, to)) sel.inverted = false;
      else if (posEq(from, sel.to)) sel.inverted = false;
      else if (posEq(to, sel.from)) sel.inverted = true;

      if (options.autoClearEmptyLines && posEq(sel.from, sel.to)) {
        var head = sel.inverted ? from : to;
        if (head.line != sel.from.line && sel.from.line < doc.size) {
          var oldLine = getLine(sel.from.line);
          if (/^\s+$/.test(oldLine.text))
            setTimeout(operation(function() {
              if (oldLine.parent && /^\s+$/.test(oldLine.text)) {
                var no = lineNo(oldLine);
                replaceRange("", {line: no, ch: 0}, {line: no, ch: oldLine.text.length});
              }
            }, 10));
        }
      }

      sel.from = from; sel.to = to;
      selectionChanged = true;
    }
    function skipHidden(pos, oldLine, oldCh) {
      function getNonHidden(dir) {
        var lNo = pos.line + dir, end = dir == 1 ? doc.size : -1;
        while (lNo != end) {
          var line = getLine(lNo);
          if (!line.hidden) {
            var ch = pos.ch;
            if (ch > oldCh || ch > line.text.length) ch = line.text.length;
            return {line: lNo, ch: ch};
          }
          lNo += dir;
        }
      }
      var line = getLine(pos.line);
      if (!line.hidden) return pos;
      if (pos.line >= oldLine) return getNonHidden(1) || getNonHidden(-1);
      else return getNonHidden(-1) || getNonHidden(1);
    }
    function setCursor(line, ch, user) {
      var pos = clipPos({line: line, ch: ch || 0});
      (user ? setSelectionUser : setSelection)(pos, pos);
    }

    function clipLine(n) {return Math.max(0, Math.min(n, doc.size-1));}
    function clipPos(pos) {
      if (pos.line < 0) return {line: 0, ch: 0};
      if (pos.line >= doc.size) return {line: doc.size-1, ch: getLine(doc.size-1).text.length};
      var ch = pos.ch, linelen = getLine(pos.line).text.length;
      if (ch == null || ch > linelen) return {line: pos.line, ch: linelen};
      else if (ch < 0) return {line: pos.line, ch: 0};
      else return pos;
    }

    function findPosH(dir, unit) {
      var end = sel.inverted ? sel.from : sel.to, line = end.line, ch = end.ch;
      var lineObj = getLine(line);
      function findNextLine() {
        for (var l = line + dir, e = dir < 0 ? -1 : doc.size; l != e; l += dir) {
          var lo = getLine(l);
          if (!lo.hidden) { line = l; lineObj = lo; return true; }
        }
      }
      function moveOnce(boundToLine) {
        if (ch == (dir < 0 ? 0 : lineObj.text.length)) {
          if (!boundToLine && findNextLine()) ch = dir < 0 ? lineObj.text.length : 0;
          else return false;
        } else ch += dir;
        return true;
      }
      if (unit == "char") moveOnce();
      else if (unit == "column") moveOnce(true);
      else if (unit == "word") {
        var sawWord = false;
        for (;;) {
          if (dir < 0) if (!moveOnce()) break;
          if (isWordChar(lineObj.text.charAt(ch))) sawWord = true;
          else if (sawWord) {if (dir < 0) {dir = 1; moveOnce();} break;}
          if (dir > 0) if (!moveOnce()) break;
        }
      }
      return {line: line, ch: ch};
    }
    function moveH(dir, unit) {
      var pos = dir < 0 ? sel.from : sel.to;
      if (shiftSelecting || posEq(sel.from, sel.to)) pos = findPosH(dir, unit);
      setCursor(pos.line, pos.ch, true);
    }
    function deleteH(dir, unit) {
      if (!posEq(sel.from, sel.to)) replaceRange("", sel.from, sel.to);
      else if (dir < 0) replaceRange("", findPosH(dir, unit), sel.to);
      else replaceRange("", sel.from, findPosH(dir, unit));
      userSelChange = true;
    }
    var goalColumn = null;
    function moveV(dir, unit) {
      var dist = 0, pos = localCoords(sel.inverted ? sel.from : sel.to, true);
      if (goalColumn != null) pos.x = goalColumn;
      if (unit == "page") dist = Math.min(scroller.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      else if (unit == "line") dist = textHeight();
      var target = coordsChar(pos.x, pos.y + dist * dir + 2);
      if (unit == "page") scroller.scrollTop += localCoords(target, true).y - pos.y;
      setCursor(target.line, target.ch, true);
      goalColumn = pos.x;
    }

    function selectWordAt(pos) {
      var line = getLine(pos.line).text;
      var start = pos.ch, end = pos.ch;
      while (start > 0 && isWordChar(line.charAt(start - 1))) --start;
      while (end < line.length && isWordChar(line.charAt(end))) ++end;
      setSelectionUser({line: pos.line, ch: start}, {line: pos.line, ch: end});
    }
    function selectLine(line) {
      setSelectionUser({line: line, ch: 0}, clipPos({line: line + 1, ch: 0}));
    }
    function indentSelected(mode) {
      if (posEq(sel.from, sel.to)) return indentLine(sel.from.line, mode);
      var e = sel.to.line - (sel.to.ch ? 0 : 1);
      for (var i = sel.from.line; i <= e; ++i) indentLine(i, mode);
    }

    function indentLine(n, how) {
      if (!how) how = "add";
      if (how == "smart") {
        if (!mode.indent) how = "prev";
        else var state = getStateBefore(n);
      }

      var line = getLine(n), curSpace = line.indentation(options.tabSize),
          curSpaceString = line.text.match(/^\s*/)[0], indentation;
      if (how == "prev") {
        if (n) indentation = getLine(n-1).indentation(options.tabSize);
        else indentation = 0;
      }
      else if (how == "smart") indentation = mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      else if (how == "add") indentation = curSpace + options.indentUnit;
      else if (how == "subtract") indentation = curSpace - options.indentUnit;
      indentation = Math.max(0, indentation);
      var diff = indentation - curSpace;

      if (!diff) {
        if (sel.from.line != n && sel.to.line != n) return;
        var indentString = curSpaceString;
      }
      else {
        var indentString = "", pos = 0;
        if (options.indentWithTabs)
          for (var i = Math.floor(indentation / options.tabSize); i; --i) {pos += options.tabSize; indentString += "\t";}
        while (pos < indentation) {++pos; indentString += " ";}
      }

      replaceRange(indentString, {line: n, ch: 0}, {line: n, ch: curSpaceString.length});
    }

    function loadMode() {
      mode = CodeMirror.getMode(options, options.mode);
      doc.iter(0, doc.size, function(line) { line.stateAfter = null; });
      work = [0];
      startWorker();
    }
    function gutterChanged() {
      var visible = options.gutter || options.lineNumbers;
      gutter.style.display = visible ? "" : "none";
      if (visible) gutterDirty = true;
      else lineDiv.parentNode.style.marginLeft = 0;
    }
    function wrappingChanged(from, to) {
      if (options.lineWrapping) {
        wrapper.className += " CodeMirror-wrap";
        var perLine = scroller.clientWidth / charWidth() - 3;
        doc.iter(0, doc.size, function(line) {
          if (line.hidden) return;
          var guess = Math.ceil(line.text.length / perLine) || 1;
          if (guess != 1) updateLineHeight(line, guess);
        });
        lineSpace.style.width = code.style.width = "";
      } else {
        wrapper.className = wrapper.className.replace(" CodeMirror-wrap", "");
        maxWidth = null; maxLine = "";
        doc.iter(0, doc.size, function(line) {
          if (line.height != 1 && !line.hidden) updateLineHeight(line, 1);
          if (line.text.length > maxLine.length) maxLine = line.text;
        });
      }
      changes.push({from: 0, to: doc.size});
    }
    function makeTab(col) {
      var w = options.tabSize - col % options.tabSize, cached = tabCache[w];
      if (cached) return cached;
      for (var str = '<span class="cm-tab">', i = 0; i < w; ++i) str += " ";
      return (tabCache[w] = {html: str + "</span>", width: w});
    }
    function themeChanged() {
      scroller.className = scroller.className.replace(/\s*cm-s-\w+/g, "") +
        options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    }

    function TextMarker() { this.set = []; }
    TextMarker.prototype.clear = operation(function() {
      var min = Infinity, max = -Infinity;
      for (var i = 0, e = this.set.length; i < e; ++i) {
        var line = this.set[i], mk = line.marked;
        if (!mk || !line.parent) continue;
        var lineN = lineNo(line);
        min = Math.min(min, lineN); max = Math.max(max, lineN);
        for (var j = 0; j < mk.length; ++j)
          if (mk[j].marker == this) mk.splice(j--, 1);
      }
      if (min != Infinity)
        changes.push({from: min, to: max + 1});
    });
    TextMarker.prototype.find = function() {
      var from, to;
      for (var i = 0, e = this.set.length; i < e; ++i) {
        var line = this.set[i], mk = line.marked;
        for (var j = 0; j < mk.length; ++j) {
          var mark = mk[j];
          if (mark.marker == this) {
            if (mark.from != null || mark.to != null) {
              var found = lineNo(line);
              if (found != null) {
                if (mark.from != null) from = {line: found, ch: mark.from};
                if (mark.to != null) to = {line: found, ch: mark.to};
              }
            }
          }
        }
      }
      return {from: from, to: to};
    };

    function markText(from, to, className) {
      from = clipPos(from); to = clipPos(to);
      var tm = new TextMarker();
      if (!posLess(from, to)) return tm;
      function add(line, from, to, className) {
        getLine(line).addMark(new MarkedText(from, to, className, tm));
      }
      if (from.line == to.line) add(from.line, from.ch, to.ch, className);
      else {
        add(from.line, from.ch, null, className);
        for (var i = from.line + 1, e = to.line; i < e; ++i)
          add(i, null, null, className);
        add(to.line, null, to.ch, className);
      }
      changes.push({from: from.line, to: to.line + 1});
      return tm;
    }

    function setBookmark(pos) {
      pos = clipPos(pos);
      var bm = new Bookmark(pos.ch);
      getLine(pos.line).addMark(bm);
      return bm;
    }

    function findMarksAt(pos) {
      pos = clipPos(pos);
      var markers = [], marked = getLine(pos.line).marked;
      if (!marked) return markers;
      for (var i = 0, e = marked.length; i < e; ++i) {
        var m = marked[i];
        if ((m.from == null || m.from <= pos.ch) &&
            (m.to == null || m.to >= pos.ch))
          markers.push(m.marker || m);
      }
      return markers;
    }

    function addGutterMarker(line, text, className) {
      if (typeof line == "number") line = getLine(clipLine(line));
      line.gutterMarker = {text: text, style: className};
      gutterDirty = true;
      return line;
    }
    function removeGutterMarker(line) {
      if (typeof line == "number") line = getLine(clipLine(line));
      line.gutterMarker = null;
      gutterDirty = true;
    }

    function changeLine(handle, op) {
      var no = handle, line = handle;
      if (typeof handle == "number") line = getLine(clipLine(handle));
      else no = lineNo(handle);
      if (no == null) return null;
      if (op(line, no)) changes.push({from: no, to: no + 1});
      else return null;
      return line;
    }
    function setLineClass(handle, className, bgClassName) {
      return changeLine(handle, function(line) {
        if (line.className != className || line.bgClassName != bgClassName) {
          line.className = className;
          line.bgClassName = bgClassName;
          return true;
        }
      });
    }
    function setLineHidden(handle, hidden) {
      return changeLine(handle, function(line, no) {
        if (line.hidden != hidden) {
          line.hidden = hidden;
          updateLineHeight(line, hidden ? 0 : 1);
          var fline = sel.from.line, tline = sel.to.line;
          if (hidden && (fline == no || tline == no)) {
            var from = fline == no ? skipHidden({line: fline, ch: 0}, fline, 0) : sel.from;
            var to = tline == no ? skipHidden({line: tline, ch: 0}, tline, 0) : sel.to;
            // Can't hide the last visible line, we'd have no place to put the cursor
            if (!to) return;
            setSelection(from, to);
          }
          return (gutterDirty = true);
        }
      });
    }

    function lineInfo(line) {
      if (typeof line == "number") {
        if (!isLine(line)) return null;
        var n = line;
        line = getLine(line);
        if (!line) return null;
      }
      else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      var marker = line.gutterMarker;
      return {line: n, handle: line, text: line.text, markerText: marker && marker.text,
              markerClass: marker && marker.style, lineClass: line.className, bgClass: line.bgClassName};
    }

    function stringWidth(str) {
      measure.innerHTML = "<pre><span>x</span></pre>";
      measure.firstChild.firstChild.firstChild.nodeValue = str;
      return measure.firstChild.firstChild.offsetWidth || 10;
    }
    // These are used to go from pixel positions to character
    // positions, taking varying character widths into account.
    function charFromX(line, x) {
      if (x <= 0) return 0;
      var lineObj = getLine(line), text = lineObj.text;
      function getX(len) {
        measure.innerHTML = "<pre><span>" + lineObj.getHTML(makeTab, len) + "</span></pre>";
        return measure.firstChild.firstChild.offsetWidth;
      }
      var from = 0, fromX = 0, to = text.length, toX;
      // Guess a suitable upper bound for our search.
      var estimated = Math.min(to, Math.ceil(x / charWidth()));
      for (;;) {
        var estX = getX(estimated);
        if (estX <= x && estimated < to) estimated = Math.min(to, Math.ceil(estimated * 1.2));
        else {toX = estX; to = estimated; break;}
      }
      if (x > toX) return to;
      // Try to guess a suitable lower bound as well.
      estimated = Math.floor(to * 0.8); estX = getX(estimated);
      if (estX < x) {from = estimated; fromX = estX;}
      // Do a binary search between these bounds.
      for (;;) {
        if (to - from <= 1) return (toX - x > x - fromX) ? from : to;
        var middle = Math.ceil((from + to) / 2), middleX = getX(middle);
        if (middleX > x) {to = middle; toX = middleX;}
        else {from = middle; fromX = middleX;}
      }
    }

    var tempId = Math.floor(Math.random() * 0xffffff).toString(16);
    function measureLine(line, ch) {
      if (ch == 0) return {top: 0, left: 0};
      var extra = "";
      // Include extra text at the end to make sure the measured line is wrapped in the right way.
      if (options.lineWrapping) {
        var end = line.text.indexOf(" ", ch + 6);
        extra = htmlEscape(line.text.slice(ch + 1, end < 0 ? line.text.length : end + (ie ? 5 : 0)));
      }
      measure.innerHTML = "<pre>" + line.getHTML(makeTab, ch) +
        '<span id="CodeMirror-temp-' + tempId + '">' + htmlEscape(line.text.charAt(ch) || " ") + "</span>" +
        extra + "</pre>";
      var elt = GEBID("CodeMirror-temp-" + tempId);
      var top = elt.offsetTop, left = elt.offsetLeft;
      // Older IEs report zero offsets for spans directly after a wrap
      if (ie && top == 0 && left == 0) {
        var backup = document.createElement("span");
        backup.innerHTML = "x";
        elt.parentNode.insertBefore(backup, elt.nextSibling);
        top = backup.offsetTop;
      }
      return {top: top, left: left};
    }
    function localCoords(pos, inLineWrap) {
      var x, lh = textHeight(), y = lh * (heightAtLine(doc, pos.line) - (inLineWrap ? displayOffset : 0));
      if (pos.ch == 0) x = 0;
      else {
        var sp = measureLine(getLine(pos.line), pos.ch);
        x = sp.left;
        if (options.lineWrapping) y += Math.max(0, sp.top);
      }
      return {x: x, y: y, yBot: y + lh};
    }
    // Coords must be lineSpace-local
    function coordsChar(x, y) {
      if (y < 0) y = 0;
      var th = textHeight(), cw = charWidth(), heightPos = displayOffset + Math.floor(y / th);
      var lineNo = lineAtHeight(doc, heightPos);
      if (lineNo >= doc.size) return {line: doc.size - 1, ch: getLine(doc.size - 1).text.length};
      var lineObj = getLine(lineNo), text = lineObj.text;
      var tw = options.lineWrapping, innerOff = tw ? heightPos - heightAtLine(doc, lineNo) : 0;
      if (x <= 0 && innerOff == 0) return {line: lineNo, ch: 0};
      function getX(len) {
        var sp = measureLine(lineObj, len);
        if (tw) {
          var off = Math.round(sp.top / th);
          return Math.max(0, sp.left + (off - innerOff) * scroller.clientWidth);
        }
        return sp.left;
      }
      var from = 0, fromX = 0, to = text.length, toX;
      // Guess a suitable upper bound for our search.
      var estimated = Math.min(to, Math.ceil((x + innerOff * scroller.clientWidth * .9) / cw));
      for (;;) {
        var estX = getX(estimated);
        if (estX <= x && estimated < to) estimated = Math.min(to, Math.ceil(estimated * 1.2));
        else {toX = estX; to = estimated; break;}
      }
      if (x > toX) return {line: lineNo, ch: to};
      // Try to guess a suitable lower bound as well.
      estimated = Math.floor(to * 0.8); estX = getX(estimated);
      if (estX < x) {from = estimated; fromX = estX;}
      // Do a binary search between these bounds.
      for (;;) {
        if (to - from <= 1) return {line: lineNo, ch: (toX - x > x - fromX) ? from : to};
        var middle = Math.ceil((from + to) / 2), middleX = getX(middle);
        if (middleX > x) {to = middle; toX = middleX;}
        else {from = middle; fromX = middleX;}
      }
    }
    function pageCoords(pos) {
      var local = localCoords(pos, true), off = eltOffset(lineSpace);
      return {x: off.left + local.x, y: off.top + local.y, yBot: off.top + local.yBot};
    }

    var cachedHeight, cachedHeightFor, measureText;
    function textHeight() {
      if (measureText == null) {
        measureText = "<pre>";
        for (var i = 0; i < 49; ++i) measureText += "x<br/>";
        measureText += "x</pre>";
      }
      var offsetHeight = lineDiv.clientHeight;
      if (offsetHeight == cachedHeightFor) return cachedHeight;
      cachedHeightFor = offsetHeight;
      measure.innerHTML = measureText;
      cachedHeight = measure.firstChild.offsetHeight / 50 || 1;
      measure.innerHTML = "";
      return cachedHeight;
    }
    var cachedWidth, cachedWidthFor = 0;
    function charWidth() {
      if (scroller.clientWidth == cachedWidthFor) return cachedWidth;
      cachedWidthFor = scroller.clientWidth;
      return (cachedWidth = stringWidth("x"));
    }
    function paddingTop() {return lineSpace.offsetTop;}
    function paddingLeft() {return lineSpace.offsetLeft;}

    function posFromMouse(e, liberal) {
      var offW = eltOffset(scroller, true), x, y;
      // Fails unpredictably on IE[67] when mouse is dragged around quickly.
      try { x = e.clientX; y = e.clientY; } catch (e) { return null; }
      // This is a mess of a heuristic to try and determine whether a
      // scroll-bar was clicked or not, and to return null if one was
      // (and !liberal).
      if (!liberal && (x - offW.left > scroller.clientWidth || y - offW.top > scroller.clientHeight))
        return null;
      var offL = eltOffset(lineSpace, true);
      return coordsChar(x - offL.left, y - offL.top);
    }
    function onContextMenu(e) {
      var pos = posFromMouse(e), scrollPos = scroller.scrollTop;
      if (!pos || window.opera) return; // Opera is difficult.
      if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
        operation(setCursor)(pos.line, pos.ch);

      var oldCSS = input.style.cssText;
      inputDiv.style.position = "absolute";
      input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
        "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: white; " +
        "border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      leaveInputAlone = true;
      var val = input.value = getSelection();
      focusInput();
      selectInput(input);
      function rehide() {
        var newVal = splitLines(input.value).join("\n");
        if (newVal != val) operation(replaceSelection)(newVal, "end");
        inputDiv.style.position = "relative";
        input.style.cssText = oldCSS;
        if (ie_lt9) scroller.scrollTop = scrollPos;
        leaveInputAlone = false;
        resetInput(true);
        slowPoll();
      }

      if (gecko) {
        e_stop(e);
        var mouseup = connect(window, "mouseup", function() {
          mouseup();
          setTimeout(rehide, 20);
        }, true);
      } else {
        setTimeout(rehide, 50);
      }
    }

    // Cursor-blinking
    function restartBlink() {
      clearInterval(blinker);
      var on = true;
      cursor.style.visibility = "";
      blinker = setInterval(function() {
        cursor.style.visibility = (on = !on) ? "" : "hidden";
      }, 650);
    }

    var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<"};
    function matchBrackets(autoclear) {
      var head = sel.inverted ? sel.from : sel.to, line = getLine(head.line), pos = head.ch - 1;
      var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];
      if (!match) return;
      var ch = match.charAt(0), forward = match.charAt(1) == ">", d = forward ? 1 : -1, st = line.styles;
      for (var off = pos + 1, i = 0, e = st.length; i < e; i+=2)
        if ((off -= st[i].length) <= 0) {var style = st[i+1]; break;}

      var stack = [line.text.charAt(pos)], re = /[(){}[\]]/;
      function scan(line, from, to) {
        if (!line.text) return;
        var st = line.styles, pos = forward ? 0 : line.text.length - 1, cur;
        for (var i = forward ? 0 : st.length - 2, e = forward ? st.length : -2; i != e; i += 2*d) {
          var text = st[i];
          if (st[i+1] != null && st[i+1] != style) {pos += d * text.length; continue;}
          for (var j = forward ? 0 : text.length - 1, te = forward ? text.length : -1; j != te; j += d, pos+=d) {
            if (pos >= from && pos < to && re.test(cur = text.charAt(j))) {
              var match = matching[cur];
              if (match.charAt(1) == ">" == forward) stack.push(cur);
              else if (stack.pop() != match.charAt(0)) return {pos: pos, match: false};
              else if (!stack.length) return {pos: pos, match: true};
            }
          }
        }
      }
      for (var i = head.line, e = forward ? Math.min(i + 100, doc.size) : Math.max(-1, i - 100); i != e; i+=d) {
        var line = getLine(i), first = i == head.line;
        var found = scan(line, first && forward ? pos + 1 : 0, first && !forward ? pos : line.text.length);
        if (found) break;
      }
      if (!found) found = {pos: null, match: false};
      var style = found.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
      var one = markText({line: head.line, ch: pos}, {line: head.line, ch: pos+1}, style),
          two = found.pos != null && markText({line: i, ch: found.pos}, {line: i, ch: found.pos + 1}, style);
      var clear = operation(function(){one.clear(); two && two.clear();});
      if (autoclear) setTimeout(clear, 800);
      else bracketHighlighted = clear;
    }

    // Finds the line to start with when starting a parse. Tries to
    // find a line with a stateAfter, so that it can start with a
    // valid state. If that fails, it returns the line with the
    // smallest indentation, which tends to need the least context to
    // parse correctly.
    function findStartLine(n) {
      var minindent, minline;
      for (var search = n, lim = n - 40; search > lim; --search) {
        if (search == 0) return 0;
        var line = getLine(search-1);
        if (line.stateAfter) return search;
        var indented = line.indentation(options.tabSize);
        if (minline == null || minindent > indented) {
          minline = search - 1;
          minindent = indented;
        }
      }
      return minline;
    }
    function getStateBefore(n) {
      var start = findStartLine(n), state = start && getLine(start-1).stateAfter;
      if (!state) state = startState(mode);
      else state = copyState(mode, state);
      doc.iter(start, n, function(line) {
        line.highlight(mode, state, options.tabSize);
        line.stateAfter = copyState(mode, state);
      });
      if (start < n) changes.push({from: start, to: n});
      if (n < doc.size && !getLine(n).stateAfter) work.push(n);
      return state;
    }
    function highlightLines(start, end) {
      var state = getStateBefore(start);
      doc.iter(start, end, function(line) {
        line.highlight(mode, state, options.tabSize);
        line.stateAfter = copyState(mode, state);
      });
    }
    function highlightWorker() {
      var end = +new Date + options.workTime;
      var foundWork = work.length;
      while (work.length) {
        if (!getLine(showingFrom).stateAfter) var task = showingFrom;
        else var task = work.pop();
        if (task >= doc.size) continue;
        var start = findStartLine(task), state = start && getLine(start-1).stateAfter;
        if (state) state = copyState(mode, state);
        else state = startState(mode);

        var unchanged = 0, compare = mode.compareStates, realChange = false,
            i = start, bail = false;
        doc.iter(i, doc.size, function(line) {
          var hadState = line.stateAfter;
          if (+new Date > end) {
            work.push(i);
            startWorker(options.workDelay);
            if (realChange) changes.push({from: task, to: i + 1});
            return (bail = true);
          }
          var changed = line.highlight(mode, state, options.tabSize);
          if (changed) realChange = true;
          line.stateAfter = copyState(mode, state);
          if (compare) {
            if (hadState && compare(hadState, state)) return true;
          } else {
            if (changed !== false || !hadState) unchanged = 0;
            else if (++unchanged > 3 && (!mode.indent || mode.indent(hadState, "") == mode.indent(state, "")))
              return true;
          }
          ++i;
        });
        if (bail) return;
        if (realChange) changes.push({from: task, to: i + 1});
      }
      if (foundWork && options.onHighlightComplete)
        options.onHighlightComplete(instance);
    }
    function startWorker(time) {
      if (!work.length) return;
      highlight.set(time, operation(highlightWorker));
    }

    // Operations are used to wrap changes in such a way that each
    // change won't have to update the cursor and display (which would
    // be awkward, slow, and error-prone), but instead updates are
    // batched and then all combined and executed at once.
    function startOperation() {
      updateInput = userSelChange = textChanged = null;
      changes = []; selectionChanged = false; callbacks = [];
    }
    function endOperation() {
      var reScroll = false, updated;
      if (selectionChanged) reScroll = !scrollCursorIntoView();
      if (changes.length) updated = updateDisplay(changes, true);
      else {
        if (selectionChanged) updateSelection();
        if (gutterDirty) updateGutter();
      }
      if (reScroll) scrollCursorIntoView();
      if (selectionChanged) {scrollEditorIntoView(); restartBlink();}

      if (focused && !leaveInputAlone &&
          (updateInput === true || (updateInput !== false && selectionChanged)))
        resetInput(userSelChange);

      if (selectionChanged && options.matchBrackets)
        setTimeout(operation(function() {
          if (bracketHighlighted) {bracketHighlighted(); bracketHighlighted = null;}
          if (posEq(sel.from, sel.to)) matchBrackets(false);
        }), 20);
      var tc = textChanged, cbs = callbacks; // these can be reset by callbacks
      if (selectionChanged && options.onCursorActivity)
        options.onCursorActivity(instance);
      if (tc && options.onChange && instance)
        options.onChange(instance, tc);
      for (var i = 0; i < cbs.length; ++i) cbs[i](instance);
      if (updated && options.onUpdate) options.onUpdate(instance);
    }
    var nestedOperation = 0;
    function operation(f) {
      return function() {
        if (!nestedOperation++) startOperation();
        try {var result = f.apply(this, arguments);}
        finally {if (!--nestedOperation) endOperation();}
        return result;
      };
    }

    for (var ext in extensions)
      if (extensions.propertyIsEnumerable(ext) &&
          !instance.propertyIsEnumerable(ext))
        instance[ext] = extensions[ext];
    return instance;
  } // (end of function CodeMirror)

  // The default configuration options.
  CodeMirror.defaults = {
    value: "",
    mode: null,
    theme: "default",
    indentUnit: 2,
    indentWithTabs: false,
    smartIndent: true,
    tabSize: 4,
    keyMap: "default",
    extraKeys: null,
    electricChars: true,
    autoClearEmptyLines: false,
    onKeyEvent: null,
    lineWrapping: false,
    lineNumbers: false,
    gutter: false,
    fixedGutter: false,
    firstLineNumber: 1,
    readOnly: false,
    onChange: null,
    onCursorActivity: null,
    onGutterClick: null,
    onHighlightComplete: null,
    onUpdate: null,
    onFocus: null, onBlur: null, onScroll: null,
    matchBrackets: false,
    workTime: 100,
    workDelay: 200,
    pollInterval: 100,
    undoDepth: 40,
    tabindex: null,
    autofocus: null
  };

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var win = /Win/.test(navigator.platform);

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    modes[name] = mode;
  };
  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec))
      spec = mimeModes[spec];
    else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec))
      return CodeMirror.resolveMode("application/xml");
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) {
      if (window.console) console.warn("No mode " + spec.name + " found, falling back to plain text.");
      return CodeMirror.getMode(options, "text/plain");
    }
    return mfactory(options, spec);
  };
  CodeMirror.listModes = function() {
    var list = [];
    for (var m in modes)
      if (modes.propertyIsEnumerable(m)) list.push(m);
    return list;
  };
  CodeMirror.listMIMEs = function() {
    var list = [];
    for (var m in mimeModes)
      if (mimeModes.propertyIsEnumerable(m)) list.push({mime: m, mode: mimeModes[m]});
    return list;
  };

  var extensions = CodeMirror.extensions = {};
  CodeMirror.defineExtension = function(name, func) {
    extensions[name] = func;
  };

  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection({line: 0, ch: 0}, {line: cm.lineCount() - 1});},
    killLine: function(cm) {
      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
      if (!sel && cm.getLine(from.line).length == from.ch) cm.replaceRange("", from, {line: from.line + 1, ch: 0});
      else cm.replaceRange("", from, sel ? to : {line: from.line});
    },
    deleteLine: function(cm) {var l = cm.getCursor().line; cm.replaceRange("", {line: l, ch: 0}, {line: l});},
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    goDocStart: function(cm) {cm.setCursor(0, 0, true);},
    goDocEnd: function(cm) {cm.setSelection({line: cm.lineCount() - 1}, null, true);},
    goLineStart: function(cm) {cm.setCursor(cm.getCursor().line, 0, true);},
    goLineStartSmart: function(cm) {
      var cur = cm.getCursor();
      var text = cm.getLine(cur.line), firstNonWS = Math.max(0, text.search(/\S/));
      cm.setCursor(cur.line, cur.ch <= firstNonWS && cur.ch ? 0 : firstNonWS, true);
    },
    goLineEnd: function(cm) {cm.setSelection({line: cm.getCursor().line}, null, true);},
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharLeft: function(cm) {cm.deleteH(-1, "char");},
    delCharRight: function(cm) {cm.deleteH(1, "char");},
    delWordLeft: function(cm) {cm.deleteH(-1, "word");},
    delWordRight: function(cm) {cm.deleteH(1, "word");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t", "end");},
    transposeChars: function(cm) {
      var cur = cm.getCursor(), line = cm.getLine(cur.line);
      if (cur.ch > 0 && cur.ch < line.length - 1)
        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),
                        {line: cur.line, ch: cur.ch - 1}, {line: cur.line, ch: cur.ch + 1});
    },
    newlineAndIndent: function(cm) {
      cm.replaceSelection("\n", "end");
      cm.indentLine(cm.getCursor().line);
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };

  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharRight", "Backspace": "delCharLeft", "Tab": "insertTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"
  };
  // Note that the save and find-related commands aren't defined by
  // default. Unknown commands are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
    "Ctrl-Left": "goWordLeft", "Ctrl-Right": "goWordRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delWordLeft", "Ctrl-Delete": "delWordRight", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    fallthrough: "basic"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goWordLeft",
    "Alt-Right": "goWordRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delWordLeft",
    "Ctrl-Alt-Backspace": "delWordRight", "Alt-Delete": "delWordRight", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageUp", "Shift-Ctrl-V": "goPageDown", "Ctrl-D": "delCharRight", "Ctrl-H": "delCharLeft",
    "Alt-D": "delWordRight", "Alt-Backspace": "delWordLeft", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };

  function getKeyMap(val) {
    if (typeof val == "string") return keyMap[val];
    else return val;
  }
  function lookupKey(name, extraMap, map, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found != null && handle(found)) return true;
      if (map.catchall) return handle(map.catchall);
      var fallthrough = map.fallthrough;
      if (fallthrough == null) return false;
      if (Object.prototype.toString.call(fallthrough) != "[object Array]")
        return lookup(fallthrough);
      for (var i = 0, e = fallthrough.length; i < e; ++i) {
        if (lookup(fallthrough[i])) return true;
      }
      return false;
    }
    if (extraMap && lookup(extraMap)) return true;
    return lookup(map);
  }
  function isModifierKey(event) {
    var name = keyNames[e_prop(event, "keyCode")];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }

  CodeMirror.fromTextArea = function(textarea, options) {
    if (!options) options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (options.autofocus == null && textarea.getAttribute("autofocus") != null)
      options.autofocus = true;

    function save() {textarea.value = instance.getValue();}
    if (textarea.form) {
      // Deplorable hack to make the submit method do the right thing.
      var rmSubmit = connect(textarea.form, "submit", save, true);
      if (typeof textarea.form.submit == "function") {
        var realSubmit = textarea.form.submit;
        function wrappedSubmit() {
          save();
          textarea.form.submit = realSubmit;
          textarea.form.submit();
          textarea.form.submit = wrappedSubmit;
        }
        textarea.form.submit = wrappedSubmit;
      }
    }

    textarea.style.display = "none";
    var instance = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    instance.save = save;
    instance.getTextArea = function() { return textarea; };
    instance.toTextArea = function() {
      save();
      textarea.parentNode.removeChild(instance.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        rmSubmit();
        if (typeof textarea.form.submit == "function")
          textarea.form.submit = realSubmit;
      }
    };
    return instance;
  };

  // Utility functions for working with state. Exported because modes
  // sometimes need to do this.
  function copyState(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  }
  CodeMirror.copyState = copyState;
  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  CodeMirror.startState = startState;

  // The character stream used by a mode's parser.
  function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
  }
  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == 0;},
    peek: function() {return this.string.charAt(this.pos);},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {return countColumn(this.string, this.start, this.tabSize);},
    indentation: function() {return countColumn(this.string, null, this.tabSize);},
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        function cased(str) {return caseInsensitive ? str.toLowerCase() : str;}
        if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      }
      else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);}
  };
  CodeMirror.StringStream = StringStream;

  function MarkedText(from, to, className, marker) {
    this.from = from; this.to = to; this.style = className; this.marker = marker;
  }
  MarkedText.prototype = {
    attach: function(line) { this.marker.set.push(line); },
    detach: function(line) {
      var ix = indexOf(this.marker.set, line);
      if (ix > -1) this.marker.set.splice(ix, 1);
    },
    split: function(pos, lenBefore) {
      if (this.to <= pos && this.to != null) return null;
      var from = this.from < pos || this.from == null ? null : this.from - pos + lenBefore;
      var to = this.to == null ? null : this.to - pos + lenBefore;
      return new MarkedText(from, to, this.style, this.marker);
    },
    dup: function() { return new MarkedText(null, null, this.style, this.marker); },
    clipTo: function(fromOpen, from, toOpen, to, diff) {
      if (fromOpen && to > this.from && (to < this.to || this.to == null))
        this.from = null;
      else if (this.from != null && this.from >= from)
        this.from = Math.max(to, this.from) + diff;
      if (toOpen && (from < this.to || this.to == null) && (from > this.from || this.from == null))
        this.to = null;
      else if (this.to != null && this.to > from)
        this.to = to < this.to ? this.to + diff : from;
    },
    isDead: function() { return this.from != null && this.to != null && this.from >= this.to; },
    sameSet: function(x) { return this.marker == x.marker; }
  };

  function Bookmark(pos) {
    this.from = pos; this.to = pos; this.line = null;
  }
  Bookmark.prototype = {
    attach: function(line) { this.line = line; },
    detach: function(line) { if (this.line == line) this.line = null; },
    split: function(pos, lenBefore) {
      if (pos < this.from) {
        this.from = this.to = (this.from - pos) + lenBefore;
        return this;
      }
    },
    isDead: function() { return this.from > this.to; },
    clipTo: function(fromOpen, from, toOpen, to, diff) {
      if ((fromOpen || from < this.from) && (toOpen || to > this.to)) {
        this.from = 0; this.to = -1;
      } else if (this.from > from) {
        this.from = this.to = Math.max(to, this.from) + diff;
      }
    },
    sameSet: function(x) { return false; },
    find: function() {
      if (!this.line || !this.line.parent) return null;
      return {line: lineNo(this.line), ch: this.from};
    },
    clear: function() {
      if (this.line) {
        var found = indexOf(this.line.marked, this);
        if (found != -1) this.line.marked.splice(found, 1);
        this.line = null;
      }
    }
  };

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  function Line(text, styles) {
    this.styles = styles || [text, null];
    this.text = text;
    this.height = 1;
    this.marked = this.gutterMarker = this.className = this.bgClassName = this.handlers = null;
    this.stateAfter = this.parent = this.hidden = null;
  }
  Line.inheritMarks = function(text, orig) {
    var ln = new Line(text), mk = orig && orig.marked;
    if (mk) {
      for (var i = 0; i < mk.length; ++i) {
        if (mk[i].to == null && mk[i].style) {
          var newmk = ln.marked || (ln.marked = []), mark = mk[i];
          var nmark = mark.dup(); newmk.push(nmark); nmark.attach(ln);
        }
      }
    }
    return ln;
  }
  Line.prototype = {
    // Replace a piece of a line, keeping the styles around it intact.
    replace: function(from, to_, text) {
      var st = [], mk = this.marked, to = to_ == null ? this.text.length : to_;
      copyStyles(0, from, this.styles, st);
      if (text) st.push(text, null);
      copyStyles(to, this.text.length, this.styles, st);
      this.styles = st;
      this.text = this.text.slice(0, from) + text + this.text.slice(to);
      this.stateAfter = null;
      if (mk) {
        var diff = text.length - (to - from);
        for (var i = 0; i < mk.length; ++i) {
          var mark = mk[i];
          mark.clipTo(from == null, from || 0, to_ == null, to, diff);
          if (mark.isDead()) {mark.detach(this); mk.splice(i--, 1);}
        }
      }
    },
    // Split a part off a line, keeping styles and markers intact.
    split: function(pos, textBefore) {
      var st = [textBefore, null], mk = this.marked;
      copyStyles(pos, this.text.length, this.styles, st);
      var taken = new Line(textBefore + this.text.slice(pos), st);
      if (mk) {
        for (var i = 0; i < mk.length; ++i) {
          var mark = mk[i];
          var newmark = mark.split(pos, textBefore.length);
          if (newmark) {
            if (!taken.marked) taken.marked = [];
            taken.marked.push(newmark); newmark.attach(taken);
            if (newmark == mark) mk.splice(i--, 1);
          }
        }
      }
      return taken;
    },
    append: function(line) {
      var mylen = this.text.length, mk = line.marked, mymk = this.marked;
      this.text += line.text;
      copyStyles(0, line.text.length, line.styles, this.styles);
      if (mymk) {
        for (var i = 0; i < mymk.length; ++i)
          if (mymk[i].to == null) mymk[i].to = mylen;
      }
      if (mk && mk.length) {
        if (!mymk) this.marked = mymk = [];
        outer: for (var i = 0; i < mk.length; ++i) {
          var mark = mk[i];
          if (!mark.from) {
            for (var j = 0; j < mymk.length; ++j) {
              var mymark = mymk[j];
              if (mymark.to == mylen && mymark.sameSet(mark)) {
                mymark.to = mark.to == null ? null : mark.to + mylen;
                if (mymark.isDead()) {
                  mymark.detach(this);
                  mk.splice(i--, 1);
                }
                continue outer;
              }
            }
          }
          mymk.push(mark);
          mark.attach(this);
          mark.from += mylen;
          if (mark.to != null) mark.to += mylen;
        }
      }
    },
    fixMarkEnds: function(other) {
      var mk = this.marked, omk = other.marked;
      if (!mk) return;
      for (var i = 0; i < mk.length; ++i) {
        var mark = mk[i], close = mark.to == null;
        if (close && omk) {
          for (var j = 0; j < omk.length; ++j)
            if (omk[j].sameSet(mark)) {close = false; break;}
        }
        if (close) mark.to = this.text.length;
      }
    },
    fixMarkStarts: function() {
      var mk = this.marked;
      if (!mk) return;
      for (var i = 0; i < mk.length; ++i)
        if (mk[i].from == null) mk[i].from = 0;
    },
    addMark: function(mark) {
      mark.attach(this);
      if (this.marked == null) this.marked = [];
      this.marked.push(mark);
      this.marked.sort(function(a, b){return (a.from || 0) - (b.from || 0);});
    },
    // Run the given mode's parser over a line, update the styles
    // array, which contains alternating fragments of text and CSS
    // classes.
    highlight: function(mode, state, tabSize) {
      var stream = new StringStream(this.text, tabSize), st = this.styles, pos = 0;
      var changed = false, curWord = st[0], prevWord;
      if (this.text == "" && mode.blankLine) mode.blankLine(state);
      while (!stream.eol()) {
        var style = mode.token(stream, state);
        var substr = this.text.slice(stream.start, stream.pos);
        stream.start = stream.pos;
        if (pos && st[pos-1] == style)
          st[pos-2] += substr;
        else if (substr) {
          if (!changed && (st[pos+1] != style || (pos && st[pos-2] != prevWord))) changed = true;
          st[pos++] = substr; st[pos++] = style;
          prevWord = curWord; curWord = st[pos];
        }
        // Give up when line is ridiculously long
        if (stream.pos > 5000) {
          st[pos++] = this.text.slice(stream.pos); st[pos++] = null;
          break;
        }
      }
      if (st.length != pos) {st.length = pos; changed = true;}
      if (pos && st[pos-2] != prevWord) changed = true;
      // Short lines with simple highlights return null, and are
      // counted as changed by the driver because they are likely to
      // highlight the same way in various contexts.
      return changed || (st.length < 5 && this.text.length < 10 ? null : false);
    },
    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(mode, state, ch) {
      var txt = this.text, stream = new StringStream(txt);
      while (stream.pos < ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = mode.token(stream, state);
      }
      return {start: stream.start,
              end: stream.pos,
              string: stream.current(),
              className: style || null,
              state: state};
    },
    indentation: function(tabSize) {return countColumn(this.text, null, tabSize);},
    // Produces an HTML fragment for the line, taking selection,
    // marking, and highlighting into account.
    getHTML: function(makeTab, endAt) {
      var html = [], first = true, col = 0;
      function span(text, style) {
        if (!text) return;
        // Work around a bug where, in some compat modes, IE ignores leading spaces
        if (first && ie && text.charAt(0) == " ") text = "\u00a0" + text.slice(1);
        first = false;
        if (text.indexOf("\t") == -1) {
          col += text.length;
          var escaped = htmlEscape(text);
        } else {
          var escaped = "";
          for (var pos = 0;;) {
            var idx = text.indexOf("\t", pos);
            if (idx == -1) {
              escaped += htmlEscape(text.slice(pos));
              col += text.length - pos;
              break;
            } else {
              col += idx - pos;
              var tab = makeTab(col);
              escaped += htmlEscape(text.slice(pos, idx)) + tab.html;
              col += tab.width;
              pos = idx + 1;
            }
          }
        }
        if (style) html.push('<span class="', style, '">', escaped, "</span>");
        else html.push(escaped);
      }
      var st = this.styles, allText = this.text, marked = this.marked;
      var len = allText.length;
      if (endAt != null) len = Math.min(endAt, len);
      function styleToClass(style) {
        if (!style) return null;
        return "cm-" + style.replace(/ +/g, " cm-");
      }

      if (!allText && endAt == null)
        span(" ");
      else if (!marked || !marked.length)
        for (var i = 0, ch = 0; ch < len; i+=2) {
          var str = st[i], style = st[i+1], l = str.length;
          if (ch + l > len) str = str.slice(0, len - ch);
          ch += l;
          span(str, styleToClass(style));
        }
      else {
        var pos = 0, i = 0, text = "", style, sg = 0;
        var nextChange = marked[0].from || 0, marks = [], markpos = 0;
        function advanceMarks() {
          var m;
          while (markpos < marked.length &&
                 ((m = marked[markpos]).from == pos || m.from == null)) {
            if (m.style != null) marks.push(m);
            ++markpos;
          }
          nextChange = markpos < marked.length ? marked[markpos].from : Infinity;
          for (var i = 0; i < marks.length; ++i) {
            var to = marks[i].to || Infinity;
            if (to == pos) marks.splice(i--, 1);
            else nextChange = Math.min(to, nextChange);
          }
        }
        var m = 0;
        while (pos < len) {
          if (nextChange == pos) advanceMarks();
          var upto = Math.min(len, nextChange);
          while (true) {
            if (text) {
              var end = pos + text.length;
              var appliedStyle = style;
              for (var j = 0; j < marks.length; ++j)
                appliedStyle = (appliedStyle ? appliedStyle + " " : "") + marks[j].style;
              span(end > upto ? text.slice(0, upto - pos) : text, appliedStyle);
              if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
              pos = end;
            }
            text = st[i++]; style = styleToClass(st[i++]);
          }
        }
      }
      return html.join("");
    },
    cleanUp: function() {
      this.parent = null;
      if (this.marked)
        for (var i = 0, e = this.marked.length; i < e; ++i) this.marked[i].detach(this);
    }
  };
  // Utility used by replace and split above
  function copyStyles(from, to, source, dest) {
    for (var i = 0, pos = 0, state = 0; pos < to; i+=2) {
      var part = source[i], end = pos + part.length;
      if (state == 0) {
        if (end > from) dest.push(part.slice(from - pos, Math.min(part.length, to - pos)), source[i+1]);
        if (end >= from) state = 1;
      }
      else if (state == 1) {
        if (end > to) dest.push(part.slice(0, to - pos), source[i+1]);
        else dest.push(part, source[i+1]);
      }
      pos = end;
    }
  }

  // Data structure that holds the sequence of lines.
  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    remove: function(at, n, callbacks) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        line.cleanUp();
        if (line.handlers)
          for (var j = 0; j < line.handlers.length; ++j) callbacks.push(line.handlers[j]);
      }
      this.lines.splice(at, n);
    },
    collapse: function(lines) {
      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));
    },
    insertHeight: function(at, lines, height) {
      this.height += height;
      this.lines.splice.apply(this.lines, [at, 0].concat(lines));
      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;
    },
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };
  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0, e = children.length; i < e; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    remove: function(at, n, callbacks) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.remove(at, rm, callbacks);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      if (this.size - n < 25) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);
    },
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;
      this.insertHeight(at, lines, height);
    },
    insertHeight: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertHeight(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iter: function(from, to, op) { this.iterN(from, to - from, op); },
    iterN: function(at, n, op) {
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  function getLineAt(chunk, n) {
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0, e = chunk.children.length; ; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no;
  }
  function lineAtHeight(chunk, h) {
    var n = 0;
    outer: do {
      for (var i = 0, e = chunk.children.length; i < e; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0, e = chunk.lines.length; i < e; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }
  function heightAtLine(chunk, n) {
    var h = 0;
    outer: do {
      for (var i = 0, e = chunk.children.length; i < e; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; continue outer; }
        n -= sz;
        h += child.height;
      }
      return h;
    } while (!chunk.lines);
    for (var i = 0; i < n; ++i) h += chunk.lines[i].height;
    return h;
  }

  // The history object 'chunks' changes that are made close together
  // and at almost the same time into bigger undoable units.
  function History() {
    this.time = 0;
    this.done = []; this.undone = [];
  }
  History.prototype = {
    addChange: function(start, added, old) {
      this.undone.length = 0;
      var time = +new Date, cur = this.done[this.done.length - 1], last = cur && cur[cur.length - 1];
      var dtime = time - this.time;
      if (dtime > 400 || !last) {
        this.done.push([{start: start, added: added, old: old}]);
      } else if (last.start > start + old.length || last.start + last.added < start - last.added + last.old.length) {
        cur.push({start: start, added: added, old: old});
      } else {
        var oldoff = 0;
        if (start < last.start) {
          for (var i = last.start - start - 1; i >= 0; --i)
            last.old.unshift(old[i]);
          oldoff = Math.min(0, added - old.length);
          last.added += last.start - start + oldoff;
          last.start = start;
        } else if (last.start < start) {
          oldoff = start - last.start;
          added += oldoff;
        }
        for (var i = last.added - oldoff, e = old.length; i < e; ++i)
          last.old.push(old[i]);
        if (last.added < added) last.added = added;
      }
      this.time = time;
    }
  };

  function stopMethod() {e_stop(this);}
  // Ensure an event has a stop method.
  function addStop(event) {
    if (!event.stop) event.stop = stopMethod;
    return event;
  }

  function e_preventDefault(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}
  CodeMirror.e_stop = e_stop;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    if (e.which) return e.which;
    else if (e.button & 1) return 1;
    else if (e.button & 2) return 3;
    else if (e.button & 4) return 2;
  }

  // Allow 3rd-party code to override event properties by adding an override
  // object to an event object.
  function e_prop(e, prop) {
    var overridden = e.override && e.override.hasOwnProperty(prop);
    return overridden ? e.override[prop] : e[prop];
  }

  // Event handler registration. If disconnect is true, it'll return a
  // function that unregisters the handler.
  function connect(node, type, handler, disconnect) {
    if (typeof node.addEventListener == "function") {
      node.addEventListener(type, handler, false);
      if (disconnect) return function() {node.removeEventListener(type, handler, false);};
    }
    else {
      var wrapHandler = function(event) {handler(event || window.event);};
      node.attachEvent("on" + type, wrapHandler);
      if (disconnect) return function() {node.detachEvent("on" + type, wrapHandler);};
    }
  }
  CodeMirror.connect = connect;

  function Delayed() {this.id = null;}
  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};

  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  var gecko = /gecko\/\d{7}/i.test(navigator.userAgent);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt9 = /MSIE [1-8]\b/.test(navigator.userAgent);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var khtml = /KHTML\//.test(navigator.userAgent);

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie_lt9) return false;
    var div = document.createElement('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var lineSep = "\n";
  // Feature-detect whether newlines in textareas are converted to \r\n
  (function () {
    var te = document.createElement("textarea");
    te.value = "foo\nbar";
    if (te.value.indexOf("\r") > -1) lineSep = "\r\n";
  }());

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = 0, n = 0; i < end; ++i) {
      if (string.charAt(i) == "\t") n += tabSize - (n % tabSize);
      else ++n;
    }
    return n;
  }

  function computedStyle(elt) {
    if (elt.currentStyle) return elt.currentStyle;
    return window.getComputedStyle(elt, null);
  }

  // Find the position of an element by following the offsetParent chain.
  // If screen==true, it returns screen (rather than page) coordinates.
  function eltOffset(node, screen) {
    var bod = node.ownerDocument.body;
    var x = 0, y = 0, skipBody = false;
    for (var n = node; n; n = n.offsetParent) {
      var ol = n.offsetLeft, ot = n.offsetTop;
      // Firefox reports weird inverted offsets when the body has a border.
      if (n == bod) { x += Math.abs(ol); y += Math.abs(ot); }
      else { x += ol, y += ot; }
      if (screen && computedStyle(n).position == "fixed")
        skipBody = true;
    }
    var e = screen && !skipBody ? null : bod;
    for (var n = node.parentNode; n != e; n = n.parentNode)
      if (n.scrollLeft != null) { x -= n.scrollLeft; y -= n.scrollTop;}
    return {left: x, top: y};
  }
  // Use the faster and saner getBoundingClientRect method when possible.
  if (document.documentElement.getBoundingClientRect != null) eltOffset = function(node, screen) {
    // Take the parts of bounding client rect that we are interested in so we are able to edit if need be,
    // since the returned value cannot be changed externally (they are kept in sync as the element moves within the page)
    try { var box = node.getBoundingClientRect(); box = { top: box.top, left: box.left }; }
    catch(e) { box = {top: 0, left: 0}; }
    if (!screen) {
      // Get the toplevel scroll, working around browser differences.
      if (window.pageYOffset == null) {
        var t = document.documentElement || document.body.parentNode;
        if (t.scrollTop == null) t = document.body;
        box.top += t.scrollTop; box.left += t.scrollLeft;
      } else {
        box.top += window.pageYOffset; box.left += window.pageXOffset;
      }
    }
    return box;
  };

  // Get a node's text content.
  function eltText(node) {
    return node.textContent || node.innerText || node.nodeValue || "";
  }
  function selectInput(node) {
    if (ios) { // Mobile Safari apparently has a bug where select() is broken.
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    } else node.select();
  }

  // Operations on {line, ch} objects.
  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}
  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}
  function copyPos(x) {return {line: x.line, ch: x.ch};}

  var escapeElement = document.createElement("pre");
  function htmlEscape(str) {
    escapeElement.textContent = str;
    return escapeElement.innerHTML;
  }
  // Recent (late 2011) Opera betas insert bogus newlines at the start
  // of the textContent, so we strip those.
  if (htmlEscape("a") == "\na")
    htmlEscape = function(str) {
      escapeElement.textContent = str;
      return escapeElement.innerHTML.slice(1);
    };
  // Some IEs don't preserve tabs through innerHTML
  else if (htmlEscape("\t") != "\t")
    htmlEscape = function(str) {
      escapeElement.innerHTML = "";
      escapeElement.appendChild(document.createTextNode(str));
      return escapeElement.innerHTML;
    };
  CodeMirror.htmlEscape = htmlEscape;

  // Used to position the cursor after an undo/redo by finding the
  // last edited character.
  function editEnd(from, to) {
    if (!to) return 0;
    if (!from) return to.length;
    for (var i = from.length, j = to.length; i >= 0 && j >= 0; --i, --j)
      if (from.charAt(i) != to.charAt(j)) break;
    return j + 1;
  }

  function indexOf(collection, elt) {
    if (collection.indexOf) return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt) return i;
    return -1;
  }
  function isWordChar(ch) {
    return /\w/.test(ch) || ch.toUpperCase() != ch.toLowerCase();
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, nl, result = [];
    while ((nl = string.indexOf("\n", pos)) > -1) {
      result.push(string.slice(pos, string.charAt(nl-1) == "\r" ? nl - 1 : nl));
      pos = nl + 1;
    }
    result.push(string.slice(pos));
    return result;
  } : function(string){return string.split(/\r?\n/);};
  CodeMirror.splitLines = splitLines;

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 91: "Mod", 92: "Mod", 93: "Mod", 127: "Delete", 186: ";", 187: "=", 188: ",",
                  189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'", 63276: "PageUp",
                  63277: "PageDown", 63275: "End", 63273: "Home", 63234: "Left", 63232: "Up", 63235: "Right",
                  63233: "Down", 63302: "Insert", 63272: "Delete"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  return CodeMirror;
})();

    
    
    </script>
    <script type="text/javascript">
    // javascript.js
    
    CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var jsonMode = parserConfig.json;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};
    return {
      "if": A, "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom
    };
  }();

  var isOperatorChar = /[+\-*&%=<>!?|]/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function nextUntilUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next == end && !escaped)
        return false;
      escaped = !escaped && next == "\\";
    }
    return escaped;
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }

  function jsTokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'")
      return chain(stream, state, jsTokenString(ch));
    else if (/[\[\]{}\(\),;\:\.]/.test(ch))
      return ret(ch);
    else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    }      
    else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    }
    else if (ch == "/") {
      if (stream.eat("*")) {
        return chain(stream, state, jsTokenComment);
      }
      else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      }
      else if (state.reAllowed) {
        nextUntilUnescaped(stream, "/");
        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
        return ret("regexp", "string-2");
      }
      else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", null, stream.current());
      }
    }
    else if (ch == "#") {
        stream.skipToEnd();
        return ret("error", "error");
    }
    else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", null, stream.current());
    }
    else {
      stream.eatWhile(/[\w\$_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function jsTokenString(quote) {
    return function(stream, state) {
      if (!nextUntilUnescaped(stream, quote))
        state.tokenize = jsTokenBase;
      return ret("string", "string");
    };
  }

  function jsTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = jsTokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;
  
    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      for (var v = state.localVars; v; v = v.next)
        if (v.name == varname) return;
      state.localVars = {name: varname, next: state.localVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    if (!cx.state.context) cx.state.localVars = defaultVars;
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state;
      state.lexical = new JSLexical(state.indented, cx.stream.column(), type, null, state.lexical, info)
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    return function expecting(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(arguments.callee);
    };
  }

  function statement(type) {
    if (type == "var") return cont(pushlex("vardef"), vardef1, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), expect("("), pushlex(")"), forspec1, expect(")"),
                                      poplex, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                         block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                        statement, poplex, popcontext);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);
    if (type == "function") return cont(functiondef);
    if (type == "keyword c") return cont(maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeoperator);
    if (type == "operator") return cont(expression);
    if (type == "[") return cont(pushlex("]"), commasep(expression, "]"), poplex, maybeoperator);
    if (type == "{") return cont(pushlex("}"), commasep(objprop, "}"), poplex, maybeoperator);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
    
  function maybeoperator(type, value) {
    if (type == "operator" && /\+\+|--/.test(value)) return cont(maybeoperator);
    if (type == "operator") return cont(expression);
    if (type == ";") return;
    if (type == "(") return cont(pushlex(")"), commasep(expression, ")"), poplex, maybeoperator);
    if (type == ".") return cont(property, maybeoperator);
    if (type == "[") return cont(pushlex("]"), expression, expect("]"), poplex, maybeoperator);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperator, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type) {
    if (type == "variable") cx.marked = "property";
    if (atomicTypes.hasOwnProperty(type)) return cont(expect(":"), expression);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") return cont(what, proceed);
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function commaSeparated(type) {
      if (type == end) return cont();
      else return pass(what, proceed);
    };
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function vardef1(type, value) {
    if (type == "variable"){register(value); return cont(vardef2);}
    return cont();
  }
  function vardef2(type, value) {
    if (value == "=") return cont(expression, vardef2);
    if (type == ",") return cont(vardef1);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef1, forspec2);
    if (type == ";") return pass(forspec2);
    if (type == "variable") return cont(formaybein);
    return pass(forspec2);
  }
  function formaybein(type, value) {
    if (value == "in") return cont(expression);
    return cont(maybeoperator, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in") return cont(expression);
    return cont(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushlex(")"), pushcontext, commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type, value) {
    if (type == "variable") {register(value); return cont();}
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: jsTokenBase,
        reAllowed: true,
        kwAllowed: true,
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: null,
        context: null,
        indented: 0
      };
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
      }
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.reAllowed = !!(type == "operator" || type == "keyword c" || type.match(/^[\[{}\(,;:]$/));
      state.kwAllowed = type != '.';
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize != jsTokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical,
          type = lexical.type, closing = firstChar == type;
      if (type == "vardef") return lexical.indented + 4;
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "stat" || type == "form") return lexical.indented + indentUnit;
      else if (lexical.info == "switch" && !closing)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricChars: ":{}"
  };
});

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});

    </script>
<!--    <link rel="stylesheet" href="../../doc/docs.css"> -->
    <style type="text/css">
          .CodeMirror {
        float: left;
        width: 100%;
      }
    </style>

<script type="text/javascript">
// <!--
// pour indenter le code javascript

/*jslint onevar: false, plusplus: false */
/*

JS Beautifier
---------------


Written by Einar Lielmanis, <einar@jsbeautifier.org>
http://jsbeautifier.org/

Originally converted to javascript by Vital, <vital76@gmail.com>

You are free to use this in any way you want, in case you find this useful or working for you.

Usage:
js_beautify(js_source_text);
js_beautify(js_source_text, options);

The options are:
indent_size (default 4)  indentation size,
indent_char (default space)  character to indent with,
preserve_newlines (default true)  whether existing line breaks should be preserved,
preserve_max_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,
indent_level (default 0)  initial indentation level, you probably won't need this ever,

space_after_anon_function (default false)  if true, then space is added between "function ()"
(jslint is happy about this); if false, then the common "function()" output is used.
braces_on_own_line (default false) - ANSI / Allman brace style, each opening/closing brace gets its own line.

e.g

js_beautify(js_source_text, {indent_size: 1, indent_char: '\t'});


*/



function js_beautify(js_source_text, options) {

  var input, output, token_text, last_type, last_text, last_last_text, last_word, flags, flag_store, indent_string;
  var whitespace, wordchar, punct, parser_pos, line_starters, digits;
  var prefix, token_type, do_block_just_closed;
  var wanted_newline, just_added_newline, n_newlines;


  // Some interpreters have unexpected results with foo = baz || bar;
  options = options ? options : {};
  var opt_braces_on_own_line = options.braces_on_own_line ? options.braces_on_own_line : false;
  var opt_indent_size = options.indent_size ? options.indent_size : 4;
  var opt_indent_char = options.indent_char ? options.indent_char : ' ';
  var opt_preserve_newlines = typeof options.preserve_newlines === 'undefined' ? true : options.preserve_newlines;
  var opt_max_preserve_newlines = typeof options.max_preserve_newlines === 'undefined' ? false : options.max_preserve_newlines;
  var opt_indent_level = options.indent_level ? options.indent_level : 0; // starting indentation
  var opt_space_after_anon_function = options.space_after_anon_function === 'undefined' ? false : options.space_after_anon_function;
  var opt_keep_array_indentation = typeof options.keep_array_indentation === 'undefined' ? false : options.keep_array_indentation;

  just_added_newline = false;

  // cache the source's length.
  var input_length = js_source_text.length;

  function trim_output(eat_newlines) {
    eat_newlines = typeof eat_newlines === 'undefined' ? false : eat_newlines;
    while (output.length && (output[output.length - 1] === ' ' || output[output.length - 1] === indent_string || (eat_newlines && (output[output.length - 1] === '\n' || output[output.length - 1] === '\r')))) {
      output.pop();
    }
  }

  function is_array(mode) {
    return mode === '[EXPRESSION]' || mode === '[INDENTED-EXPRESSION]';
  }

  function trim(s) {
    return s.replace(/^\s\s*|\s\s*$/, '');
  }

  function print_newline(ignore_repeated) {

    flags.eat_next_space = false;
    if (opt_keep_array_indentation && is_array(flags.mode)) {
      return;
    }

    ignore_repeated = typeof ignore_repeated === 'undefined' ? true : ignore_repeated;

    flags.if_line = false;
    trim_output();

    if (!output.length) {
      return; // no newline on start of file
    }

    if (output[output.length - 1] !== "\n" || !ignore_repeated) {
      just_added_newline = true;
      output.push("\n");
    }
    for (var i = 0; i < flags.indentation_level; i += 1) {
      output.push(indent_string);
    }
    if (flags.var_line && flags.var_line_reindented) {
      if (opt_indent_char === ' ') {
        output.push(' '); // var_line always pushes 4 spaces, so that the variables would be one under another
      } else {
        output.push(indent_string); // skip space-stuffing, if indenting with a tab
      }
    }
  }



  function print_single_space() {
    if (flags.eat_next_space) {
      flags.eat_next_space = false;
      return;
    }
    var last_output = ' ';
    if (output.length) {
      last_output = output[output.length - 1];
    }
    if (last_output !== ' ' && last_output !== '\n' && last_output !== indent_string) { // prevent occassional duplicate space
      output.push(' ');
    }
  }


  function print_token() {
    just_added_newline = false;
    flags.eat_next_space = false;
    output.push(token_text);
  }

  function indent() {
    flags.indentation_level += 1;
  }


  function remove_indent() {
    if (output.length && output[output.length - 1] === indent_string) {
      output.pop();
    }
  }

  function set_mode(mode) {
    if (flags) {
      flag_store.push(flags);
    }
    flags = {
      previous_mode: flags ? flags.mode : 'BLOCK',
      mode: mode,
      var_line: false,
      var_line_tainted: false,
      var_line_reindented: false,
      in_html_comment: false,
      if_line: false,
      in_case: false,
      eat_next_space: false,
      indentation_baseline: -1,
      indentation_level: (flags ? flags.indentation_level + ((flags.var_line && flags.var_line_reindented) ? 1 : 0) : opt_indent_level)
    };
  }

  function is_array(mode) {
    return mode === '[EXPRESSION]' || mode === '[INDENTED-EXPRESSION]';
  }

  function is_expression(mode) {
    return mode === '[EXPRESSION]' || mode === '[INDENTED-EXPRESSION]' || mode === '(EXPRESSION)';
  }

  function restore_mode() {
    do_block_just_closed = flags.mode === 'DO_BLOCK';
    if (flag_store.length > 0) {
      flags = flag_store.pop();
    }
  }


  function in_array(what, arr) {
    for (var i = 0; i < arr.length; i += 1) {
      if (arr[i] === what) {
        return true;
      }
    }
    return false;
  }

  // Walk backwards from the colon to find a '?' (colon is part of a ternary op)
  // or a '{' (colon is part of a class literal). Along the way, keep track of
  // the blocks and expressions we pass so we only trigger on those chars in our
  // own level, and keep track of the colons so we only trigger on the matching '?'.

  function is_ternary_op() {
    var level = 0,
     colon_count = 0;
    for (var i = output.length - 1; i >= 0; i--) {
      switch (output[i]) {
      case ':':
        if (level === 0) {
          colon_count++;
        }
        break;
      case '?':
        if (level === 0) {
          if (colon_count === 0) {
            return true;
          } else {
            colon_count--;
          }
        }
        break;
      case '{':
        if (level === 0) {
          return false;
        }
        level--;
        break;
      case '(':
      case '[':
        level--;
        break;
      case ')':
      case ']':
      case '}':
        level++;
        break;
      }
    }
  }

  function get_next_token() {
    n_newlines = 0;

    if (parser_pos >= input_length) {
      return ['', 'TK_EOF'];
    }

    wanted_newline = false;

    var c = input.charAt(parser_pos);
    parser_pos += 1;


    var keep_whitespace = opt_keep_array_indentation && is_array(flags.mode);

    if (keep_whitespace) {

      //
      // slight mess to allow nice preservation of array indentation and reindent that correctly
      // first time when we get to the arrays:
      // var a = [
      // ....'something'
      // we make note of whitespace_count = 4 into flags.indentation_baseline
      // so we know that 4 whitespaces in original source match indent_level of reindented source
      //
      // and afterwards, when we get to
      // 'something,
      // .......'something else'
      // we know that this should be indented to indent_level + (7 - indentation_baseline) spaces
      //
      var whitespace_count = 0;

      while (in_array(c, whitespace)) {

        if (c === "\n") {
          trim_output();
          output.push("\n");
          just_added_newline = true;
          whitespace_count = 0;
        } else {
          if (c === '\t') {
            whitespace_count += 4;
          } else if (c === '\r') {
            // nothing
          } else {
            whitespace_count += 1;
          }
        }

        if (parser_pos >= input_length) {
          return ['', 'TK_EOF'];
        }

        c = input.charAt(parser_pos);
        parser_pos += 1;

      }
      if (flags.indentation_baseline === -1) {
        flags.indentation_baseline = whitespace_count;
      }

      if (just_added_newline) {
        var i;
        for (i = 0; i < flags.indentation_level + 1; i += 1) {
          output.push(indent_string);
        }
        if (flags.indentation_baseline !== -1) {
          for (i = 0; i < whitespace_count - flags.indentation_baseline; i++) {
            output.push(' ');
          }
        }
      }

    } else {
      while (in_array(c, whitespace)) {

        if (c === "\n") {
          n_newlines += ((opt_max_preserve_newlines) ? (n_newlines <= opt_max_preserve_newlines) ? 1 : 0 : 1);
        }


        if (parser_pos >= input_length) {
          return ['', 'TK_EOF'];
        }

        c = input.charAt(parser_pos);
        parser_pos += 1;

      }

      if (opt_preserve_newlines) {
        if (n_newlines > 1) {
          for (i = 0; i < n_newlines; i += 1) {
            print_newline(i === 0);
            just_added_newline = true;
          }
        }
      }
      wanted_newline = n_newlines > 0;
    }


    if (in_array(c, wordchar)) {
      if (parser_pos < input_length) {
        while (in_array(input.charAt(parser_pos), wordchar)) {
          c += input.charAt(parser_pos);
          parser_pos += 1;
          if (parser_pos === input_length) {
            break;
          }
        }
      }

      // small and surprisingly unugly hack for 1E-10 representation
      if (parser_pos !== input_length && c.match(/^[0-9]+[Ee]$/) && (input.charAt(parser_pos) === '-' || input.charAt(parser_pos) === '+')) {

        var sign = input.charAt(parser_pos);
        parser_pos += 1;

        var t = get_next_token(parser_pos);
        c += sign + t[0];
        return [c, 'TK_WORD'];
      }

      if (c === 'in') { // hack for 'in' operator
        return [c, 'TK_OPERATOR'];
      }
      if (wanted_newline && last_type !== 'TK_OPERATOR' && !flags.if_line && (opt_preserve_newlines || last_text !== 'var')) {
        print_newline();
      }
      return [c, 'TK_WORD'];
    }

    if (c === '(' || c === '[') {
      return [c, 'TK_START_EXPR'];
    }

    if (c === ')' || c === ']') {
      return [c, 'TK_END_EXPR'];
    }

    if (c === '{') {
      return [c, 'TK_START_BLOCK'];
    }

    if (c === '}') {
      return [c, 'TK_END_BLOCK'];
    }

    if (c === ';') {
      return [c, 'TK_SEMICOLON'];
    }

    if (c === '/') {
      var comment = '';
      // peek for comment /* ... */
      var inline_comment = true;
      if (input.charAt(parser_pos) === '*') {
        parser_pos += 1;
        if (parser_pos < input_length) {
          while (!(input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/') && parser_pos < input_length) {
            c = input.charAt(parser_pos);
            comment += c;
            if (c === '\x0d' || c === '\x0a') {
              inline_comment = false;
            }
            parser_pos += 1;
            if (parser_pos >= input_length) {
              break;
            }
          }
        }
        parser_pos += 2;
        if (inline_comment) {
          return ['/*' + comment + '*/', 'TK_INLINE_COMMENT'];
        } else {
          return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];
        }
      }
      // peek for comment // ...
      if (input.charAt(parser_pos) === '/') {
        comment = c;
        while (input.charAt(parser_pos) !== '\r' && input.charAt(parser_pos) !== '\n') {
          comment += input.charAt(parser_pos);
          parser_pos += 1;
          if (parser_pos >= input_length) {
            break;
          }
        }
        parser_pos += 1;
        if (wanted_newline) {
          print_newline();
        }
        return [comment, 'TK_COMMENT'];
      }

    }

    if (c === "'" || // string
    c === '"' || // string
    (c === '/' && ((last_type === 'TK_WORD' && in_array(last_text, ['return', 'do'])) || (last_type === 'TK_COMMENT' || last_type === 'TK_START_EXPR' || last_type === 'TK_START_BLOCK' || last_type === 'TK_END_BLOCK' || last_type === 'TK_OPERATOR' || last_type === 'TK_EQUALS' || last_type === 'TK_EOF' || last_type === 'TK_SEMICOLON')))) { // regexp
      var sep = c;
      var esc = false;
      var resulting_string = c;

      if (parser_pos < input_length) {
        if (sep === '/') {
          //
          // handle regexp separately...
          //
          var in_char_class = false;
          while (esc || in_char_class || input.charAt(parser_pos) !== sep) {
            resulting_string += input.charAt(parser_pos);
            if (!esc) {
              esc = input.charAt(parser_pos) === '\\';
              if (input.charAt(parser_pos) === '[') {
                in_char_class = true;
              } else if (input.charAt(parser_pos) === ']') {
                in_char_class = false;
              }
            } else {
              esc = false;
            }
            parser_pos += 1;
            if (parser_pos >= input_length) {
              // incomplete string/rexp when end-of-file reached.
              // bail out with what had been received so far.
              return [resulting_string, 'TK_STRING'];
            }
          }

        } else {
          //
          // and handle string also separately
          //
          while (esc || input.charAt(parser_pos) !== sep) {
            resulting_string += input.charAt(parser_pos);
            if (!esc) {
              esc = input.charAt(parser_pos) === '\\';
            } else {
              esc = false;
            }
            parser_pos += 1;
            if (parser_pos >= input_length) {
              // incomplete string/rexp when end-of-file reached.
              // bail out with what had been received so far.
              return [resulting_string, 'TK_STRING'];
            }
          }
        }



      }

      parser_pos += 1;

      resulting_string += sep;

      if (sep === '/') {
        // regexps may have modifiers /regexp/MOD , so fetch those, too
        while (parser_pos < input_length && in_array(input.charAt(parser_pos), wordchar)) {
          resulting_string += input.charAt(parser_pos);
          parser_pos += 1;
        }
      }
      return [resulting_string, 'TK_STRING'];
    }

    if (c === '#') {
      // Spidermonkey-specific sharp variables for circular references
      // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
      // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
      var sharp = '#';
      if (parser_pos < input_length && in_array(input.charAt(parser_pos), digits)) {
        do {
          c = input.charAt(parser_pos);
          sharp += c;
          parser_pos += 1;
        } while (parser_pos < input_length && c !== '#' && c !== '=');
        if (c === '#') {
          //
        } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {
          sharp += '[]';
          parser_pos += 2;
        } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {
          sharp += '{}';
          parser_pos += 2;
        }
        return [sharp, 'TK_WORD'];
      }
    }

    if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {
      parser_pos += 3;
      flags.in_html_comment = true;
      return ['<!--', 'TK_COMMENT'];
    }

    if (c === '-' && flags.in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {
      flags.in_html_comment = false;
      parser_pos += 2;
      if (wanted_newline) {
        print_newline();
      }
      return ['-->', 'TK_COMMENT'];
    }

    if (in_array(c, punct)) {
      while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {
        c += input.charAt(parser_pos);
        parser_pos += 1;
        if (parser_pos >= input_length) {
          break;
        }
      }

      if (c === '=') {
        return [c, 'TK_EQUALS'];
      } else {
        return [c, 'TK_OPERATOR'];
      }
    }

    return [c, 'TK_UNKNOWN'];
  }

  //----------------------------------
  indent_string = '';
  while (opt_indent_size > 0) {
    indent_string += opt_indent_char;
    opt_indent_size -= 1;
  }

  input = js_source_text;

  last_word = ''; // last 'TK_WORD' passed
  last_type = 'TK_START_EXPR'; // last token type
  last_text = ''; // last token text
  last_last_text = ''; // pre-last token text
  output = [];

  do_block_just_closed = false;

  whitespace = "\n\r\t ".split('');
  wordchar = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'.split('');
  digits = '0123456789'.split('');

  punct = '+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! !! , : ? ^ ^= |= ::'.split(' ');

  // words which should always start on new line.
  line_starters = 'continue,try,throw,return,var,if,switch,case,default,for,while,break,function'.split(',');

  // states showing if we are currently in expression (i.e. "if" case) - 'EXPRESSION', or in usual block (like, procedure), 'BLOCK'.
  // some formatting depends on that.
  flag_store = [];
  set_mode('BLOCK');

  parser_pos = 0;
  while (true) {
    var t = get_next_token(parser_pos);
    token_text = t[0];
    token_type = t[1];
    if (token_type === 'TK_EOF') {
      break;
    }

    switch (token_type) {

    case 'TK_START_EXPR':

      if (token_text === '[') {

        if (last_type === 'TK_WORD' || last_text === ')') {
          // this is array index specifier, break immediately
          // a[x], fn()[x]
          if (in_array(last_text, line_starters)) {
            print_single_space();
          }
          set_mode('(EXPRESSION)');
          print_token();
          break;
        }

        if (flags.mode === '[EXPRESSION]' || flags.mode === '[INDENTED-EXPRESSION]') {
          if (last_last_text === ']' && last_text === ',') {
            // ], [ goes to new line
            if (flags.mode === '[EXPRESSION]') {
              flags.mode = '[INDENTED-EXPRESSION]';
              if (!opt_keep_array_indentation) {
                indent();
              }
            }
            set_mode('[EXPRESSION]');
            if (!opt_keep_array_indentation) {
              print_newline();
            }
          } else if (last_text === '[') {
            if (flags.mode === '[EXPRESSION]') {
              flags.mode = '[INDENTED-EXPRESSION]';
              if (!opt_keep_array_indentation) {
                indent();
              }
            }
            set_mode('[EXPRESSION]');

            if (!opt_keep_array_indentation) {
              print_newline();
            }
          } else {
            set_mode('[EXPRESSION]');
          }
        } else {
          set_mode('[EXPRESSION]');
        }



      } else {
        set_mode('(EXPRESSION)');
      }

      if (last_text === ';' || last_type === 'TK_START_BLOCK') {
        print_newline();
      } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || last_text === '.') {
        // do nothing on (( and )( and ][ and ]( and .(
      } else if (last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
        print_single_space();
      } else if (last_word === 'function') {
        // function() vs function ()
        if (opt_space_after_anon_function) {
          print_single_space();
        }
      } else if (in_array(last_text, line_starters) || last_text === 'catch') {
        print_single_space();
      }
      print_token();

      break;

    case 'TK_END_EXPR':
      if (token_text === ']') {
        if (opt_keep_array_indentation) {
          if (last_text === '}') {
            // trim_output();
            // print_newline(true);
            remove_indent();
            print_token();
            restore_mode();
            break;
          }
        } else {
          if (flags.mode === '[INDENTED-EXPRESSION]') {
            if (last_text === ']') {
              restore_mode();
              print_newline();
              print_token();
              break;
            }
          }
        }
      }
      restore_mode();
      print_token();
      break;

    case 'TK_START_BLOCK':

      if (last_word === 'do') {
        set_mode('DO_BLOCK');
      } else {
        set_mode('BLOCK');
      }
      if (opt_braces_on_own_line) {
        if (last_type !== 'TK_OPERATOR') {
          if (last_text == 'return') {
            print_single_space();
          } else {
            print_newline(true);
          }
        }
        print_token();
        indent();
      } else {
        if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
          if (last_type === 'TK_START_BLOCK') {
            print_newline();
          } else {
            print_single_space();
          }
        } else {
          // if TK_OPERATOR or TK_START_EXPR
          if (is_array(flags.previous_mode) && last_text === ',') {
            if (last_last_text === '}') {
              // }, { in array context
              print_single_space();
            } else {
              print_newline(); // [a, b, c, {
            }
          }
        }
        indent();
        print_token();
      }

      break;

    case 'TK_END_BLOCK':
      restore_mode();
      if (opt_braces_on_own_line) {
        print_newline();
        print_token();
      } else {
        if (last_type === 'TK_START_BLOCK') {
          // nothing
          if (just_added_newline) {
            remove_indent();
          } else {
            // {}
            trim_output();
          }
        } else {
          if (is_array(flags.mode) && opt_keep_array_indentation) {
            // we REALLY need a newline here, but newliner would skip that
            opt_keep_array_indentation = false;
            print_newline();
            opt_keep_array_indentation = true;

          } else {
            print_newline();
          }
        }
        print_token();
      }
      break;

    case 'TK_WORD':

      // no, it's not you. even I have problems understanding how this works
      // and what does what.
      if (do_block_just_closed) {
        // do {} ## while ()
        print_single_space();
        print_token();
        print_single_space();
        do_block_just_closed = false;
        break;
      }

      if (token_text === 'function') {
        if ((just_added_newline || last_text === ';') && last_text !== '{') {
          // make sure there is a nice clean space of at least one blank line
          // before a new function definition
          n_newlines = just_added_newline ? n_newlines : 0;
          if (!opt_preserve_newlines) {
            n_newlines = 1;
          }

          for (var i = 0; i < 2 - n_newlines; i++) {
            print_newline(false);
          }
        }
      }

      if (token_text === 'case' || token_text === 'default') {
        if (last_text === ':') {
          // switch cases following one another
          remove_indent();
        } else {
          // case statement starts in the same line where switch
          flags.indentation_level--;
          print_newline();
          flags.indentation_level++;
        }
        print_token();
        flags.in_case = true;
        break;
      }

      prefix = 'NONE';

      if (last_type === 'TK_END_BLOCK') {
        if (!in_array(token_text.toLowerCase(), ['else', 'catch', 'finally'])) {
          prefix = 'NEWLINE';
        } else {
          if (opt_braces_on_own_line) {
            prefix = 'NEWLINE';
          } else {
            prefix = 'SPACE';
            print_single_space();
          }
        }
      } else if (last_type === 'TK_SEMICOLON' && (flags.mode === 'BLOCK' || flags.mode === 'DO_BLOCK')) {
        prefix = 'NEWLINE';
      } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
        prefix = 'SPACE';
      } else if (last_type === 'TK_STRING') {
        prefix = 'NEWLINE';
      } else if (last_type === 'TK_WORD') {
        prefix = 'SPACE';
      } else if (last_type === 'TK_START_BLOCK') {
        prefix = 'NEWLINE';
      } else if (last_type === 'TK_END_EXPR') {
        print_single_space();
        prefix = 'NEWLINE';
      }

      if (flags.if_line && last_type === 'TK_END_EXPR') {
        flags.if_line = false;
      }
      if (in_array(token_text.toLowerCase(), ['else', 'catch', 'finally'])) {
        if (last_type !== 'TK_END_BLOCK' || opt_braces_on_own_line) {
          print_newline();
        } else {
          trim_output(true);
          print_single_space();
        }
      } else if (in_array(token_text, line_starters) || prefix === 'NEWLINE') {
        if ((last_type === 'TK_START_EXPR' || last_text === '=' || last_text === ',') && token_text === 'function') {
          // no need to force newline on 'function': (function
          // DONOTHING
        } else if (last_text === 'return' || last_text === 'throw') {
          // no newline between 'return nnn'
          print_single_space();
        } else if (last_type !== 'TK_END_EXPR') {
          if ((last_type !== 'TK_START_EXPR' || token_text !== 'var') && last_text !== ':') {
            // no need to force newline on 'var': for (var x = 0...)
            if (token_text === 'if' && last_word === 'else' && last_text !== '{') {
              // no newline for } else if {
              print_single_space();
            } else {
              print_newline();
            }
          }
        } else {
          if (in_array(token_text, line_starters) && last_text !== ')') {
            print_newline();
          }
        }
      } else if (is_array(flags.mode) && last_text === ',' && last_last_text === '}') {
        print_newline(); // }, in lists get a newline treatment
      } else if (prefix === 'SPACE') {
        print_single_space();
      }
      print_token();
      last_word = token_text;

      if (token_text === 'var') {
        flags.var_line = true;
        flags.var_line_reindented = false;
        flags.var_line_tainted = false;
      }

      if (token_text === 'if') {
        flags.if_line = true;
      }
      if (token_text === 'else') {
        flags.if_line = false;
      }

      break;

    case 'TK_SEMICOLON':

      print_token();
      flags.var_line = false;
      flags.var_line_reindented = false;
      break;

    case 'TK_STRING':

      if (last_type === 'TK_START_BLOCK' || last_type === 'TK_END_BLOCK' || last_type === 'TK_SEMICOLON') {
        print_newline();
      } else if (last_type === 'TK_WORD') {
        print_single_space();
      }
      print_token();
      break;

    case 'TK_EQUALS':
      if (flags.var_line) {
        // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
        flags.var_line_tainted = true;
      }
      print_single_space();
      print_token();
      print_single_space();
      break;

    case 'TK_OPERATOR':

      var space_before = true;
      var space_after = true;

      if (flags.var_line && token_text === ',' && (is_expression(flags.mode))) {
        // do not break on comma, for(var a = 1, b = 2)
        flags.var_line_tainted = false;
      }

      if (flags.var_line) {
        if (token_text === ',') {
          if (flags.var_line_tainted) {
            print_token();
            flags.var_line_reindented = true;
            flags.var_line_tainted = false;
            print_newline();
            break;
          } else {
            flags.var_line_tainted = false;
          }
          // } else if (token_text === ':') {
          // hmm, when does this happen? tests don't catch this
          // flags.var_line = false;
        }
      }

      if (last_text === 'return' || last_text === 'throw') {
        // "return" had a special handling in TK_WORD. Now we need to return the favor
        print_single_space();
        print_token();
        break;
      }

      if (token_text === ':' && flags.in_case) {
        print_token(); // colon really asks for separate treatment
        print_newline();
        flags.in_case = false;
        break;
      }

      if (token_text === '::') {
        // no spaces around exotic namespacing syntax operator
        print_token();
        break;
      }

      if (token_text === ',') {
        if (flags.var_line) {
          if (flags.var_line_tainted) {
            print_token();
            print_newline();
            flags.var_line_tainted = false;
          } else {
            print_token();
            print_single_space();
          }
        } else if (last_type === 'TK_END_BLOCK' && flags.mode !== "(EXPRESSION)") {
          print_token();
          if (flags.mode === 'OBJECT' && last_text === '}') {
            print_newline();
          } else {
            print_single_space();
          }
        } else {
          if (flags.mode === 'OBJECT') {
            print_token();
            print_newline();
          } else {
            // EXPR or DO_BLOCK
            print_token();
            print_single_space();
          }
        }
        break;
        // } else if (in_array(token_text, ['--', '++', '!']) || (in_array(token_text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS']) || in_array(last_text, line_starters) || in_array(last_text, ['==', '!=', '+=', '-=', '*=', '/=', '+', '-'])))) {
      } else if (in_array(token_text, ['--', '++', '!']) || (in_array(token_text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(last_text, line_starters)))) {
        // unary operators (and binary +/- pretending to be unary) special cases
        space_before = false;
        space_after = false;

        if (last_text === ';' && is_expression(flags.mode)) {
          // for (;; ++i)
          // ^^^
          space_before = true;
        }
        if (last_type === 'TK_WORD' && in_array(last_text, line_starters)) {
          space_before = true;
        }

        if (flags.mode === 'BLOCK' && (last_text === '{' || last_text === ';')) {
          // { foo; --i }
          // foo(); --bar;
          print_newline();
        }
      } else if (token_text === '.') {
        // decimal digits or object.property
        space_before = false;

      } else if (token_text === ':') {
        if (!is_ternary_op()) {
          flags.mode = 'OBJECT';
          space_before = false;
        }
      }
      if (space_before) {
        print_single_space();
      }

      print_token();

      if (space_after) {
        print_single_space();
      }

      if (token_text === '!') {
        // flags.eat_next_space = true;
      }

      break;

    case 'TK_BLOCK_COMMENT':

      var lines = token_text.split(/\x0a|\x0d\x0a/);

      if (/^\/\*\*/.test(token_text)) {
        // javadoc: reformat and reindent
        print_newline();
        output.push(lines[0]);
        for (i = 1; i < lines.length; i++) {
          print_newline();
          output.push(' ');
          output.push(trim(lines[i]));
        }

      } else {

        // simple block comment: leave intact
        if (lines.length > 1) {
          // multiline comment block starts with a new line
          print_newline();
          trim_output();
        } else {
          // single-line /* comment */ stays where it is
          print_single_space();

        }

        for (i = 0; i < lines.length; i++) {
          output.push(lines[i]);
          output.push('\n');
        }

      }
      print_newline();
      break;

    case 'TK_INLINE_COMMENT':

      print_single_space();
      print_token();
      if (is_expression(flags.mode)) {
        print_single_space();
      } else {
        print_newline();
      }
      break;

    case 'TK_COMMENT':

      // print_newline();
      if (wanted_newline) {
        print_newline();
      } else {
        print_single_space();
      }
      print_token();
      print_newline();
      break;

    case 'TK_UNKNOWN':
      if (last_text === 'return' || last_text === 'throw') {
        print_single_space();
      }
      print_token();
      break;
    }

    last_last_text = last_text;
    last_type = token_type;
    last_text = token_text;
  }

  return output.join('').replace(/[\n ]+$/, '');

}

// Add support for CommonJS. Just put this file somewhere on your require.paths
// and you will be able to `var js_beautify = require("beautify").js_beautify`.
if (typeof exports !== "undefined") exports.js_beautify = js_beautify;







// Fonction Indente: adaptée de jsBeautify

function Indente() {
  GEBID('lecode').value = editor.getValue();
  var js_source = GEBID('lecode').value.replace(/^\s+/, '');
  GEBID('lecode').value = js_beautify(js_source, {
    indent_size: 2, braces_on_own_line: false
  });
  //js_source = GEBID('builtin_codejs').value.replace(/^\s+/, '');
  //GEBID('builtin_codejs').value = js_beautify(js_source,{indent_size :2});
  editor.setValue(GEBID('lecode').value);
  return true;
}


//-->
</script>
		<script type="text/javascript" id="AllScripts">

// <!--

// Gestion Dropbox
var client, taskTable, DropboxSync=false;

function InitDropbox() {
  var DROPBOXKEY = '9i1w6khg9467g15';

  client = new Dropbox.Client({
    key: DROPBOXKEY,
  });

  // Try to finish OAuth authorization.
  client.authenticate({
    interactive: true
  }, function(error) {
    if (error) {
      alert('Authentication error: ' + error);
    } else {
   }
  });

  if (client.isAuthenticated()) {
    client.readdir('',{},function(error, filesystem) {
      if (error) {
        alert('Error opening default datastore: ' + error);
      }

      // AfficherTableau(filesystem);
    });
     client.getDatastoreManager().openDefaultDatastore(function(error, datastore) {
      if (error) {
        alert('Error opening default datastore: ' + error);
      }

      taskTable = datastore.getTable('Files_AlgoScripts');
	  DropboxSync=true;
      if (DropboxSync) {
        var fichier = taskTable.query({});
        for (var i = 0; i < Taille(fichier); i++) {
          if (fichier[i].has('filename')) window.localStorage[fichier[i].get('filename')] = fichier[i].get('filecontents');
        }
      }
    });
  }
}

function importDropbox_file_to_InternalFS(filenameDB,filenameIFS) {
  var xhr = client.readFile(filenameDB, null, function(error, fs) {
    window.localStorage[filenameIFS]=fs;
  });
}

function lsDropboxFile() {
    client.readdir('',{},function(error, filesystem) {
      if (error) {
        return null;
      }

      AfficherTableau(filesystem);
    });
}

function exportAllFStoDropboxFS() {
  for (p in window.localStorage) {
    if (SousChaine(p,0,Longueur('dropbox-auth')) != 'dropbox-auth') 
	    var xhr = client.writeFile(p, window.localStorage[p], null, function(error) {});
  }
}

function readDropboxFile(myfilename) {
	var fichier=taskTable.query({filename: myfilename});
    if (Taille(fichier)>0)
	    return (fichier[0].get('filecontents'));
	else return 'ERRORNOFILE';
}

function writeDropboxFile(myfilename, myfilecontents) {
	var fichier=taskTable.query({filename: myfilename});
    try {
    if (Longueur(myfilecontents)<99000) {
    if (Taille(fichier)>0) {
	    fichier[0].update({filecontents: myfilecontents});
    } else {
		taskTable.insert({filename: myfilename, filecontents: myfilecontents});
    }
    } else Ecrire('ERROR : '+myfilename+' too big to be symchronized (Size='+Longueur(myfilecontents)+')');
    } catch (e) {alert('ERROR '+e);}
}

function removeDropboxFile(myfilename) {
	var fichier=taskTable.query({filename: myfilename});
    if (Taille(fichier)>0)
	    fichier[0].deleteRecord();	
}

function lsDropbox() {
	var fichier=taskTable.query({});
	for(var i=0; i<Taille(fichier); i++) {
		if (fichier[i].has('filename')) Ecrire(fichier[i].get('filename'));		
	}
}

function exportLibraryToDropbox() {
	for(p in window.localStorage) {
		if (SousChaine(p,0,Longueur('dropbox-auth')) != 'dropbox-auth') 
			writeDropboxFile(p,readFile(p));
	}
}













// Gestion des évènements

builtin_oldfilename='';


function builtincapturetouch(e) {
	// Ecrire('capturetouch '+ e.changedTouches[0].pageY);
	e.preventDefault();
	var decy=GEBID('mycanvas').style.top.replace('px','');
	var y=(e.changedTouches[0].clientY-decy) * Math.abs(maxviewport_y-minviewport_y) / size_canvas_y;
	if (viewport_dir == 1) {
		y+=minviewport_y;
	} else {
		y=maxviewport_y-y;
	}
	if (builtinclick) MouseClick(minviewport_x+e.changedTouches[0].clientX * Math.abs(maxviewport_x-minviewport_x) / size_canvas_x, 
			   y);
}

var builtinclick=false;

function builtinMouseDown(e) {
	// Ecrire('MouseDown');
	e.preventDefault();
	builtinclick=true;
	var decy=GEBID('mycanvas').style.top.replace('px','');
        
	if (typeof(e.changedTouches) != 'undefined') builtincapturemouse({layerX:e.changedTouches[0].clientX, layerY:(e.changedTouches[0].clientY-decy)});
	else builtincapturemouse(e);
}

function builtinMouseUp(e) {
	// Ecrire('MouseUp');
	e.preventDefault();
	builtinclick=false;
}

function builtinMouseMoveEvent(e) {
	// Ecrire('MouseMove');
	e.preventDefault();
	var y=e.layerY * Math.abs(maxviewport_y-minviewport_y) / size_canvas_y;
	if (viewport_dir == 1) {
		y+=minviewport_y;
	} else {
		y=maxviewport_y-y;
	}
	if (builtinclick) MouseMove(minviewport_x+e.layerX * Math.abs(maxviewport_x-minviewport_x) / size_canvas_x, 
			   y);
}





function builtincapturemouse(e) {
	var y=e.layerY * Math.abs(maxviewport_y-minviewport_y) / size_canvas_y;
	if (viewport_dir == 1) {
		y+=minviewport_y;
	} else {
		y=maxviewport_y-y;
	}
	MouseClick(minviewport_x+e.layerX * Math.abs(maxviewport_x-minviewport_x) / size_canvas_x, 
			   y);
}

/*
Initialiser();
var old_x=-1;
var old_y=-1;
function MouseClick(x,y) {
  if (old_x>0) {
	  Ligne(old_x,old_y,x,y,'black');
  }
  old_x=x;
  old_y=y;
}
*/

function builtincapturekey(e) {
	var res='';
	for(p in e) res+=p+'='+e[p]+'\n';
	alert(res);
//	Keypressed(Ascii_vers_Caractere(e.charCode));
}

function Keypressed(t) {}

function MouseClick(x,y) {
}

function MouseMove(x,y) {
}


// Gestion des sons
// Reprise de la classe RIFFWAVE
var FastBase64 = {

  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  encLookup: [],

  Init: function() {
    for (var i = 0; i < 4096; i++) {
      this.encLookup[i] = this.chars[i >> 6] + this.chars[i & 0x3F];
    }
  },

  Encode: function(src) {
    var len = src.length;
    var dst = '';
    var i = 0;
    while (len > 2) {
      n = (src[i] << 16) | (src[i + 1] << 8) | src[i + 2];
      dst += this.encLookup[n >> 12] + this.encLookup[n & 0xFFF];
      len -= 3;
      i += 3;
    }
    if (len > 0) {
      var n1 = (src[i] & 0xFC) >> 2;
      var n2 = (src[i] & 0x03) << 4;
      if (len > 1) n2 |= (src[++i] & 0xF0) >> 4;
      dst += this.chars[n1];
      dst += this.chars[n2];
      if (len == 2) {
        var n3 = (src[i++] & 0x0F) << 2;
        n3 |= (src[i] & 0xC0) >> 6;
        dst += this.chars[n3];
      }
      if (len == 1) dst += '=';
      dst += '=';
    }
    return dst;
  } // end Encode
}

FastBase64.Init();

var RIFFWAVE = function(data) {

  this.data = []; // Byte array containing audio samples
  this.wav = []; // Array containing the generated wave file
  this.dataURI = ''; // http://en.wikipedia.org/wiki/Data_URI_scheme
  this.header = { // OFFS SIZE NOTES
    chunkId: [0x52, 0x49, 0x46, 0x46],
    // 0    4    "RIFF" = 0x52494646
    chunkSize: 0,
    // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)
    format: [0x57, 0x41, 0x56, 0x45],
    // 8    4    "WAVE" = 0x57415645
    subChunk1Id: [0x66, 0x6d, 0x74, 0x20],
    // 12   4    "fmt " = 0x666d7420
    subChunk1Size: 16,
    // 16   4    16 for PCM
    audioFormat: 1,
    // 20   2    PCM = 1
    numChannels: 1,
    // 22   2    Mono = 1, Stereo = 2, etc.
    sampleRate: 8000,
    // 24   4    8000, 44100, etc
    byteRate: 0,
    // 28   4    SampleRate*NumChannels*BitsPerSample/8
    blockAlign: 0,
    // 32   2    NumChannels*BitsPerSample/8
    bitsPerSample: 8,
    // 34   2    8 bits = 8, 16 bits = 16, etc...
    subChunk2Id: [0x64, 0x61, 0x74, 0x61],
    // 36   4    "data" = 0x64617461
    subChunk2Size: 0 // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8
  };

  function u32ToArray(i) {
    return [i & 0xFF, (i >> 8) & 0xFF, (i >> 16) & 0xFF, (i >> 24) & 0xFF];
  }

  function u16ToArray(i) {
    return [i & 0xFF, (i >> 8) & 0xFF];
  }

  this.Make = function(data) {
    if (data instanceof Array) this.data = data;
    this.header.byteRate = (this.header.sampleRate * this.header.numChannels * this.header.bitsPerSample) >> 3;
    this.header.blockAlign = (this.header.numChannels * this.header.bitsPerSample) >> 3;
    this.header.subChunk2Size = this.data.length;
    this.header.chunkSize = 36 + this.header.subChunk2Size;

    this.wav = this.header.chunkId.concat(
    u32ToArray(this.header.chunkSize), this.header.format, this.header.subChunk1Id, u32ToArray(this.header.subChunk1Size), u16ToArray(this.header.audioFormat), u16ToArray(this.header.numChannels), u32ToArray(this.header.sampleRate), u32ToArray(this.header.byteRate), u16ToArray(this.header.blockAlign), u16ToArray(this.header.bitsPerSample), this.header.subChunk2Id, u32ToArray(this.header.subChunk2Size), this.data);
    this.dataURI = 'data:audio/wav;base64,' + FastBase64.Encode(this.wav);
  };

  if (data instanceof Array) this.Make(data);

}; // end RIFFWAVE


function ChargerSon(url) {
  // Charge un son stocké dans un fichier externe
  var res = document.createElement('audio');
  res.setAttribute('src', url);
  res.load();
  return res;
}

function CreerSon(data, samplerate) {
  // création d'un objet sonore à partir d'un tableau et d'un taux d'échantillonnage
  var wave = new RIFFWAVE();
  wave.header.sampleRate = samplerate;
  wave.header.numChannels = 1;
  wave.Make(data);
  var res = document.createElement('audio');
  res.setAttribute('src', wave.dataURI);
  res.load();
  return res;
}


function encode64(input) {
var keyStr = "ABCDEFGHIJKLMNOP" + "QRSTUVWXYZabcdef" + "ghijklmnopqrstuv" + "wxyz0123456789+/" + "=";
  input = escape(input);
  var output = "";
  var chr1, chr2, chr3 = "";
  var enc1, enc2, enc3, enc4 = "";
  var i = 0;

  do {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);

    enc1 = chr1 >> 2;
    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
    enc4 = chr3 & 63;

    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }

    output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
    chr1 = chr2 = chr3 = "";
    enc1 = enc2 = enc3 = enc4 = "";
  } while (i < input.length);

  return output;
}

function decode64(input) {
var keyStr = "ABCDEFGHIJKLMNOP" + "QRSTUVWXYZabcdef" + "ghijklmnopqrstuv" + "wxyz0123456789+/" + "=";
  var output = "";
  var chr1, chr2, chr3 = "";
  var enc1, enc2, enc3, enc4 = "";
  var i = 0;

  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  var base64test = /[^A-Za-z0-9\+\/\=]/g;
  if (base64test.exec(input)) {
    alert("There were invalid base64 characters in the input text.\n" + "Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\n" + "Expect errors in decoding.");
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 != 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 != 64) {
      output = output + String.fromCharCode(chr3);
    }

    chr1 = chr2 = chr3 = "";
    enc1 = enc2 = enc3 = enc4 = "";

  } while (i < input.length);

  return unescape(output);
}


function ImportSon(nomfichier) {
  var sonurl = readFile(nomfichier).replace(/^[\s\n]+/g,'').replace(/[\s\n]+$/g,'');
  var sondata = decode64(SousChaine(sonurl, PositionDans(sonurl, 'base64') + 7), Longueur(sonurl));
  var numchannels = Caractere_vers_Ascii(sondata[22]) + Caractere_vers_Ascii(sondata[23]) * 256;
  var samplerate = Caractere_vers_Ascii(sondata[24]) + Caractere_vers_Ascii(sondata[25]) * 256 + 256 * 256 * Caractere_vers_Ascii(sondata[26]) + Caractere_vers_Ascii(sondata[27]) * 256 * 256 * 256;
  var bitssample = Caractere_vers_Ascii(sondata[34]) + Caractere_vers_Ascii(sondata[35]) * 256;
/*
Ecrire(numchannels + ' canaux');
Ecrire(samplerate + ' SR');
Ecrire(bitssample + ' b/s');
*/
  var decalage = Math.floor(bitssample / 8);

  var data = Tableau();
  var k = 0;
  for (var i = 0; i < Longueur(sondata) - 44; i += decalage) {
    data[k] = 0;
    puiss = 1;
    for (var j = 0; j < decalage && (44 + i + j < Longueur(sondata)); j++) {
      data[k] += (Caractere_vers_Ascii(CaractereEn(sondata, 44 + i + j, 1))) * puiss;
      puiss *= 256;
    }
    k++;
  }

  // pb du 0
  var maxval = Math.pow(2, bitssample);

  if (bitssample > 8) {
    for (var i = 0; i < Taille(data); i += 1) {
      // Pour une conversion en signed 16bits
      if (data[i] > maxval / 2) data[i] = data[i] - maxval;
      data[i] = Math.floor(0.5 * 256 * (data[i]) / maxval + 127);
    }
  }
  return data;
}

function SampleRate(nomfichier) {
  var sonurl = readFile(nomfichier).replace(/^[\s\n]+/g,'').replace(/[\s\n]+$/g,'');
  var sondata = decode64(SousChaine(sonurl, PositionDans(sonurl, 'base64') + 7), Longueur(sonurl));
  var samplerate = Caractere_vers_Ascii(sondata[24]) + Caractere_vers_Ascii(sondata[25]) * 256 + 256 * 256 * Caractere_vers_Ascii(sondata[26]) + Caractere_vers_Ascii(sondata[27]) * 256 * 256 * 256;
  return samplerate;
}

function SauverSon(nomfichier, data, samplerate) {
  // création d'un objet sonore à partir d'un tableau et d'un taux d'échantillonnage
  var wave = new RIFFWAVE();
  wave.header.sampleRate = samplerate;
  wave.header.numChannels = 1;
  wave.Make(data);
  writeFile(nomfichier, wave.dataURI);
}

function ExportSon(data, samplerate) {
  // création d'un objet sonore à partir d'un tableau et d'un taux d'échantillonnage
  var wave = new RIFFWAVE();
  wave.header.sampleRate = samplerate;
  wave.header.numChannels = 1;
  wave.Make(data);
  window.open(wave.dataURI);
}



// Fin gestion des sons

// Début gestion des fichiers
function writeFile(filename,content) {
 window.localStorage[filename]=content;
 if (DropboxSync) writeDropboxFile(filename,content)
}

function EcrireDans(filename,content) {
 window.localStorage[filename]+=content;
}

function includeFile(filename) {
  try {window.eval(readFile(filename));} catch(e) {};
}

function readAllFS(str) {
    var tab = str.split('\n');
	str = '';
	var flag = false;
	for (var i = 0; i < Taille(tab); i++) {
  		tab[i] = tab[i].replace(new RegExp('^[\-]{3,100}', 'g'), '-=-=-=-=-');
  		if (flag) str += '\n';
  		flag=true;
  		str += tab[i];
	}
    var tab=str.split('-=-=-=-=-');
    for(var i=0; i<Taille(tab);i+=2) {
        writeFile(tab[i].replace(/\n/g,''),tab[i+1]);
    }
}

function ls() {
 for(p in window.localStorage) Ecrire(p);
}

function directory() {
 var res=''; for(p in window.localStorage) if (SousChaine(p,0,Longueur('dropbox-auth')) != 'dropbox-auth') res+=p+'\n'; return res;
}

function readFile(filename) {
 return window.localStorage[filename];
}

function removeFile(filename) {
 delete window.localStorage[filename];
  if (DropboxSync) removeDropboxFile(filename)

}

function clearAllFS() {
 for(var p in window.localStorage) removeFile(p);
}

function FileExists(filename) {
	return (window.localStorage[filename])?true:false;
}

function renameFile(oldname,newname) {
 writeFile(newname,readFile(oldname));
 removeFile(oldname);
}

function removeAllFiles() {
 for(var p in window.localStorage) removeFile(p);
}

// Fin gestion des ES

var Exemples_javascripts_nom = Array();
var Exemples_javascripts_inst = Array();
var Exemples_javascripts_fonctions = Array();


Exemples_javascripts_nom[0] = "Exemple d'utilisation d'AfficherCourbe";

Exemples_javascripts_inst[0] = "var tab=new Array(1,3,5,2,4);\nvar tab2=new Array(16,2,1,3,4);\n// Obtenir de l'aide sur AfficherCourbe\nAfficherCourbe();\nAfficherCourbe(tab2);\nAfficherCourbe(tab,true,false,'green','X',1);\n";

Exemples_javascripts_fonctions[0] = "";

function texte_a_etudier() {
  return GEBID("MonTexte").value;
}

function getEntreetexte() {
  return GEBID("MonTexte").value;
}

function setEntreetexte(valeur) {
  GEBID("MonTexte").value=valeur;
}

function AfficherTableau(tab) {
  for (var i = 0; i < tab.length; i++) {
    if (typeof(tab[i]) != "object") Afficher(tab[i]);
    else {
      ligne = "";
      for (var p in tab[i])
      ligne = ligne + tab[i][p] + "\t";
      Afficher(ligne);
    }
  }
}

function affiche_tableau(tab) {
  AfficherTableau(tab);
}

//function Point(x,y) {var res=new Array(x,y); return res;}

function point(x1, y1) {
  var tab = new Array(x1, y1);
  return (tab);
}

Exemples_javascripts_nom[1] = "Animation";

Exemples_javascripts_inst[1] = "Initialiser();\nAfficheGraphique();Anim(0);";

Exemples_javascripts_fonctions[1] = "function Anim(t) {\n  if (t<600) {\n    Effacer();\n    for(i=1; i<480; i++) {\n      Point(i,150+50*Math.cos((i+t)*3.14/180),'red');\n    }\n   setTimeout('Anim('+(t+1)+')',1);\n  }\n}";

Exemples_javascripts_nom[2] = "Fractale de Von Koch";

Exemples_javascripts_inst[2] = "Initialiser(); Viewport(0,0,600,400,1)\nDeplacer(100,100);\nDroite(90);\nAfficheGraphique();\nvar ch=Lsystems('F','F-F++F-F',4);\ninterprete(ch,2,60);\nDroite(120);\ninterprete(ch,2,60);\nDroite(120);\ninterprete(ch,2,60);\nDroite(120);\n";

Exemples_javascripts_fonctions[2] = "function Lsystems(current,regles,n) {\n  if (n<1)\n    return current;\n  else {\n    var res='';\n    var i;\n    for (i=0; i<current.length; i++) {\n      if (current.charAt(i) == 'F') {\n        res=res+regles;\n      } else {\n        res=res+current.charAt(i);\n      }\n    }\n    return Lsystems(res,regles,n-1);\n  }\n}\n\nfunction interprete(ch,l,a) {\n  var i;\n  for (i=0; i<ch.length; i++) {\n    switch (ch.charAt(i)) {\n    case 'F' : Avancer(l); break;\n    case '+' : Droite(a); break;\n    case '-' : Gauche(a); break;\n    }\n  }\n}\n";

Exemples_javascripts_nom[3] = "Fractale Ensemble de Mandelbrot";

Exemples_javascripts_inst[3] = "Initialiser(); Viewport(0,0,300,200,1);\nHideTurtle();\nAfficheGraphique();\nMandelbrot();\nStop('');\nDrawTurtle();\n";

Exemples_javascripts_fonctions[3] = "function TranslateX(x) {\n	return x*3/300-2;\n}\n\nfunction TranslateY(y) {\n	return (y-100)*3/200;\n}\n\n\nfunction Mandelbrot() {\n	var i;\n	var j;\n	for(i=0; i<300; i++) {\n		for(j=0; j<200; j++) {\n		var macouleur=CouleurMandelbrot(TranslateX(i),TranslateY(j));\n			var chcouleur='rgb('+((macouleur*4)%256)+',0,0)';\n			RectanglePlein(i,j,1,1,chcouleur);\n		}\n	}\n}\n\nfunction module(x,y) {\n	return Math.sqrt(x*x+y*y);\n}\n\nfunction CouleurMandelbrot(a,b) {\n	var i=0;\n	var x=a;\n	var y=b;\n	do {\n		var tmp=x;\n		x=x*x-y*y+a;\n		y=2*tmp*y+b;\n                i++;\n	}\n while ((module(x,y)<2) && (i<50));\n	return 50-i;\n}";


function putExemple(i) {
  if (Exemples_javascripts_inst[i] != '') GEBID('lecode').value = Exemples_javascripts_inst[i];
  //	if (Exemples_javascripts_fonctions[i] != '') GEBID('builtin_codejs').value=Exemples_javascripts_fonctions[i];
  if (Exemples_javascripts_fonctions[i] != '') GEBID('lecode').value += Exemples_javascripts_fonctions[i];
  //GEBID('Aide').style.visibility='hidden';
  // pour CodeMirror
  editor.setValue(GEBID('lecode').value);
  // fin
  GEBID('titre_onglet').selectedIndex = 0;
  MontreFenetre(0);
}

function ConstruitExemples() {
  var i;
  document.writeln('<ul>');
  for (i = 0; i < Exemples_javascripts_nom.length; i++) {
    document.writeln('<li><a href="javascript:(void(0))" onclick="putExemple(' + i + ')">' + Exemples_javascripts_nom[i] + '</a></li>');
  }
  document.writeln('</ul>');
}



function chronometre(instruction) {
  var avant = new Date();
  eval(instruction);
  var apres = new Date();
  return ((apres.getSeconds() - avant.getSeconds()) * 1000 + (apres.getMilliseconds() - avant.getMilliseconds()));
}

function builtin_max(a, b) {
  if (a < b) return b;
  else
  return a;
}

function InitGraphic() {
  canvas = GEBID('mycanvas');
  ctx = canvas.getContext('2d');
  DrawTurtle();
  CacheGraphique();
}

function AfficheGraphique() {
  fenetre_courante = builtin_fenetregraphique;
  MontreFenetre(0);
}

function CacheGraphique() {}

function Effacer() {
  HideTurtle();
  ctx.clearRect(0, 0, size_canvas_x, size_canvas_y);
  DrawTurtle();
}

function Rotation(angle) {
	ctx.setTransform(Math.cos(angle*3.14/180),Math.sin(angle*3.14/180),-Math.sin(angle*3.14/180),Math.cos(angle*3.14/180),1,1);
}

function Transformation(a,b,c,d,e,f) {
	ctx.setTransform(a,b,c,d,e,f);
}

function Initialiser() {
  currentx = 0;
  currenty = 0;
  currentcolor = 'black';
  ctx.strokeStyle = currentcolor;
  ctx.fillStyle = currentcolor;
  ctx.lineWidth = 1;
  currentangle = 0;
  plotflag = true;
  Viewport(0, 0, size_canvas_x, size_canvas_y, 1);
  Deplacer(200, 200);
  Rotation(0);
  ShadowOff();
  Effacer();
  HideTurtle();
}

var canvas;
var ctx;

var currentx = 0;
var currenty = 0;
var plotflag = true;
var currentcolor = 'black';
var currentangle = 0;
var currentMask;
var currentMaskX = 0;
var currentMaskY = 0;
var sizeTurtle = 10;
var minviewport_x = 0;
var minviewport_y = 0;
var maxviewport_x = 480;
var maxviewport_y = 300;
var viewport_dir = -1;
var turtleEnabled=true;

function Viewport(minx, miny, maxx, maxy, dir) {
  minviewport_x = minx;
  minviewport_y = miny;
  maxviewport_x = maxx;
  maxviewport_y = maxy;
  viewport_dir = dir;
}

function ViewX(x) {
  x = (x - minviewport_x) * size_canvas_x / (maxviewport_x - minviewport_x);
  if (x < 0) return 0;
  if (x >= size_canvas_x) return size_canvas_x - 1;
  return x;
}

function ViewY(y) {
  if (viewport_dir == 1) y = (y - minviewport_y) * size_canvas_y / (maxviewport_y - minviewport_y);
  else
  y = size_canvas_y - (y - minviewport_y) * size_canvas_y / (maxviewport_y - minviewport_y);
  if (y < 0) return 0;
  if (y >= size_canvas_y) return size_canvas_y - 1;
  return y;

}

function ShadowOn() {
	ctx.shadowColor='black';
	ctx.shadowBlur=3;
	ctx.shadowOffsetX=3;
	ctx.shadowOffsetY=3;
}

function ShadowOff() {
	ctx.shadowColor='black';
	ctx.shadowBlur=0;
	ctx.shadowOffsetX=0;
	ctx.shadowOffsetY=0;
}

function Ligne(x0, y0, x1, y1, color) {
  ctx.strokeStyle = color;
  ctx.beginPath();
  ctx.moveTo(ViewX(x0), ViewY(y0));
  ctx.lineTo(ViewX(x1), ViewY(y1));
  ctx.closePath();
  ctx.stroke();
}

function Cercle(x0, y0, r, color) {
  Ellipse(x0,y0,r,r,color);
}

function CerclePlein(x0, y0, r, color) {
  EllipsePlein(x0,y0,r,r,color);
}

function DrawImage(imageurl,x,y,w,h) { 
	var monim=new Image();
	monim.src=imageurl.replace(/^[\s\n]+/g,'').replace(/[\s\n]+$/g,'').replace(/\n/g,'');
	ctx.drawImage(monim,ViewX(x), ViewY(y),ViewX(w), ViewY(h));
}

function Ellipse(x, y, w, h, color) {
  x-=w/2;
  y-=h/2;
  var kappa = .5522848;
      ox = (w / 2) * kappa, // control point offset horizontal
      oy = (h / 2) * kappa, // control point offset vertical
      xe = x + w,           // x-end
      ye = y + h,           // y-end
      xm = x + w / 2,       // x-middle
      ym = y + h / 2;       // y-middle

  ctx.strokeStyle = color;
  ctx.beginPath();
  ctx.moveTo(ViewX(x), ViewY(ym));
  ctx.bezierCurveTo(ViewX(x), ViewY(ym - oy), ViewX(xm - ox), ViewY(y), ViewX(xm), ViewY(y));
  ctx.bezierCurveTo(ViewX(xm + ox), ViewY(y), ViewX(xe), ViewY(ym - oy), ViewX(xe), ViewY(ym));
  ctx.bezierCurveTo(ViewX(xe), ViewY(ym + oy), ViewX(xm + ox), ViewY(ye), ViewX(xm), ViewY(ye));
  ctx.bezierCurveTo(ViewX(xm - ox), ViewY(ye), ViewX(x), ViewY(ym + oy), ViewX(x), ViewY(ym));
  ctx.closePath();
  ctx.stroke();
}

function EllipsePlein(x, y, w, h, color) {
  x-=w/2;
  y-=h/2;
  var kappa = .5522848;
      ox = (w / 2) * kappa, // control point offset horizontal
      oy = (h / 2) * kappa, // control point offset vertical
      xe = x + w,           // x-end
      ye = y + h,           // y-end
      xm = x + w / 2,       // x-middle
      ym = y + h / 2;       // y-middle

  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(ViewX(x), ViewY(ym));
  ctx.bezierCurveTo(ViewX(x), ViewY(ym - oy), ViewX(xm - ox), ViewY(y), ViewX(xm), ViewY(y));
  ctx.bezierCurveTo(ViewX(xm + ox), ViewY(y), ViewX(xe), ViewY(ym - oy), ViewX(xe), ViewY(ym));
  ctx.bezierCurveTo(ViewX(xe), ViewY(ym + oy), ViewX(xm + ox), ViewY(ye), ViewX(xm), ViewY(ye));
  ctx.bezierCurveTo(ViewX(xm - ox), ViewY(ye), ViewX(x), ViewY(ym + oy), ViewX(x), ViewY(ym));
  ctx.closePath();
  ctx.fill();
}

function Rectangle(x, y, l, h, color) {
  ctx.strokeStyle = color;
  ctx.strokeRect(ViewX(x), ViewY(y), l * size_canvas_x / (maxviewport_x - minviewport_x), h * size_canvas_y / (maxviewport_y - minviewport_y))
}

function RectanglePlein(x, y, l, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(ViewX(x), ViewY(y), (l * size_canvas_x / (maxviewport_x - minviewport_x)) , (h * size_canvas_y / (maxviewport_y - minviewport_y)) );
}


function Point(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(ViewX(x), ViewY(y), 1, 1);
}

function Texte(x, y, ch, color) {
  ctx.fillStyle = color;
  ctx.fillText(ch, ViewX(x), ViewY(y));
}

function setCanvasFont(_fontname, _fontsize, _extrastyle) {
	ctx.font = _extrastyle+' '+_fontsize+' '+_fontname;
}

function GradientLineaire(couleur1,couleur2,xd,yd,xf,yf) {
	var grd=ctx.createLinearGradient(ViewX(xd),ViewY(yd),ViewX(xf),ViewY(yf));
	grd.addColorStop(0,couleur1);
	grd.addColorStop(1,couleur2);
	return grd;
}

function AfficherCourbe() {
  if (AfficherCourbe.arguments.length == 0) {
    alert('ERROR AfficherCourbe/DrawTable\nUsage: AfficherCourbe/DrawTable(tab,[addition, filled, ColorLine, TypePoint=".OX", lineWidth])');
    return;
  }
  var tab = AfficherCourbe.arguments[0];
  var addition, filled, ColorLine, TypePoint, Eppline;
  if (AfficherCourbe.arguments.length > 1) addition = AfficherCourbe.arguments[1];
  else addition = false;
  if (AfficherCourbe.arguments.length > 2) filled = AfficherCourbe.arguments[2];
  else filled = true;
  if (AfficherCourbe.arguments.length > 3) ColorLine = AfficherCourbe.arguments[3];
  else ColorLine = 'rgb(255,0,0)';
  if (AfficherCourbe.arguments.length > 4) TypePoint = AfficherCourbe.arguments[4];
  else TypePoint = 'O';
  if (AfficherCourbe.arguments.length > 5) Eppline = AfficherCourbe.arguments[5];
  else Eppline = 5;
  if (!addition) {
    Initialiser();
    var minx = 0;
    var miny = 0;
    var maxx = 0;
    var maxy = 0;
    var x;
    var y;
    if (tab.length > 0) {
      if (typeof(tab[0]) != "object") {
        minx = 0;
        maxx = 0;
        miny = tab[0];
        maxy = tab[0];
      } else {
        minx = tab[0][0];
        maxx = tab[0][0];
        miny = tab[0][1];
        maxy = tab[0][1];
      }
    }

    for (var i = 0; i < tab.length; i++) {
      if (typeof(tab[i]) != "object") {
        x = i;
        y = tab[i];
      } else {
        x = tab[i][0];
        y = tab[i][1];
      }
      if (x < minx) minx = x;
      if (x > maxx) maxx = x;
      if (y < miny) miny = y;
      if (y > maxy) maxy = y;
    }
    Viewport(minx, miny, maxx, maxy, -1);
  }
  if (filled) CourbesFill(tab, 'rgb(200,200,255)');
  Courbes(tab, ColorLine, Eppline);
  AllPoints(tab, ColorLine, TypePoint);
}


function CourbesFill(tab, color) {
  ctx.fillStyle = color;
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(ViewX(minviewport_x), ViewY(minviewport_y));
  for (var i = 0; i < tab.length; i++) {
    if (typeof(tab[i]) != "object") ctx.lineTo(ViewX(i), ViewY(tab[i]));
    else {
      ctx.lineTo(ViewX(tab[i][0]), ViewY(tab[i][1]));
    }
  }
  ctx.lineTo(ViewX(maxviewport_x), ViewY(minviewport_y));
  //	ctx.lineTo(ViewX(minviewport_x),ViewY(minviewport_y));
  ctx.closePath();
  ctx.fill();
  ctx.lineWidth = 1;
}

function Courbes(tab, color, epp) {
  var x, y;
  ctx.strokeStyle = color;
  ctx.lineWidth = epp;
  ctx.beginPath();
  for (var i = 0; i < tab.length; i++) {
    if (typeof(tab[i]) != "object") {
      x = ViewX(i);
      y = ViewY(tab[i]);
    } else {
      x = ViewX(tab[i][0]);
      y = ViewY(tab[i][1]);
    }
    if (i == 0) ctx.moveTo(x, y);
    else
    ctx.lineTo(x, y);

  }
  //	ctx.closePath();
  ctx.stroke();
  ctx.lineWidth = 1;
}

function AllPoints(tab, color, typep) {
  ctx.fillStyle = color;
  ctx.lineWidth = 1;
  var x, y;
  for (var i = 0; i < tab.length; i++) {
    if (typeof(tab[i]) != "object") {
      x = ViewX(i);
      y = ViewY(tab[i]);
    } else {
      x = ViewX(tab[i][0]);
      y = ViewY(tab[i][1]);
    }
    if (typep == "O") {
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, Math.PI * 2, true);
      ctx.fill();
    } else if (typep == "X") {
      ctx.beginPath();
      ctx.moveTo(x - 5, y - 5);
      ctx.lineTo(x + 5, y + 5);
      ctx.moveTo(x - 5, y + 5);
      ctx.lineTo(x + 5, y - 5);
      ctx.stroke();
    }
  }
  ctx.lineWidth = 1;
}


function DrawTurtle() {
  if (turtleEnabled) {
  currentMaskX = builtin_max(0, ViewX(currentx) - sizeTurtle * 2);
  currentMaskY = builtin_max(0, ViewY(currenty) - sizeTurtle * 2);
  currentMask = ctx.getImageData(currentMaskX, currentMaskY, sizeTurtle * 2 * 2, sizeTurtle * 2 * 2);
  ctx.fillStyle = 'blue';
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'black';
  ctx.beginPath();
  ctx.moveTo(ViewX(currentx), ViewY(currenty));
  ctx.lineTo(ViewX(currentx) + 0.5 * sizeTurtle * Math.cos(currentangle * 3.14 / 180), ViewY(currenty) - 0.5 * sizeTurtle * Math.sin(currentangle * 3.14 / 180));
  ctx.lineTo(ViewX(currentx) - sizeTurtle * Math.sin(currentangle * 3.14 / 180), ViewY(currenty) - 1.5 * sizeTurtle * Math.cos(currentangle * 3.14 / 180));
  ctx.lineTo(ViewX(currentx) - 0.5 * sizeTurtle * Math.cos(currentangle * 3.14 / 180), ViewY(currenty) + 0.5 * sizeTurtle * Math.sin(currentangle * 3.14 / 180));
  ctx.closePath();
  ctx.fill();
  }
}

function HideTurtle() {
  if (turtleEnabled) {
  ctx.putImageData(currentMask, currentMaskX, currentMaskY);
  }
}

function Gauche(a) {
  currentangle = (currentangle + a) % 360;
  HideTurtle();
  DrawTurtle();
}

function Droite(a) {
  currentangle = (360 + currentangle - a) % 360;
  HideTurtle();
  DrawTurtle();
}

function Avancer(l) {
  var newx = currentx - l * Math.sin(currentangle * 3.14 / 180);
  var newy = currenty - l * Math.cos(currentangle * 3.14 / 180);
  HideTurtle();
  if (plotflag) {
    Ligne(currentx, currenty, newx, newy, currentcolor);
  }
  currentx = newx;
  currenty = newy;
  DrawTurtle();
}

function Deplacer(x, y) {
  HideTurtle();
  currentx = x;
  currenty = y;
  DrawTurtle();
}

function Baisser() {
  plotflag = true;
}

function Couleur(c) {
  currentcolor = c;
}

function Lever() {
  plotflag = false;
}



// Manipulations de chaines de caract&egrave;res

function Caractere_vers_Ascii(c) {
  return c.charCodeAt(0);
}

function Ascii_vers_Caractere(n) {
  return String.fromCharCode(n);
}

function Majuscule(c) {
  return c.toUpperCase();
}

function CaractereEn(ch, i) {
  return ch.charAt(i);
}

function Longueur(ch) {
  return ch.length;
}

function SousChaine(ch, deb, long) {
  return ch.substr(deb, long);
}

function PositionDans(ch, ch_cherchee) {
  return ch.indexOf(ch_cherchee);
}

// Manipulation de Tableaux

function Tableau(n) {
  return new Array(n);
}

function Taille(T) {
  return T.length;
}

function InitialiserTableau(T, valeur) {
  for (var i = 0; i < T.length; i++) {
    T[i] = valeur;
  }
}

// AfficherTableau d&eacute;jà d&eacute;clar&eacute;e

function ConcateneTableaux(T1, T2) {
  return T1.concat(T2);
}

function CombineTableauxL(T1, T2) {
  return new Array(T1, T2);
}

function CombineTableauxC(T1, T2) {
  var res = new Array();
  for (var i = 0; i < builtin_max(T1.length, T2.length); i++) {
    res[i] = new Array(T1[i], T2[i]);
  }
  return res;
}

function Renverser(T) {
  return T.reverse();
}

function Numerique(a, b) {
  return a - b;
}

function OrdreNumerique(T) {
  var res = T.slice(0, T.length);
  return res.sort(Numerique);
}

function OrdreLexicographique(T) {
  var res = T.slice(0, T.length);
  return res.sort();
}

function SousTableau(T, debut, longueur) {
  return T.slice(debut, debut + longueur);
}

// Autres fonctions

function Hasard(n) {
  return (Math.random() * n) >> 0;
}


//-->
//    <!--

function resetVariables() {
  for (builtin_p in this) {
    if ((typeof(eval(builtin_p)) == 'number') || (typeof(eval(builtin_p)) == 'string')) {
      if (">>>|name|scrollX|scrollY|status|defaultStatus|innerWidth|innerHeight|outerWidth|outerHeight|screenX|screenY|pageXOffset|pageYOffset|scrollMaxX|scrollMaxY|length|builtin_courant|builtin_codejs|builtin_wait|builtin_p|".lastIndexOf('|' + builtin_p + '|') <= 0) {
        //		    		Afficher('reset '+p+' : '+typeof(eval(p))+' = '+eval(builtin_p));
        eval(builtin_p + '=undefined');
        //		    		Afficher('reset '+p+' : '+typeof(eval(p))+' = '+eval(builtin_p));
      }
    }
  }
}

var size_canvas_x;
var size_canvas_y;

function Init() {
  GEBID('sortie').disabled = true;
  size_canvas_x = 800;
  size_canvas_y = 600;
  // GEBID('mycanvas').onclick=builtincapturemouse;
  GEBID('mycanvas').ontouchstart=builtinMouseDown;
  GEBID('mycanvas').ontouchmove=builtincapturetouch;
  GEBID('mycanvas').ontouchend=builtinMouseUp;
  GEBID('mycanvas').onmousedown=builtinMouseDown;
  GEBID('mycanvas').onmouseup=builtinMouseUp;
  GEBID('mycanvas').onmousemove=builtinMouseMoveEvent;
  document.onkeypress=function (k) {Keypressed(k['charCode']+1000*k['keyCode']);};

}


var builtin_allvariables = '';

function getAllVariablesInMemory() {
  var i = 0;
  for (var p in window) {
    if ((typeof(eval("window." + p)) == "number") || (typeof(eval("window." + p)) == "boolean") || (typeof(eval("window." + p)) == "string")) {
      builtin_allvariables.push(p);
    }
  }
}

var builtin_wait = false;
var builtin_courant = '';
var builtin_code = Array();
var builtin_codejs;
var builtin_verrou=-1;

function Analyseur(ch) {
  var nbinstructions = 0;
  var instructions = Array();
  var deb = 0;
  var current = '';
  var parent = 0;
  var accolade = 0;
  var ligne = 0;
  var motcle = '';
  for (i = 0; i < ch.length; i++) {
    c = ch.charAt(i);
    if (c == '(') parent++;
    if (c == ')') parent--;
    if (c == '{') accolade++;
    if (c == '}') {
      accolade--;
    }
    if ("aabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".lastIndexOf(c) > 0) motcle = motcle + c;
    else {
      if (motcle.length > 0) alert(motcle);
      motcle = '';
    }
    if (c == '\n') {
      ligne++;
      if (current == '') c = '';
      else c = '\n';
    }

    if ((c.charAt(c.length - 1) == ";") && (parent + accolade == 0)) {
      current = current + c + '\n';
      //				alert(current);
      instructions[nbinstructions] = current;
      nbinstructions++;
      current = '';
    } else {
      current = current + c;
    }
  }
  instructions[nbinstructions] = current;
  return instructions;
}

var Inspector_flag = false;
var Variables_a_inspecter = '';
var contenu_memoire = '';

function Inspector_on(ch) {
  Inspector_flag = true;
  Variables_a_inspecter = ch;
}

function Inspector_off() {
  Inspector_flag = false;
}

function Inspection() {
  alert('Execution crace\n--------------------------\n' + contenu_memoire);
}

function Inspecte(variables, obj) {
  var toutesvariables_du_stop = variables.split(',');
  var afficher_du_stop = '';
  var i_du_stop;
  var valeur_du_stop = '';
  for (i_du_stop = 0; i_du_stop < toutesvariables_du_stop.length; i_du_stop++) {
    try {
      valeur_du_stop = globaleval('obj.' + toutesvariables_du_stop[i_du_stop]);
      //valeur_du_stop=eval(toutesvariables_du_stop[i_du_stop]);
    } catch (e) {
      valeur_du_stop = '?';
    } finally {}
    if ('++undefined'.lastIndexOf(valeur_du_stop) > 0) valeur_du_stop = '?';
    afficher_du_stop = afficher_du_stop + toutesvariables_du_stop[i_du_stop] + '=' + valeur_du_stop + '\t';
  }
  contenu_memoire += afficher_du_stop + '\n';
}

function find_reverse(ch,i,car) {
	while ((i>0) && (ch[i] != car)) i--;
	return i;
}

function Evaluer() {
  //		resetVariables();
  // Effacer l'écran
  Initialiser();
  BeginningEvent=true;
  contenu_memoire = '';
  Variables_a_inspecter = GEBID('builtin_inspector').value;

  // Pour CodeMirror
  GEBID('lecode').value = editor.getValue();
  // Fin
  var tabcode = GEBID('lecode').value;
  // début sauvegarde automatique des 10 dernières exécutions
  for(var i=8; i>=0; i--) {
  	if (FileExists('Sauvegardes/save'+i+'.js')) {
  		writeFile('Sauvegardes/save'+(i+1)+'.js',readFile('Sauvegardes/save'+i+'.js'));
  	}
  }
  writeFile('Sauvegardes/save0.js',tabcode);  
  // Fin
  
  if (Variables_a_inspecter != '') {
    var ch = tabcode;
    tabcode = '';
    var nbparenthesis = 0;
    var toutesvariables_du_stop = Variables_a_inspecter.split(',');
    var afficher_du_stop = '';
    var i_du_stop;
    var valeur_du_stop = '';
    contenu_memoire += afficher_du_stop + '\n';
    try {
      valeur_du_stop = globaleval('window.' + toutesvariables_du_stop[i_du_stop]);
    } catch (e) {
      valeur_du_stop = '?';
    } finally {}
    var k=1;
    for (var i = 0; i < ch.length; i++) {
      if ((ch.charAt(i) == ';') && (nbparenthesis == 0)) {
        tabcode += ';'; revi=find_reverse(ch,i,'\n'); if ((i-revi)>20) chaineaaffichermem=ch.substr(revi+1,10)+''+ ch.substr(i-10,10); else chaineaaffichermem=ch.substring(revi+1,i); tabcode+='contenu_memoire+="'+(k++)+') ['+chaineaaffichermem+'] => ";';
        for (i_du_stop = 0; i_du_stop < toutesvariables_du_stop.length; i_du_stop++) {
          tabcode += 'try {contenu_memoire+="' + toutesvariables_du_stop[i_du_stop] + '="+((typeof(eval("' + toutesvariables_du_stop[i_du_stop] + '")) == "string")?"\'"+eval("' + toutesvariables_du_stop[i_du_stop] + '")+"\'":eval("' + toutesvariables_du_stop[i_du_stop] + '")) +", ";} catch (e) {contenu_memoire+="' + toutesvariables_du_stop[i_du_stop] + '=undefined, ";} finally {}; ';
        }
        tabcode += 'contenu_memoire+="\\n"; ';
      } else tabcode += ch.charAt(i);
      if (ch.charAt(i) == '(') {
        nbparenthesis++;
      }
      if (ch.charAt(i) == ')') {
        nbparenthesis--;
      }
    }
  }
  //		alert(tabcode);
  //		builtin_code=tabcode.value.split("\n");
  if (builtin_allvariables == '') {
    // si premi&egrave;re ex&eacute;cution m&eacute;moirise les variables de base
    var ch = '|';
	var p;
    for (p in window) {
      var letype = ""
      try {
        letype = typeof(eval('window.' + p));
      } catch (e) {
        letype = "NONE";
      } finally {}
      //  Ecrire(p + ' -> ' + letype);
      if ((letype == "string") || (letype == "boolean") || (letype == "number")) {
        ch = ch + p + '|';
      }
    }
    builtin_allvariables = ch;
  } else {
    // sinon efface les variables cr&eacute;&eacute;es par la pr&eacute;c&eacute;dente ex&eacute;cution
    var supprimees = "";
    var p;
    for (p in window) {
      var letype = ""
      try {
        letype = typeof(eval('window["' + p+'"]'));
      } catch (e) {
        letype = "NONE";
      } finally {}
      //  Ecrire(p + ' -> ' + letype);
      if ((letype == "string") || (letype == "boolean") || (letype == "number")) {
        if (builtin_allvariables.indexOf('|' + p + '|') < 0) {
          //eval('window.' + p + '= "undefined";');
          Ecrire("Suppression de ("+p+")");
          eval('delete window["' + p + '"];');
          //supprimees+=p+'\n';
        }
      }
    }

  }


  //globaleval(GEBID('builtin_codejs').value);
  builtin_courant = '';
  GEBID('sortie').value = builtin_courant;
  var submemory=[];
  with (submemory) globaleval(tabcode);

  if (Variables_a_inspecter != '') {
    Inspection();
  }

  //alert('VAR\n'+supprimees);
}

function Evaluer_debug() {
  Initialiser();
  BeginningEvent=true;
  contenu_memoire = '';

  // Pour CodeMirror
  document.getElementById('lecode').value = editor.getValue();
  // Fin
  var tabcode = GEBID('lecode').value;
  
  builtin_courant = '';
  document.getElementById('sortie').value = builtin_courant;
  globaleval(tabcode);
}

function Executer(ligne, temporisation) {
  if (ligne < builtin_code.length) {
    lecode = "";
    flag = false;
    for (i = 0; i < builtin_code.length; i++) {
      if (flag) lecode = lecode + '';
      flag = true;
      if (i == ligne) symbole = ">>>> ";
      else symbole = "";
      lecode = lecode + symbole + builtin_code[i];
    }
    document.getElementById('lecode').value = lecode;
    try {
      globaleval(builtin_code[ligne]);
    } catch (err) {
      alert("Error of type : " + err.message);
    } finally {
      setTimeout('Executer(' + (ligne + 1) + ',' + temporisation + ')', temporisation);
    }
  } else {
    lecode = "";
    flag = false;
    for (i = 0; i < builtin_code.length; i++) {
      if (flag) lecode = lecode;
      flag = true;
      lecode = lecode + builtin_code[i];
    }
    document.getElementById('lecode').value = lecode;
  }
}

function Afficher(ch) {
  builtin_courant = builtin_courant + ch + "\n";
  document.getElementById('sortie').value = builtin_courant;
}

function EffacerEcran() {
  builtin_courant = "";
  GEBID('sortie').value = builtin_courant;
}


function Ecrire(ch) {
  builtin_courant = builtin_courant + ch + "\n";
  document.getElementById('sortie').value = builtin_courant;
}

function Afficher_srl(ch) {
  builtin_courant = builtin_courant + ch;
  document.getElementById('sortie').value = builtin_courant;
}

var enablePrettyPrompt=false;

function setPrettyPrompt() {
	enablePrettyPrompt=true;
}

function unsetPrettyPrompt() {
	enablePrettyPrompt=false;
}

function myPrompt(message) {
  window.builtin_nbprompt++; 
  var r=0;
  if (enablePrettyPrompt && typeof(window.showModalDialog)=='function' && (window.builtin_nbprompt<11)
  && (! (navigator.userAgent.indexOf('Android')>0))
  && (! (navigator.userAgent.indexOf('KHTML')>0))) {
    message=message.replace(/\n/g,'<br/>');
  	r = window.showModalDialog('data:text/html;base64,PGh0bWw+PGhlYWQ+PG1ldGEgY2hhcnNldD0iVVRGLTgiPjx0aXRsZT5GZW4mZWNpcmM7dHJlIGRlIHNhaXNpZSBBbGdvU2NyaXB0PC90aXRsZT48L2hlYWQ+Cjxib2R5IHN0eWxlPSJ3aWR0aDogMTAwJTsgaGVpZ2h0OiBhdXRvOiBtYXJnaW46IGF1dG87IHRleHQtYWxpZ246IGNlbnRlcjsgb3ZlcmZsb3cteDogaGlkZGVuOyBvdmVyZmxvdy15OiBhdXRvOyBiYWNrZ3JvdW5kLWNvbG9yOiBvcmFuZ2U7IGNvbG9yOiBibGFjazsiIG9ubG9hZD0iZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbycpLmZvY3VzKCk7IiBvbnVubG9hZD0id2luZG93LnJldHVyblZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbycpLnZhbHVlOyI+CjxkaXYgc3R5bGU9InBvc2l0aW9uOiBmaXhlZDsgdG9wOjBweDsgbGVmdDogMHB4OyBoZWlnaHQ6IDcwJTsgd2lkdGg6IDEwMCU7IHRleHQtYWxpZ246IGNlbnRlcjsgbWFyZ2luOiBhdXRvOyI+CjxzY3JpcHQ+CndpbmRvdy5yZXNpemVUbygzMDAsMjUwKTsKZG9jdW1lbnQud3JpdGUod2luZG93LmRpYWxvZ0FyZ3VtZW50cyk7Cjwvc2NyaXB0Pgo8YnIvPgo8YnIvPgo8L2Rpdj4KPGRpdiBzdHlsZT0icG9zaXRpb246IGZpeGVkOyBib3R0b206IDBweDsgIGhlaWdodDogNjBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+CjxpbnB1dCBzdHlsZT0iZm9udC1mYW1pbHk6IGhlbHZldGljYSwgc2Fucy1zZXJpZiwgYXJpYWw7IGZvbnQtc2l6ZTogMS41ZW07IHdpZHRoOiA5MCU7IGhlaWdodDogNDBweDsiIGlkPSJmb28iIHR5cGU9InRleHQiIHZhbHVlPSIiIG9uY2hhbmdlPSJ3aW5kb3cucmV0dXJuVmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9vJykudmFsdWU7IHdpbmRvdy5jbG9zZSgpOyI+PGJyLz4KPGlucHV0IHR5cGU9ImJ1dHRvbiIgdmFsdWU9Ik9LIiBvbmNsaWNrPSJ3aW5kb3cucmV0dXJuVmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9vJykudmFsdWU7IHdpbmRvdy5jbG9zZSgpOyI+CjwvZGl2Pgo8L2JvZHk+CjwvaHRtbD4=', message, 'dialogwidth:50px; dialogLeft:'+Math.floor(window.innerWidth/2-150)+'px; dialogtop:'+Math.floor(window.innerHeight/2-125)+'px; dialogheight:50px; resizable:yes; status:no;');
  } else {
    r = prompt(message);
  }
  return r;
}

// the previous trick does not work with several navigators or media

if (navigator.userAgent.indexOf('KHTML') >0) unsetPrettyPrompt();
if (navigator.userAgent.indexOf('Android') >0) unsetPrettyPrompt();

function SaisieEntier() {
  var i;
  var test;
  var nb;
  var ch;
  do {
    if (SaisieEntier.arguments.length > 0) ch = SaisieEntier.arguments[0] + '\n';
    else ch = '';
    nb = myPrompt(ch+'\nPlease enter an Integer');
    test = true;
    for (i = 0; i < nb.length; i++)
    test = test && ("0-0123456789".lastIndexOf(nb.charAt(i)) > 0);
  } while (!test);
  return nb * 1;
}

function SaisieReel() {
  var i;
  var test;
  var nbpoint;
  var nb;
  var ch;
  do {
    if (SaisieReel.arguments.length > 0) ch = SaisieReel.arguments[0] + '\n';
    else ch = '';
    nb = myPrompt(ch+'\nPlease enter a Real');
    test = true;
    nbpoint = 0;
/*			for (i=0; i<nb.length; i++) {
				test=test && ("0-.0123456789".lastIndexOf(nb.charAt(i)) > 0);
				if (nb.charAt(i) == '.') nbpoint++;
			}
			test=test && (nbpoint < 2);
*/
  } while (!test);
  return nb * 1;
}

function SaisieChaine() {
  var ch;
  if (SaisieChaine.arguments.length > 0) ch = SaisieChaine.arguments[0] + '\n';
  else ch = '';
  return myPrompt(ch+'\nPlease enter a String');
}

function Saisie() {
  var ch;
  if (Saisie.arguments.length > 0) ch = Saisie.arguments[0] + '\n';
  else ch = '';
  return myPrompt(ch+'\nPlease enter a String');
}

function enReel(nb) {
  return 1 * nb;
}

function enEntier(nb) {
  return 1 * nb;

}

function enChaine(nb) {
  return nb + '';
}

function Stop() {
  alert('Break point');
}

function Stop(variables) {
  var toutesvariables_du_stop = variables.split(',');
  var afficher_du_stop = 'Break point\n';
  var i_du_stop;
  var valeur_du_stop = '';
  for (i_du_stop = 0; i_du_stop < toutesvariables_du_stop.length; i_du_stop++) {
    try {
      valeur_du_stop = globaleval('window.' + toutesvariables_du_stop[i_du_stop]);
    } catch (e) {
      valeur_du_stop = '?';
    } finally {}
    if ('++undefined'.lastIndexOf(valeur_du_stop) > 0) valeur_du_stop = '?';
    afficher_du_stop = afficher_du_stop + toutesvariables_du_stop[i_du_stop] + '=' + valeur_du_stop + '\n';
  }
  alert(afficher_du_stop);
}

function builtin_waitOn() {
  this.builtin_wait = true;
  setTimeout('builtin_waitOff()', 500);
}

function builtin_waitOff() {
  this.builtin_wait = false;
}

function Help() {
  GEBID('Aide').style.visibility = 'visible';
  // setTimeout("GEBID('Aide').style.visibility='hidden';",10000);
}

var builtin_fg = false;

function FenetreGraphique() {
  if (builtin_fg) {
    CacheGraphique();
    GEBID('bouton_fg').style.backgroundColor = 'rgb(230,230,230)';
    GEBID('bouton_fg').style.color = 'black';
    builtin_fg = false;
  } else {
    AfficheGraphique();
    GEBID('bouton_fg').style.backgroundColor = 'red';
    GEBID('bouton_fg').style.color = 'black';
    builtin_fg = true;
  }
}

// Tutoriel
var positionTUTOX = 0;
var positionTUTOY = 0;

function MoveTuto(x, y) {
  positionTUTOX = x;
  positionTUTOY = y;
  GEBID('divtuto').style.left = x + 'px';
  GEBID('divtuto').style.top = y + 'px';
}

function Deplacement(debut, fin, t, nbsteps) {
  return fin * t / nbsteps + debut * (1 - t / nbsteps);
}

function rgb(r, v, b) {
  return 'rgb(' + (r >> 0) + ',' + (v >> 0) + ',' + (b >> 0) + ')';
}

function rgba(r, v, b, a) {
  return 'rgba(' + (r >> 0) + ',' + (v >> 0) + ',' + (b >> 0) + ',' + a+ ')';
}

function MonInnerHTML(b, ch) {
  b.innerHTML = ch;
}

function MonInnerHTML_value(b, ch) {
  b.value = ch;
}

function HTMLoutput(ch) {
  //MonInnerHTML(GEBID('frameweboutput').contentDocument,ch);
  var maframe = GEBID('frameweboutput').contentDocument
  maframe.open();
  maframe.writeln(ch);
  maframe.close();
}


// Processing like functions
var mouseX=0,mouseY=0,clearTimeoutEvent=0,FrameRate=1000;

window.onmousemove=function(e) {
  mouseX=e.layerX*(maxviewport_x - minviewport_x)/size_canvas_x+minviewport_x; 
  mouseY=e.layerY*(maxviewport_y - minviewport_y)/size_canvas_y+minviewport_y;
};

function setup() {}

function draw() {
  //Initialiser();
  //RectanglePlein(mouseX,mouseY,10,10,'red');
}

function MouseClick(x,y) {
//  Texte(x,y,'Bonjour','black');
//  Texte(mouseX,mouseY,'rien','blue');
}


var BeginningEvent=true;
var BeginningTime;
function Loop(ms) {
  if (typeof(clearTimeoutEvent) != 'undefined') clearTimeout(clearTimeoutEvent);
  if (BeginningEvent) {setup(); BeginningTime=new Date(); BeginningEvent=false;}
  
  draw();
  
  if (ms>0) {
    var time=new Date();
    var ecoule=(time.getSeconds()-BeginningTime.getSeconds())*1000+(time.getMilliseconds()-BeginningTime.getMilliseconds());
  } else {ecoule=ms-1;}
  if (ecoule<ms) {clearTimeoutEvent=setTimeout('Loop('+ms+')',1000/FrameRate);} else BeginningEvent=true; 
}



var fenetre_courante;
var builtin_fenetregraphique = 2;

function getTransformProperty(element) {
    var properties = [
        'transform',
        'WebkitTransform',
        'msTransform',
        'MozTransform',
        'OTransform'
    ];
    var p;
    while (p = properties.shift()) {
        if (typeof element.style[p] != 'undefined') {
            return p;
        }
    }
    return false;
}

function RetailleFenetre(fen,viz,zindex,echelleX,echelleY) {
	var leselect = GEBID('titre_onglet');
	if (leselect) {
	var tr=getTransformProperty(GEBID(leselect.options[fen].value));
	if (tr) {
		GEBID(leselect.options[fen].value).style.visibility = viz;
		GEBID(leselect.options[fen].value).style.zIndex = zindex;
		GEBID(leselect.options[fen].value).style[tr] = 'scaleX('+echelleX+') scaleY('+echelleY+')';
	}
	}
}

function MontreFenetre(nb) {
  var leselect = GEBID('titre_onglet');
  if (leselect) {
  if ((fenetre_courante + nb >= 0) && (fenetre_courante + nb < Taille(leselect.options))) {
    GEBID(leselect.options[fenetre_courante].value).style.visibility = 'hidden';
//    GEBID(leselect.options[fenetre_courante].value).style.display = 'none';
    GEBID(leselect.options[fenetre_courante].value).style.zIndex = -1;
    if (leselect.options[fenetre_courante].value == 'lecode') {
    	// Même traitement pour l'éditeur
	    editor.getTextArea().style.visibility = 'hidden';
    	editor.getTextArea().style.zIndex = -1;
    }
    
    
    if (fenetre_courante == leselect.selectedIndex) {
      fenetre_courante += nb;
      leselect.selectedIndex = fenetre_courante;
    } else
    fenetre_courante = leselect.selectedIndex;
    GEBID(leselect.options[fenetre_courante].value).style.visibility = 'visible';
//	if (fenetre_courante == 3) GEBID('MonTexte').focus();
	if (leselect.value == 'GestionFichiers') UpdateFS();

	if (builtin_verrou >=0) {
		if (builtin_verrou == fenetre_courante) {
			RetailleFenetre(builtin_verrou,'visible',100,1,1);		
		} else {
			RetailleFenetre(builtin_verrou,'visible',200,0.5,1);		
		}
	}

    if (leselect.value == 'lecode') {
    	// Même traitement pour l'éditeur
	    editor.getTextArea().style.visibility = 'visible';
    	editor.getTextArea().style.zIndex = 101;
    }

    GEBID(leselect.options[fenetre_courante].value).style.zIndex = 100;
    window.scrollTo(0, 1);
  }
  }
}

function TailleBoite(b, x, y) {
if (b) {
  b.style.width = x + 'px';
  if (y != 'auto') b.style.height = y + 'px'; else b.style.height = y;
  }
}

function AdapterTaille(x, y) {
  TailleBoite(GEBID('sortie'), x, y - 30);
  TailleBoite(GEBID('lecode'), x, 'auto');
  TailleBoite(editor.getTextArea(), x, 'auto');
  TailleBoite(GEBID('credits'), x, 'auto');
  TailleBoite(GEBID('GestionFichiers'), x, 'auto');
  TailleBoite(GEBID('resizecode'), x, y - 30);

  editor.getWrapperElement().style.position = 'absolute';
  editor.getWrapperElement().style.width = x + 'px';
  editor.getWrapperElement().style.height = (y - 30) + 'px';

  TailleBoite(GEBID('Aide'), x, y - 30);
  TailleBoite(GEBID('divtuto'), x, y - 30);
  TailleBoite(GEBID('mycanvas'), x, y - 30);
  size_canvas_x = x;
  size_canvas_y = y - 30;
  GEBID('mycanvas').width = x;
  GEBID('mycanvas').height = (y - 30);
  TailleBoite(GEBID('SaisieTexte'), x, 'auto');
  TailleBoite(GEBID('MonTexte'), x, y - 30);
  TailleBoite(GEBID('weboutput'), x, y-30);
  if (x <= 419) {
    TailleBoite(GEBID('boutons'), x, 61);
    editor.getWrapperElement().style.top = '60px';
    GEBID('sortie').style.top = '60px';
    GEBID('GestionFichiers').style.top = '60px';
    GEBID('lecode').style.top = '60px';
	editor.getTextArea().style.top = '60px';
    GEBID('Aide').style.top = '60px';
    GEBID('credits').style.top = '60px';
    GEBID('divtuto').style.top = '60px';
    GEBID('mycanvas').style.top = '60px';
    GEBID('SaisieTexte').style.top = '60px';
    GEBID('weboutput').style.top = '60px';
  } else {
    TailleBoite(GEBID('boutons'), x, 31);
    editor.getWrapperElement().style.top = '30px';
    GEBID('sortie').style.top = '30px';
    GEBID('lecode').style.top = '30px';
	editor.getTextArea().style.top = '30px';
    GEBID('GestionFichiers').style.top = '30px';
    GEBID('Aide').style.top = '30px';
    GEBID('credits').style.top = '30px';
    GEBID('divtuto').style.top = '30px';
    GEBID('mycanvas').style.top = '30px';
    GEBID('SaisieTexte').style.top = '30px';
    GEBID('weboutput').style.top = '30px';
  }

}

function AdapterTaille2(x, y) {
  TailleBoite(GEBID('sortie'), x, y);
  TailleBoite(GEBID('mycanvas'), x, y);
  size_canvas_x = x;
  size_canvas_y = y;
  GEBID('mycanvas').width = x;
  GEBID('mycanvas').height = y;
}



function InitImages() {
	GEBID('MemExec').src=GEBID('icoExec').src;
	GEBID('MemIndent').src=GEBID('icoIndent').src;
	GEBID('MemResize').src=GEBID('icoResize').src;
	GEBID('MemSave').src=GEBID('icoSave').src;
	GEBID('MemLoad').src=GEBID('icoLoad').src;
	}

// Un début pour un bel affichage de la liste des fichiers.

function FS(_name) {
  this.name = _name;
  this.content = new Array();

  this.CreateFS=function (tab) {
    var MonFS = [];
    for (var i = 0; i < tab.length; i++) {
      var p = tab[i];
      var pos = (' ' + p).indexOf('/');
      if (pos > 0) {
        dirname = p.substr(0, pos - 1);
        basename = p.substr(pos);
        if (MonFS[dirname] == undefined) MonFS[dirname] = [];
        MonFS[dirname].push(basename);
      } else this.content.push(p);
    }
    for (p in MonFS) {
      var f = new FS(p);
      f.CreateFS(MonFS[p]);
      this.content.push(f);
    }
  }

  this.Print=function (dec,dec2) {
    var res = '';
    for (p in this.content) {
      if (typeof(this.content[p]) == 'string') {
        res += dec2 + this.content[p] + '\n';
      } else {
      res+=this.content[p].name+'\n'+this.content[p].Print(dec+'   ',dec2+this.content[p].name+'/');
      }
    }
    return res;
  }
  this.PrintPretty=function (dec,dec2) {
    var res = '';
    for (p in this.content) {
      if (typeof(this.content[p]) == 'string') {
        if (this.content[p].length>0) {res += '<option value="'+dec2 + this.content[p]+'">'+dec+this.content[p]+'</option>\n';}
      } else {
      res+='<optgroup label="'+dec+this.content[p].name+'">\n'+this.content[p].PrintPretty(dec+'&nbsp;&nbsp;',dec2+this.content[p].name+'/')+'</optgroup>';
      }
    }
    return res+'';
  }
}

function UpdateFS() {
	var tab = directory().split('\n').sort();
	var monFS=new FS('/');
	monFS.CreateFS(tab);
	GEBID('internalFS').innerHTML=monFS.PrintPretty('','');
	GEBID('internalFS_standalone').innerHTML=GEBID('internalFS').innerHTML;
	delete monFS;
}


function readExternal(fichier,dest) {
	var fr=new FileReader();
	switch (dest) {
		case 1:
		fr.onload=function (e) {
			editor.setValue(e.target.result); GEBID('lecode').value=editor.getValue();
		}
		break;
		case 2:
		fr.onload=function (e) {
			setEntreetexte(e.target.result);
		}
		break;
		case 3:
		fr.onload=function (e) {
			readAllFS(e.target.result);
		}
		break;
	}
	fr.readAsText(fichier.files[0]);
}

function monbasename(ch,ext) {
	var tab=ch.split('/');
	var res=tab[tab.length-1];
	if (res.lastIndexOf(ext)>0) res=res.substr(0,res.lastIndexOf(ext));
  return res;
}

function readDataToIFS(fichier) {
	var fr=new FileReader();
	fr.onload=function (e) {
		//for (p in fichier.files[0]) Ecrire(p+"="+fichier.files[0][p]);
		writeFile('Data/'+monbasename(fichier.files[0].name,''),e.target.result);
	}
	fr.readAsDataURL(fichier.files[0]);
}

function fonctionerreur(e,f,l) {
	if (((l-evalligne)>0) && ((l-evalligne)<=editor.lineCount())) alert('Erreur ligne '+(l-evalligne)+'\n'+e); else alert('Erreur '+l+'\n'+e);
}




function createStandaloneApp(ch,title,style,files) {
	var res='';
	res+='<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE html\n      PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"\n    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">\n<head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" />\n<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1"/>\n';

for (var i = 0; i < (AllExtensions.length); i++) {
  var enabled = (AllExtensions[i]['ENABLED'][0].search(/yes/i) >= 0);
  if (AllExtensions[i]['ENABLED'][0].search(/ask/i) >= 0) enabled = true; //confirm('Do you want to enable\n' + AllExtensions[i]['TITLE'][0] + ' ?');
  if (enabled) {
    if (typeof(AllExtensions[i]['JSURL']) != 'undefined') {
      for(var j=0; j<AllExtensions[i]['JSURL'].length;j++) res+='<script src="'+AllExtensions[i]['JSURL'][j]+'"></script>\n';
    }
    if (typeof(AllExtensions[i]['CSSURL']) != 'undefined') {
      for(var j=0; j<AllExtensions[i]['CSSURL'].length;j++) res+='<link rel="stylesheet" href="'+AllExtensions[i]['CSSURL'][j]+'" />\n';
    }
  }
}
	
	switch (style) {
	case 1:
	res+='<title>'+title+'</title>'+GEBID("AllScripts").outerHTML+GEBID("AllStyles").outerHTML+'</head><body onload=" Init(); InitGraphic(); AdapterTaille2(window.innerWidth,window.innerHeight); window.onresize=function () {AdapterTaille2(window.innerWidth,window.innerHeight);};GEBID(\'Libraries\').value=UnMaskCode(GEBID(\'Libraries\').value); readAllFS(GEBID(\'Libraries\').value); GEBID(\'SourceCode\').value=UnMaskCode(GEBID(\'SourceCode\').value); setTimeout(function() {window.eval(GEBID(\'SourceCode\').value);}, 10);">';
	res+='<div id="weboutput" style="visibility: hidden; top:0px; left: 0px; width:100%; height: 100%"></div><textarea style="visibility: visible; border:0; top:0px; left: 0px; width: 100%; height: 100%" id="sortie"></textarea><canvas style="visibility: hidden; top:0px; left: 0%; width: 100%; height: 100%" id="mycanvas" width="480" height="300"></canvas>';
	break;
	case 2:
	res+='<title>'+title+'</title>'+GEBID("AllScripts").outerHTML+GEBID("AllStyles").outerHTML+'</head><body onload="Init(); InitGraphic(); AdapterTaille2(Math.floor(window.innerWidth/2),window.innerHeight); window.onresize=function () {AdapterTaille(Math.floor(window.innerWidth/2),window.innerHeight);};GEBID(\'Libraries\').value=UnMaskCode(GEBID(\'Libraries\').value); readAllFS(GEBID(\'Libraries\').value); GEBID(\'SourceCode\').value=UnMaskCode(GEBID(\'SourceCode\').value); setTimeout(function() {window.eval(GEBID(\'SourceCode\').value);}, 10);">';
	res+='<div id="weboutput" style="visibility: hidden; top:0px; left: 0px; width:100%; height: 100%"></div><textarea style="visibility: visible; border:0; top:0px; left: 0px; width: 50%; height: 100%" id="sortie"></textarea><canvas style="visibility: visible; top:0px; left: 50%; width: 50%; height: 100%" id="mycanvas" width="480" height="300"></canvas>';
	break;
	case 3:
	res+='<title>'+title+'</title>'+GEBID("AllScripts").outerHTML+GEBID("AllStyles").outerHTML+'</head><body onload="Init(); InitGraphic(); AdapterTaille2(window.innerWidth,window.innerHeight); window.onresize=function () {AdapterTaille2(window.innerWidth,window.innerHeight);}; GEBID(\'Libraries\').value=UnMaskCode(GEBID(\'Libraries\').value); readAllFS(GEBID(\'Libraries\').value); GEBID(\'SourceCode\').value=UnMaskCode(GEBID(\'SourceCode\').value); setTimeout(function() {window.eval(GEBID(\'SourceCode\').value);}, 10);">';
	res+='<div id="weboutput" style="visibility: hidden; top:0px; left: 0px; width:100%; height: 100%"></div><canvas style="visibility: visible; top:0px; left: 0px; width: 100%; height: 100%" id="mycanvas" width="480" height="300"></canvas><textarea style="visibility: hidden; border:0; top:0px; left: 0px; width: 100%; height: 100%" id="sortie"></textarea>';
	break;
	case 4:
	res+='<title>'+title+'</title>'+GEBID("AllScripts").outerHTML+GEBID("AllStyles").outerHTML+'</head><body onload="Init(); InitGraphic(); AdapterTaille2(window.innerWidth,window.innerHeight); window.onresize=function () {AdapterTaille2(window.innerWidth,window.innerHeight);}; GEBID(\'Libraries\').value=UnMaskCode(GEBID(\'Libraries\').value); readAllFS(GEBID(\'Libraries\').value); GEBID(\'SourceCode\').value=UnMaskCode(GEBID(\'SourceCode\').value);  setTimeout(function() {window.eval(GEBID(\'SourceCode\').value);}, 10);">\n';
	res+='<div id="weboutput" style="visibility: visible; position: absolute; background-color: white; top:0px; left: 0px; width:100%; height: 100%"></div><canvas style="visibility: hidden; top:0px; left: 0%; width: 100%; height: 100%" id="mycanvas" width="480" height="300"></canvas><textarea style="visibility: hidden; border:0; top:0px; left: 0px; width: 100%; height: 100%" id="sortie"></textarea>';
	break;
	}
	
	res+='<textarea id="Libraries" style="display: none">\n';
	var code='';
	flag=false;
	for(var i=0; i<Taille(files);i++) {
		if (flag) res+='--------------------\n';
		flag=true;
		code+=files[i]+'\n';
		code+='--------------------\n';
		code+=readFile(files[i])+'\n';
	}
	res+=MaskCode(code);
	res+='</textarea>';
	ch="\n\nwindow.document.getElementsByTagName('div')[0].id= 'weboutput';\n"+ch;
	res+='<textarea id="SourceCode" style="display: none">'+MaskCode(ch)+'</textarea></body></html>';
	return res;
}

function createLibraryApp(ch,title,style,files) {
	var res='';
	flag=false;
	for(var i=0; i<Taille(files);i++) {
		if (flag) res+='--------------------\n';
		flag=true;
		res+=files[i]+'\n';
		res+='--------------------\n';
		res+=readFile(files[i])+'\n';
	}
		
	if (flag) res+='--------------------\n';
	res+='Executable.js\n';
	res+='--------------------\n';
	res+=ch+'\n';
	return res;
}


// Gestion des assertions
function GEBID(e) {
	var res;
	try {
		res=document.getElementById(e);
	} catch (error) {
		Ecrire("Affichage = "+e);
	}
	return res;
}


function EcrireAssert(ch) {
	console.log(ch);
}

function Assert(condition, description) {
	if (condition) description='PASS:'+description; else description='FAIL:'+description;
	EcrireAssert('WARNING ON ASSERT: '+description);
}


function EncodeWithCesar(ch,cle) {
	var res='';
	for(var i=0; i<Longueur(ch); i++) {
		if ( (Caractere_vers_Ascii(ch[i]) < 122) && (Caractere_vers_Ascii(ch[i])>= 32))
			res+=Ascii_vers_Caractere(32+ ((Caractere_vers_Ascii(ch[i])-32) + cle) % 90);
		else res+=ch[i];
	}
	return res;
}

function DecodeWithCesar(ch,cle) {
	return EncodeWithCesar(ch,90-cle);
}

function MaskCode(ch) {
	return EncodeWithCesar(ch,29);
}

function UnMaskCode(ch) {
	return DecodeWithCesar(ch,29);
}

// AlgoScript English version

var getString=Saisie;
var getInt=SaisieEntier;
var getReal=SaisieReel;

var toInt=enEntier;
var toReal=enReel;
var toString=enChaine;

var Write=Ecrire;
var Print=Afficher_srl;
var Write=Ecrire;

var ClearScreen=EffacerEcran;

var InitializeGraphics=Initialiser;

var Turtle_go=Avancer;
var Turtle_right=Droite;
var Turtle_left=Gauche;
var Turtle_up=Lever;
var Turtle_down=Baisser;
var Turtle_move=Deplacer;
var Turtle_color=Couleur;

var Line=Ligne;
var FilledRectangle=RectanglePlein;
var Circle=Cercle;
var FilledCircle=CerclePlein;
var FilledEllipse=EllipsePlein;
var Text=Texte;

var LinearGradient=GradientLineaire;
var Length=Longueur;
var Substr=SousChaine;
var Search=PositionDans;
var toAscii=Caractere_vers_Ascii;
var fromAscii=Ascii_vers_Caractere;
var Uppercase=Majuscule;

var Size=Taille;
var PrintTable=AfficherTableau;
var DrawTable=AfficherCourbe;
var InitTable=InitialiserTableau;
var ConcatTable=ConcateneTableaux;
var CombineTableByRow=CombineTableauxL;
var CombineTableByColumn=CombineTableauxC;
var Reverse=Renverser;
var SortNumericalOrder=OrdreNumerique;
var SortLexicographicOrder=OrdreLexicographique;
var SubTable=SousTableau;

var LoadAudio=ChargerSon;
var CreateAudio=CreerSon;
var ImportAudio=ImportSon;

var SaveAudio=SauverSon;
var ExportAudio=ExportSon;

var Random=Hasard;

var ExecutionTime=chronometre;

var getTextEntry=getEntreetexte;
var setTextEntry=setEntreetexte;
//       -->

    </script>
    <style type="text/css" id="AllStyles">
    body {
    	font-size: 1em;
    	width: 480px;
    	height: 320px;
		overflow: hidden;
    }
    
    #sortie, #lecode, #mycanvas, #SaisieTexte, #weboutput, #Aide, #divtuto, #credits, #GestionFichiers {
		-ms-transition: -ms-transform 1s ease;
		-moz-transition: -moz-transform 1s ease;
		-webkit-transition: -webkit-transform 1s ease;
		-o-transition: -o-transform 1s ease;
		transition: transform 1s ease;
    	transform-origin: bottom right;
		-ms-transform-origin: bottom right;
		-moz-transform-origin: bottom right;
		-webkit-transform-origin: bottom right;
		-o-transform-origin: bottom right;
    }
    
    
	#sortie {
		position: absolute;
		top: 30px;
		left:0px;
		width: 480px;
		height: 300px;
		background-color: black;
		color: rgb(100,255,100);
		font-weight: bold;
		font-family: Monospace, system;
		overflow: auto;
	}
	#lecode {
		position: absolute;
		overflow: auto;
		top: 30px;
		left:0px;
		font-family: Monospace, system;
		width: 480px;
		height: 600px;
		background-color: rgb(220,220,220);
		color: black;
		font-size: 0.8em;
	}
	#mycanvas {
		position: absolute;
		border: 1px solid;
		border-color: black;
		top: 30px;
		left: 0px;
		width: 480px;
		height: 300px;
		background-color: white;
				overflow: hidden;

	}

	#SaisieTexte {
		position: absolute;
		top: 30px;
		left:0px;
		width: 480px;
		height: 300px;
		color: black;
		background-color: rgb(200,200,255);
		visibility: hidden;
		overflow: auto;
z-index:100;
	}


	#Aide {
		position: absolute;
		top: 30px;
		left:0px;
		width: 480px;
		color: black;
		border:1px solid;
		border-color: black;
		background-color: white;
		visibility: hidden;
		overflow: auto;
		font-size: 1em;
		height: auto;

	}
	#Aide dt {
		font-family: Monospace, system;
		color: red;
		font-weight: bold;
	}
	#Aide dd {
		font-family: Arial, helvetica, sans serif;
		color: black;
		font-style: italic;
	}
	
	#bouton_fg {
		background-color: rgb(230,230,230);
		color: black;
	}



#titre_onglet {
	color: black;
	font-size: 1em;
	font-family: helvetica, arial, sans-serif;
	border: none;
	font-style: italic;
	font-weight: bold;
	width: 120px;
}

#boutons table {
	width: 100%; 
	padding: 0; margin: 0;
}

#boutons td {
	padding: 0; margin: 0;
}

#boutons {
	width: 480px;
	height: 31px;
	z-index: 2000;
	position: fixed;
	top: 0px;
	left: 0px;
		background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAeCAIAAABi9+OQAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3AwQFDYbJJefXwAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAN0lEQVQI103MyQ3AMAACQe+4/4aS5vLwoSAeaEGM530piaYamEjlqNo7kpmblze4P6sdh/228gEumQLy/g1NKAAAAABJRU5ErkJggg==);
	margin: 0; padding: 0;
}

#boutons tr {
	padding: 0; margin: 0;
}

#boutons input, #boutons select, #boutons option  {
	padding: 0; 
	margin: 0;
	border: 0;
	height: 25px;
	color: black;
	font-family: helvetica, arial, sans-serif;
	background-color: rgb(200,200,200);
		background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAeCAIAAABi9+OQAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3AwQFDYbJJefXwAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAN0lEQVQI103MyQ3AMAACQe+4/4aS5vLwoSAeaEGM530piaYamEjlqNo7kpmblze4P6sdh/228gEumQLy/g1NKAAAAABJRU5ErkJggg==);
	vertical-align: top;
}


#boutons input.fleche {
	vertical-align: top; width: 40px;
	text-align: center;
	line-height: 1;
	font-size: 1.4em; color: blue; font-weight: bold;
}

#boutons input.fleche:hover {
	text-align: center;
		vertical-align: top;
	background-color: rgb(220,220,220);
}

#boutons img+div {
	position: absolute;
	visibility: hidden;
	-moz-transform: translateX(-20px) translateY(30px);
	-webkit-transform: translateX(-20px) translateY(30px);
	transform: translateX(-20px) translateY(30px);
	display: inline;
}

#boutons input+div,#boutons select+div {
	position: absolute;
	visibility: hidden;
	-ms-transform: translateX(-100px) translateY(30px);
	-o-transform: translateX(-100px) translateY(30px);
	-moz-transform: translateX(-100px) translateY(30px);
	-webkit-transform: translateX(-100px) translateY(30px);
	transform: translateX(-100px) translateY(30px);
	display: inline;
	color: black;
	width: auto;
	text-align: center;
}

#boutons img:hover+div, #boutons input:hover+div, #boutons select:hover+div {
	visibility: visible;
}

#boutons img+div>div, #boutons input+div>div, #boutons select+div>div {
	width: 0px;
	background-color: yellow;
	border-color: black;
	font-family: helvetica, sans-serif, arial;
	font-size: 12px;
	font-style: italic;	
	display: inline;

}

.definition+div {
	z-index:100000;
	position: absolute;
	visibility: hidden;
	-ms-transform: translateX(-100px) translateY(30px);
	-o-transform: translateX(-100px) translateY(30px);
	-moz-transform: translateX(-100px) translateY(30px);
	-webkit-transform: translateX(-100px) translateY(30px);
	transform: translateX(-100px) translateY(30px);
	display: inline;
	color: blue;
	width: auto;
	text-align: center;
}

.definition+div>div {
	width: 0px;
	background-color: yellow;
	border-color: black;
	font-family: helvetica, sans-serif, arial;
	font-size: 12px;
	font-style: italic;	
	display: inline;

}

.definition+div:hover {
	visibility: hidden;
}


#divtuto {
		position: absolute;
		top: 30px;
		left:0px;
		width: 480px;
		color: black;
		visibility: hidden;
		overflow: auto;
	z-index: 30;
	background-color: rgb(220,220,220);	
}

#credits {
		position: absolute;
		top: 30px;
		left:0px;
		width: 480px;
		color: black;
		visibility: hidden;
		overflow: auto;
	z-index: 30;
	background-color: black; color: white;	
	font-family: helvetica, arial, sans-serif;
	
}

#credits h1 {
	color: white;
	font-style: italic;
}

#credits a {
	color: white;
	text-decoration: none;
}

#credits a:hover {
	font-weight: bold;
}

#divtuto input {
	padding: 0; 
	margin: 0;
	border: 0;
	height: 25px;
	color: black;
	font-family: helvetica, arial, sans-serif;
	background-color: rgb(200,200,200);
	vertical-align: top;
}


#divtuto input.fleche {
	vertical-align: top; width: 40px;
	text-align: center;
	line-height: 1px;
	font-size: 1.4em; color: blue; font-weight: bold;
}

#divtuto input.fleche:hover {
	text-align: center;
		vertical-align: top;
	background-color: rgb(220,220,220);
}

.divfullscreen {
	text-align: center;
	vertical-align: middle; 
	text-align: center;
	font-size: 1.4em; color: green; font-weight: bold;
	letter-spacing: -8px;
	font-size: 25px;
}	

.divfullscreen:hover {
	background-color: rgb(220,220,220);
}	

#weboutput {
	padding: 0px;
	position: absolute;
	top:30px;
	left:0px;
	border: none;
	width: 800px;
	height: 100%;
	visibility: hidden;
			overflow: auto;

}

#GestionFichiers {
	background-color: black;
	color: white;
		position: absolute;
		top: 30px;
		left:0px;
		width: 480px;
		color: black;
		visibility: hidden;
		overflow: auto;
	z-index: 30;
	font-family: helvetica, arial, sans-serif;
	}

#GestionFichiers h1 {
	color: white;
	font-style: italic;
}


#frameweboutput {
	position: relative;
	top:0px;
	left:0px;
	border: none;
	background-color: rgb(230,230,230);
	width: 100%;
	height: 100%;
			overflow: auto;

}

.fleche {
	z-index: 2000;
	-ms-transition: all 0.5s ease;
	-o-transition: all 0.5s ease;
	-moz-transition: all 0.5s ease;
	-webkit-transition: all 0.5s ease;
	transition: all 0.5s ease;
}

.fleche:hover {
	transform: scale(1) translateY(0px);
	-webkit-transform: scale(1) translateY(0px);
	-ms-transform: scale(1) translateY(0px);
	-moz-transform: scale(1) translateY(0px);
	-o-transform: scale(1) translateY(0px);
}

#GestionFichiers>div>h1+div {
	-ms-transform-origin: top left;
	-webkit-transform-origin: top left;
	-moz-transform-origin: top left;
	-o-transform-origin: top left;
	transform-origin: top left;

	-ms-transition: -moz-transform 1s ease;
	-moz-transition: -moz-transform 1s ease;
	-webkit-transition: -webkit-transform 1s ease;
	-o-transition: -o-transform 1s ease;
	transition: transform 1s ease;

	-ms-transform: scaleY(1);
	-o-transform: scaleY(1);
	-webkit-transform: scaleY(1);
	transform: scaleY(1);
	-moz-transform: scaleY(1);
	height: auto;
	// display: none;
}



#GestionFichiers>div:hover>h1+div {
	-ms-transform: scaleY(1);
	-moz-transform: scaleY(1);
	-webkit-transform: scaleY(1);
	-o-transform: scaleY(1);
	transform: scaleY(1);
	height: auto;
//	display: inherit;
}

@media (max-width: 0px) {
.fleche:hover {
	transform: scale(1.5) translateY(10px);
	-webkit-transform: scale(1.5) translateY(10px);
	-ms-transform: scale(1.5) translateY(5px);
	-moz-transform: scale(1.5) translateY(5px);
	-o-transform: scale(1.5) translateY(5px);
}

#GestionFichiers>div>h1+div {
	-ms-transform-origin: top left;
	-webkit-transform-origin: top left;
	-moz-transform-origin: top left;
	-o-transform-origin: top left;
	transform-origin: top left;

	-ms-transition: -moz-transform 1s ease;
	-moz-transition: -moz-transform 1s ease;
	-webkit-transition: -webkit-transform 1s ease;
	-o-transition: -o-transform 1s ease;
	transition: transform 1s ease;

	-ms-transform: scaleY(0.2);
	-o-transform: scaleY(0.2);
	-webkit-transform: scaleY(0.2);
	transform: scaleY(0.2);
	-moz-transform: scaleY(0.2);
	height: 50px;
	// display: none;
}



#GestionFichiers>div:hover>h1+div {
	-ms-transform: scaleY(1);
	-moz-transform: scaleY(1);
	-webkit-transform: scaleY(1);
	-o-transform: scaleY(1);
	transform: scaleY(1);
	height: auto;
//	display: inherit;
}
}

#GestionFichiers {
	vertical-align: top;
}

#GestionFichiers .bonglet {
	-ms-transition: background-color 0.5s ease;
	-moz-transition: background-color 0.5s ease;
	-webkit-transition: background-color 0.5s ease;
	-o-transition: background-color 0.5s ease;
	transition: background-color 0.5s ease;
	padding-top: 25px; 
	padding-left: 25px; 
	padding-right: 25px; 
	padding-bottom: 5px; 
	vertical-align: middle;
	font-size: 1.5em;
	background-color: rgb(255,255,255); 
	color: black;
}

    </style>
    <style type="text/css" >

#Aide span+div {
	position: absolute;
	visibility: hidden;
	-ms-transform: translateX(-50px) translateY(20px);
	-o-transform: translateX(-50px) translateY(20px);
	-moz-transform: translateX(-50px) translateY(20px);
	-webkit-transform: translateX(-50px) translateY(20px);
	transform: translateX(-50px) translateY(20px);
	display: inline;
	color: blue;
	border-color: blue;
	border: 1px solid;
	padding: 5px;
	width: auto;
	text-align: left;
	background-color: yellow;
	font-family: helvetica, sans-serif, arial;
	font-size: 12px;
	font-style: italic;	
}

#Aide span:hover+div {
	visibility: visible;
}

#Aide span:hover {
	background-color: rgb(220,220,220);
}

#Aide span+div>div {
	width: auto;
	display: block;

}
    
    </style>
    </head>
    <body onload="Init(); InitGraphic(); GEBID('titre_onglet').selectedIndex=0; var builtin_oldfilename=''; fenetre_courante=0; MontreFenetre(0); AdapterTaille(window.innerWidth,window.innerHeight); window.onresize=function () {AdapterTaille(window.innerWidth,window.innerHeight);}; /*setTimeout('GEBID(\'divtuto\').style.visibility=\'hidden\';',2000);*/ readAllFS(GEBID('Libraries').value); window.onerror=fonctionerreur; GEBID('sortie').value=''; GEBID('MonTexte').value='Votre texte ici'; GEBID('MonTexte').disabled=false; builtin_ong=GEBID('onglet1'); builtin_bong=GEBID('bonglet1'); builtin_oldfilename=''; Dropboxsync=confirm('Do you want to synchronize the internal filesystem with Dropbox ?'); if (Dropboxsync) InitDropbox(); if (MustCreateAlgoScriptConfigflag) MustCreateAlgoScriptConfig();/* InitImages();*/">
        <form name="f" id="f" action="javascript:void(0)" method="post">
	<textarea id="lecode" style="border: 0;">// Javascript code here
</textarea>
	<div id="boutons">
	<table><tr><td style="text-align: left; vertical-align: middle; margin: 0; border: 0; padding: 0;">
	<img id="icoExec" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFn0lEQVR4Xp2Qe4xcZRmHn/c7Z3ZuO9vZW3e73bSFtlto2i5aWRZK0UZbLTXUYEktW4iKQgy6a21qYiAE/wBNiFUk/qd4wVtTQzSYEAxFGosp1mgF6lrpZblIpXSuO9dz+V5nZmcbSBog/nKe8zsn53vPk7y8W4av+7Oz8uP/umHT58/et3Xq3C+2f+P8k5/c99/fbr7rzCOj257+7MC67y3iPWK4RBaNH+1Y+6mXJ1ePLTs1ccfQs7vvHPzm5FTvrfumej6xd6r3pi/cPfTl274y/uiWiYmZ0e1PHewb2bf2fQsWbzyxevHKRX+58dMLH578Uu+yzR+OM3plhKFFDukeQ2+fw4plETasj3HHrgUdd05dv2Ps5j3HBkcfui/Ws8l9V8HAtS9cNzySPrLzMz3rrlkfVYmJVhDK2mjbhCZUtNFAVUSHh13dvSPd8ZGdn7u/c+mtP3NT47FLCrpG/zbSvTj9xLatnd3pXoeSipRCGijNLgZIwW81sxYpWWmdaVIzwg3jMdmwbfuujoU3fVeilzvvEHQsf8pxksnHrt+Q6HHihkIoFAIYTigj8ZB6pUy+FlD0oRg0EQr2bYSGohWuWhtl+fjtd0l8zS3vEEh04PbLRjqvjqaMZn3RXCBk/FBH0q4u6ezgY4OdusJ4WswVNFsJKPmqJR8KoWjOGs2FQmNGCwE62pAkLpt6AGdh+qLATcT2DAw6ZOoiGa9BYMgGIqFFAoVQRZank7J1KCULqkVeeD0r03mf18oqGV8kExoyvpELnkjjYnjFyOUm+aGbAdzIij+t7uqLr6kq+DWIeoLrG2oFH89CREFEQSHmGrYs7WFswOeJMwUOZ1zKksKxDq4v1OtC4EFXj4PTu3mHnX3m565E4hs74kLeA+qiVA1+SeiKaCPMRVFEmX9PRyM6cWUfG/M1/fGJLH/MxAnrMU14Aj5Yg3Z0X/0B/2zQZTBmpa9IwaMpkbfqIrVA8AIEVNoSARFpMf+uDC+IyT3X9su3Pij0a1bOVwLJe1CsqziJwX4k2mewuW4L6lvwVVQFDSx4vqpVVFHmqgE6d2/3/Mf1Q0m+89Eu9UoXtBpALVDFcQ3ipFysV1ZF2v8R2oOh5eKzImIFRGFOIvMLE0XIlqr6g0P/FqQbtL1Qay0ahq76xVdtoBBYaLe1SmBgfjuqXIzOt0LVC/jV0dM8erxIsWMpJhqHoocNFFvLldBKwdjyiWN+TVHPghdC3WI9xQ8F1Sag0Grb7sAqTx4/y8RP/8oPZzqpDFyFcdOIr+CH2Lri5/9xGjTfEDx31Cvk3rQ1C7VQpRoolQDPl/aaQRW1bY6eOscXH3teH3pRyfSPapAaUhs4UAmVagv8imqQ+cMRoGi0dKjuvXnoJ/6sQjkQSr4w62Mbz1ZpWSwiJ9/IyVd/fUy+frjAmdQaCdLLqGpMvJq2zktzrjlTDqlls2Wb//1BwDcAYeZ3+yvnL7wVFkNah4tNQv7+SonXM2Xuffw4ux9/jedZhdc7QpkkpbqDV7ZQ8Bt4UPRbs/WCpXbmkd9gS8cBhHZM966dqXUP/DI5GBHpjkDKxTolrJSQ3n5MKg2uAwqECvUQKgFSDqDotUTehYDiy8+drJ+87RYIXwJwacfOPnuwNL1/BNl7f8KqmMCKSSYwiZRScoW6hxoBUAms4FmlFgpNwayvXi6U2Znp/9RP3f01CKdpR3h7nH7HLNgymVh174OJ/kTMTRkk7ihRR3ANGEBRQhX8lmBu53nV8szhf3qnJ/di888A/qUFAKbTSGTJeGR477djizdtiKYccWKCici8AA0V64FfVmqZc4XazMMHbPbA98GeBELeXyIJoldscQb3/Ch6xYGXEuuP5ZLXTNeTYy9W4uuefiOybP8R03Xjg0h0DOjk/4+4wAJgCbCqzVKgG3B5j/wPFVAowDGOz14AAAAASUVORK5CYII=" alt="&#x2714;: Run" onclick="GEBID('sortie').value='Execution en cours'; Evaluer();"  style="color:green; width:24px; height: 24px;" class="fleche"/><div><div>Execute</div></div>
	<img id="icoIndent" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFsUlEQVR4Xq1VaYwVVRb+TlW9qrd1DzS22DsD3awSbOxhSTDMoD80LkggxgkxmExmEpZB42SAQSXqgE0i9g9+KG6hwz/XSVxiTIuMYRlIBjrQAWdCQpOAo92v19f9qurVdubcevUI/0yMJ/n63q5b733n+86550FFk+CB9nbCLxQ3Ll9GM0BQUV/doPov5gu6BGsEawX3Cx4UPCJ4XLBB8Kh6lpytTd5dIVgkaEQSXUhY6oDZrfn820s6l3fVNzRwzYwZacuyUrpuaLqha4Zh6AJNl5UICPwgCoIgDH0/DAI/CsMw8svlYKpYLI8VhqP/XBoYvDYysmMYuIgkNvXsfZ5LRZvtKZd/Vnge22Oj7I6P8dGD3QzgXSxeVGckBHc2z5mLbE0GZSfgcydOUuHHH+CVHbglG4HnQVKFZAvmCLqmQ5TB0HWYlgUrnUauJo8l99yDho75aGxphkQGxanaKsHMbC4HFZOjI7T/me08MDAAAyAP4ABABJCAIaEBJGAdQCrZ18jnD7z5BgkBm6ZJOcAqTU+ZMYEBZNOZDCRY04g+OnMW4iWmJiZgl0qipIwoDJT3AEeQekDTNeiyZrNZ5PJ5ZHNZpEUJQk/OdMjOKNlOOiZY17Ggftbs2YhC4KUdWzH/7qW085WX0QCAPZ8IXMlTSzqOWYEUGSKWJSSpNKTQQBQRJAggMJPGzO919x7b2DyvHYXhAnzbwcmPPuA9Tz/NY0MFkEbs2DZz6IN9nwPHYfWO59jsuy4HXlmRsQjnSAhjZgL0hMD46+anNgSBN9NKZyLJgkyR/pc//QFff/4FdmxYj4O9vWhta0Xv4cO4cOZfFcu8stjlxxaJ3wILS7uWY8v2bYjFguI6iRrNuHr5Us1rPYfww5UrVBwbpdqaZUgT0UMrV0A/8U/s2byZXjxyBKOibvDqVfI9DwrS+6Q6KZUylUq6Y3Y9wFFFAKFKQIZlWnpdSuei71Iuk2F3cpwK45Ncnp7GqoWLaPrkKe7etQvH+vpo+96/see6quAURZGyBaRrZJkmm5aJsuuqujBJ6IpDYEwXp2igf4CHbw4Bno+yWKCgfDaCAIPjRdR1zoqzI2YAgqTQTACpVSGKgORcyBECEQgwHMn05rVrNHTze56eLFI2lcIM0yRdPP7m/AVoS5fQ7gN/x6Fdu/HtV19VLPLVxROLdB2GmYJGGt27eiV2v7ofIKIw8OEAPlJmqHV0duL4xQEMej4X8nnuv3ETkyMjfPzf5xmLF6Kn9yg33tXAs+6sx5yOedzU1sqNLa1oaGnmxtYWbm5rw6/bK891TQNYNVygCAKk057x1meffth/9vzv5rTPvUNl9tz6x/Dh6dNY/fsnsa/ndcysrYVjl7Bl2zbBVgRhcMsOAkAEKCUMhiu2Aky+KHABXwh8g4ieWNPYdPj1Y8f+fO/qVazX1tDDz+6kfYcOQUXkOpTJZFBpDSIzZdzqlnhVfkcRqay58jyeXawUECIDEqf+9/3w2NAQ9GwW3UfeQCad4evyozE5MU5OqcQyKtSwIxnRnIwKknHAKTOlRgXlcnmunVGLGkkO6kb7PiQCASfDTt1yV2VGjXPn4Y8PPoS+vj5YAMqCUBAlUKElMASmwBOsW/dbvPPx++AggOs6kPCUpCrBhC3dBDkM5HDHC8/Txi1Pqb4W/20KKhcrVgHEnqthRynpOGWflbaoSUZ0FATqOaT1IVFS9t0iGBseBqJQycey+9ZgGen46QgADiHMkLThOQ4iP0RB7I4Jwiisjuv+L//xyXe2XVo0s65O+QpdiklE0DSCTpqsMZTq2GPp9XgN/MoPkdSJZU75o4UR+vb4if8ScJ2LRSYDIJUHgN8INglSibW6QLsNlKzVAobV9ba9I7AFNyQbWyw6R7g9Fsz/FRzXArOOMFZHqL6RtP2t9mQgqTtXwKpfgTBkTE2xyFKEo/8HH2I/LpzikbAAAAAASUVORK5CYII=" alt="&#x21F6;: Indent" onclick="Indente();"  style="color:black; width:24px; height: 24px;" class="fleche"/><div><div>Indent</div></div>
<!--	<img id="icoResize" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABWElEQVR42u2XIUjEYBiGd8KKqO3QbBBMgvWaFoPh8iFr3rXrBsUy1LszLMqJSbQaNC94xQWTTBaGDFaG6Jr183t/dnBjisPd/v/CPnh4+creB/ZvYxoRKaUSmB0BnjWmybRLpomulADPpmmaB2EYPkdRRGWCDnShc1Jgz/f9d/t8QMONdUIGQUCjux7dHq0ixX79cEz7PR2J/d+gC52TAm3XdelpZ4s+d7dFYn+9aRA9NpBiP7lfocuXeST2QqAzJeA4Dn1cDSEgEvuXewEBpNhHb2cQQGIvQlbAtm3yPI/iOBaZYy9CVsCyLJJIVoDkzs8ChmGkmMpkr/u3QEmTTyDJMsoRuQSmKvHLdZUewkqgElAuoPQxnN0XUUfBq7iDwOhMV8HHqJt0a4vMIUkedCbd2gLTYk6ZPjMomX7S1UL3+BYsMXVmWRL1pFMfH8IaMyeZWvVvCL4BhCbDBZfU9WwAAAAASUVORK5CYII=" alt="&#x21F1;&#x21F2;: Resize" onclick="AdapterTaille(window.innerWidth,window.innerHeight); window.scrollTo(0,1);"  style="color:blue; width:24px; height: 24px; letter-spacing: -8px; text-align:center;" class="fleche"/> -->
<!--	
	<input onclick="GEBID('sortie').value='Execution en cours'; Evaluer()"  style="color:green;" value="&#x2714;" type="button" class="fleche" />
	<input onclick="Indente()"  style="color:black;" value="&#x21F6;" type="button" class="fleche" />
	<input type="button" class="fleche" style="color: blue; letter-spacing: -8px; text-align:center;" value="&#x21F1;&#x21F2;" onclick="AdapterTaille(window.innerWidth,window.innerHeight); window.scrollTo(0,1);"/> -->
	<img id="icoSave" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAF9UlEQVR42p2VCUxUVxSGZwbEJUq1riB1qTbWNi6YVsSo0RpAVmURccOtKlJFQTYHGJiRURydUkYKtHFFQKVSt6qoIKssgwi4NDpV0aQCIog4RJHl/D0zEYsUa9o/+XPve3nvO/89980dwfvktnChqPO1sXG/kUKh0Imn622sre/MsLG5NcnKpmnCnG/+4HvT2YaC/yGTCRMmis3Npxx3dHSq8vRcjm3b/HEqLQUH0o7hW1U8bL28YdDDUMXPmnZL8HRfIuyY2zo6jOFh5tChJlJrG5vnHh7ukEjCkJyciCtXziEv7xKKirKoWJ1LN8oK8V20ipbJd2HkxMmV/J7VQLMRvd6X1H34qFH7HR0cGzdu3IiIiBCcPJmK0tJ8PTQnJ53U6jxoNL/TkydVaG5+BZ0yS8vgLNkOiwWurcyIMDQyMvkH2cbe4dIGSQRWyuRITjuO0pJcKi7Opvz8DE6bg8pKDbW1taKTqLGxgV40NuBZ43Ns2hsP+y0B6D90WB7jJgm6KiBUoi2v/BOrFErsSjxMZdeu0oMHGjx7VtcB1BdgKGpra/D0aQ1ptS8Ib3Q0M5ts/YIxznJGvcjAYBUj323TV9MsU7PV16E4dgIroxRoevkSHXr16iUDn1BNzWM0Nb1AW1sbWKSzLkBDQx2q6+rhufP7tmku7jAwNNzHyFGCLlom3x2NCyVlcJPIKCXjCnSqrqnSwfH6dfPbtC0tLaivf6orqFsF2tsJOimPpZHdlkCMnjSlnnn2xoMG93nnU7ScMas8o/g6tv74E/moYkkn3kjqSMsw3txqdhU1NWnf3mfpx4fVNZgfFglLV3cwL7a7VQQnHE7Gz2cuwDksApdLSqmjRdXVjzl1rT59Z+nYnRWy7xAc/EPw8XAzDfOc2UadC4y0W+Dy4krZLSyLjKLIxGQdgKGv0dba2i20Q7crH0KyPxFLpFG0WL4b5nZOYJ6Sbda5gGioiWnSzymp+OHEGbILDkHFvfv0N5fQ1t7+ts6TZw10Or8AS2VRcAyWwGqrmJzEUvLgawffIPTpP6CCmXO7rsJ+g18g0vKKsSg8khQpxwnAO752R0OyQ0m0eqeSZm7yJ6dt4TRfLEVAdCz5yHcRt4g8tu/GWIvprczb0KNX7/6dC/T/crJ5Vsr5DGyNTWj3kMrxoLoaVXX1lF5cQp6RCnIJkdIcnwCy8g0i7z0qikk6ShcuZeLu7Tt0cP9+slrvA5cwOay8tnCbhGf5cBwv6KIgmVKFuJPn9KvwUcWRa5gMtv5icFq4hUqhOn4C6pu3UFdbi4f37iErKxdlpddRVlxEbt4+sA8MhxN7yKdj7+rb1KGE1JNCHoabW0yr+jW7ECvlCnJmoFvYdqzbuQdJZ87ifuUDZGRlY96KNTh46gwK8gv5aLnOVuNGeTmFymSY7bUZ7twmS4/lYJ5C0FV9jT+KjtybAHnisZaFDHcNlZGPMoYT16C5SQvXtV40y9uXvBTRKCpUo5zTX1OrKTcnl9Ivnqc5K9fB+js/jLWcCcOevZIF3Wiy89IV2sQLWfzp7aDFETswLyAUp7OyCQApY2Jortdmsg8Mo8ycfCq/VoLCqwVUUHCVTp8/BasF81v7mZo9Yk4K74FfdwV6mJiNOBpzJBWbo+NaXXkVLqHbaV2Ukpq0WrpZUQEL18Ww3hpKioNJ9EhzF+kXL2OzOASffz21SiAySH/zO3Bnf8ruVt6+4XLsTjpBztvC211CZHAIkiC7qBja5w0k3qWE/w/x9Mu58wjfEYVxX1vwGSTM4fdSRXxUCEUiT54P7Ja8xl8s5GHA6HHj7xz4LRO+qp/aF3GbrP3ECIpNwH2NhvLzCqGI2YsvLKY3CPt9VMjPH2Gr2AFsG/Yngg+pZ6/eay1mz61b7RsISdwBBMcfwgppFDw3+cJynkOLwYCBZQKRKFXAibnXgTzasz9j92ZzyA/LmO3Ejh48zLRi0lTLmkHDTB/3HjTkhkCoB8ext7Bt2SP1fzT/UUKjnj379jAyGvOmkJQdwd7AXsq2Y4/RJ/4X/QX99SaY+5lDRAAAAABJRU5ErkJggg==" alt="Save" onclick="builtin_oldfilename=prompt('Nom du fichier à sauvegarder',builtin_oldfilename); writeFile(builtin_oldfilename,editor.getValue());" style="color:black; width:24px; height: 24px;" class="fleche"/><div><div>Save</div></div>
	<img id="icoLoad" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFY0lEQVRIx5WUS2xcVxnHf9+5594Zj8eTTDPj+NXGKY6V2A7GUtoCxVmQPkAVlkDQbrqoKJAFUiqBWGTDigU7WLCgIBZsKhYQlRQStQVEneIWlFC1KE5wkrp+27HnYc/b9/Gx8ExtJ0jQI13p09G53//7P84RgFuvf30oCkrnkr1fOrtdWUOjAI0iospMUKHXOid+Pn7yqLy9dHvSqa9djkoLl/ASnTI08WbEf1l/u3DWefxrL4cAVlXNzd+ffrdr9AcdblsmdBOuY+MexnWBQbsw9UOuTZ6/oqr9IjK3p48W5v7040rhznhp9Z1GozhDUPy75/Z8dXp04uXvtA7JrTee+24iffJnPae+ofCGgAdEQIBGIOZ5/eAPL0kYO0JP12G262WiRgFDRPxgltiBbuIHuvFS/UCFt375LLOVR175yhNDrx4aOX9BZv/6rVLv6Lmke/AaaKCgrQFBFNWEiP+khrXrYSR+JLYmjmcIg7xWN27bxtaaqRfntLw2jeNlBXssSGQesbn5Sfyuc/+wQWU16R5sU6UsIh4K8jE9BJEaeH+U1Q9esX45AFKqUUI0aqMtfZx4+hSZ4wM8+LnjIC7kJi2HTuuNd3/F3PrMo1bEAgURFVQVMQawgMsOls+tSz+iPfMifZ99EeMoxu0A2oA6UAMaaPgR6niwfBlz6LQU8ysa9fVgnfYB8MugISKGsJSjmp+nWliiVlwmqPm0H36BnlMvAbNNbuuAok2yoiASAiF4KWCBQq1dstlswwb1FajXWbt+mdz8h3jJY7Slh4ilRukcGsVNZHFTKeAqqgYRQRVE2LVLAI0AFzEOjc0bNOhCVX5tVSNqq9PklvIMPfuO7NAuNqmXm1OHqDot83c9ElBtRUIFLIihsTWLbw5TLNUvWe/AAH55nQeOPAPcUeXfIjjNsZrfbs8dZUBo5k1agSNScATHoVa8SZ0sA0cOYdXfpB6UUO8B4K4IVRSzy7xZ7FFkT8r2gKCiGMQ4bG/d0dAMykB/xrGIy3ZllVhqEKirRr6A+biL7N4K9pSyrwBQVXEcIdhifaMgiY4MnZ3ZwMZSAxpVruO1JSGsQBCqcP8Tc4+nuo/KDsCOfEGJXDEUcBatG3/balhlK/cvSR59Cvy6EviiyP6f72GwN0Syu4cggr/JRt5HbOKGiOQtGoao2liyF7ZXIArune3/WtKEICizWQrIfqrHAtjKzZ98GRN/U7QG2xUR3YmJ3i/L/zAZAQP+FoVN4eGefgBs1W8c9OtrODYOvt+kL/u0v1ctuQ9EETGKa6VSrRFKmkwmbQBs6FcCMRYbT2uUL4lx2rT14DXvkewxVlpSgyhiwBgR60F1Q4LCDOur7wdO/IxNpPp+CmBt5gx+8Sr4JfAbSmT3S6JNwYxFjAcYJaoIVPBLa7Kyshguzs0E86vbulI9Gi/oF23fwJnoRL/76sWLF43VqEGsvQsiXyQIFQ1ExOwMakQwDhARlpelvDlHvbzE9GyVD1ddWdtM0LDHnLbMM062/wQZL3ZhOJueeuqJx39z9uy3mZiYiKziYL0k+GUkigliINyEaIt8bpmFxflgcXVDl3JedDcYizXcJ6U91Us82/nPsdOfiXV3d782NtJ3XlWTIlJueXPlyhUZHx9Xm+h+2iP3Go31a7q5+Ge5WyjrzLIjs+sJtoIHsR1P20RmjIcee5iOMPr+8GBfeXj4xJy1zuv7YrqnOcD4+LgC2FSHd3thqYNf/Paq5PwxTPKktLd3LKc/fWT6C8NDtqd/8HsPZeQ9VRUR0U98PwB+N6mPhfm3vmklvPT5Rwdjh7v6/iIiG61DU1NTTiqVikZGRj4xwH8AiTZ+be0Tvg0AAAAASUVORK5CYII=" alt="Load" style="color:black; width:24px; height: 24px;" onclick="editor.setValue(readFile(prompt('Contenu du repertoire\n-----------------------\n'+directory()))); GEBID('lecode').value=editor.getValue();"  class="fleche"/><div><div>Load</div></div>
	<img id="icoLock" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFIElEQVR4XnWWTYhdZx3Gf8//fc+5d27SzCSd6dS2ZmBI8YNWrBWFunBR0k1BFNyo6M7uunAhVgU/QIS6aENBEVFXgq66EFxoJF0FY0JFK01RkoY0M0mbzMzN3Myd+3neRzKXCwHJAw/vjwPP84f/ORxebW5ulsiVpuOhm94tclWLSAZACGQQmrMAJMCzgxkDLo2a8cj5yEMIy7ZzpEqj/i7Nu+d11ANadQtSJUWAEkQSERxYdzmhA44DRpqxhG0Glu7sDMnHjhNCuTEevn1GHx7ccGd5DYb7QphI8+CMJaFk5uWS0Zxj9jyyFg4fcW6GbN9+X+0HH3XuXbvIwqVzdNYeh60NPCuY+YBBuV1IVcKNiASpLjQTDKEIrHlGqHeTI60Ftugz7BwlD3tdVRv/gdVHBAECFNIsZHKlfvdK6u11XRRdKVKWFh9cXSctPGBPjSJkidnwJG5/wN7WZVoPris7ZU92t0Vvy3QWoRSJsEMoZe11r3PtxqWf/e43p189d41RAX/3heOPf+Txz5x6bO0Tz6S6gwEijELULU93txhs76idsnNE0Az60O9BqqE0OAWKVMrUabe/88rHf3T6O7ZbnPnFkywsDfXM1y7Ae5/r/vrh95eOrKxijAJFAIW7X2PTvYVSRQapNFMY7YvpECjzF5cahZfWn3jN/kPy6z+4qMlo3bGJ//jTl/WF771ULR77JdP9H+IooGQlFCH+/QbOq5CysoQJC8bGBwOEwxSpOnS0G0dXe/zpJ0+q6a8z2d+XokPm5Mj+fv3nVy6zswGWIazqkPjvWZd33oFPHRcuziDIYIbIA6AgEihw038gckQp+zDtQ7PXgYBpVdeg0ow6UfZRqjEVXL0AF0/jFkRKAGQJqRJoIhgh2Ti00+01+9Xo7OKH9if9re29Zu/W5TLYvQU6nA5P3nwEytbu9sZo88qtlZWHV9q7G3D5nKksOkAARhnhqCRpMluRkJW4Q/Xi0z+/9Nu3T316cu5qr9/b2f3sfm+n4BKHlsrk61Cu7vT++pVX/7L+zxefep3bV05SI3LLGk6JJBmcEaQKiBFoiCWIzNrnnzuz/e2XRqvXfsWXfvwewDb36BuvCWB014dT9y23dFKpgqlRG5QEhhBSVIDGgpGIMYoxbG8cAmDti9xPPvWxBEB7oVa7gla6a0ULRRZgzVZUS6SpD8oVchhpAgAxEWD+X1AngFnxZP5ztKMVKEkwX1EdEGOQIALFBMcQADTkvmrfM2CacYAmhWgnUiUwZECpBtJYqGAJlICBAWBo7iO3WwC4DmsSiAAh1UEkAShLOFUSdZhK6IATtJcHAHru99xP8dXzDbNVNUwCSICsOkgZAc6SSK0EdYE64VqoTlDe/ZbPPvuyB9dr5WxCYABDY5g2eDy2Vp5d9vULz1FpPgBamagENrlRUtNZhFZPzkCV7MpouvmC1fomdeqSIhECDEUgg7C0gLvnl6QB1FFMkYpFK2jaRwmSstur3qif0KMLb1oVkBB1QO1G1ShRVcdIAQIkaAoUwzRg3KDxqIBAKSSgqrxbjnOzPqET7bbz8vIq/1p6nr9t7/H08T3qhSFU2VQRVIIUJgkCYZliKBZNMblAVYKJTdWYEbrZW+DvgzVWPvk87TxFN25c9/7IvPWPs4xvvEGnDSaQAAHccxoM4HttPGPKtGGvLPLYU1/moyfWcGmYXVtCMuEPtvbY7d3RLCXAAs1rxQxmLFlzngVIOeuh5SUvHa5pmiLb/h8Qv2S8gSe3MQAAAABJRU5ErkJggg==" alt="Lock" style="color:black; background-color: white; width:24px; height: 24px;" onclick="if (builtin_verrou>=0) {RetailleFenetre(builtin_verrou,'hidden',-1,1,1); builtin_verrou=-1; this.style.backgroundColor='white';  MontreFenetre(0);} else {if (fenetre_courante>0) {builtin_verrou=fenetre_courante; this.style.backgroundColor='red';}}"  class="fleche"/><div><div>[Un]-lock the current view</div></div>

	</td>
	<td align="center"><!--<input type="text" value="Code" id="titre_onglet" disabled="disabled"/>-->
	<select id="titre_onglet" onchange="MontreFenetre(0);">
	<option value="lecode">Code JS</option>
	<option value="sortie">Text output</option>
	<option value="mycanvas">Graphic output</option>
	<option value="SaisieTexte">Text input</option>
	<option value="weboutput">HTML output</option>
	<option value="Aide">Memento</option>
	<option value="divtuto">Help</option>
	<option value="credits">Credits</option>
	<option value="GestionFichiers">File manager</option>
	</select><div><div>Fen&ecirc;tre&nbsp;visible</div></div></td>
	<td align="right"><label style="vertical-align: middle; font-style: italic; font-size: 0.7em; font-family: helvetica, sans-serif, arial; color: blue">Inspect&nbsp;<input class="other" type="text" id="builtin_inspector" style="color: blue; background-image: none; background-color: white; width: 80px;" value=""/><div><div>Variables&nbsp;à&nbsp;inspecter</div></div></label>
	<img id="icoLeft" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFbklEQVR4XoWWbWhcxxWGn5k7d+/X7upKkVpJtqQlTeK2ckiM21LSpAqllJi2VIGWkoTAKhBsXNxa6EdJi6FqQKENqdxAmxIokmnaUhOKTNvgxk0V4aqOiymJK5zUkWXVlhTbsqJdaT+k/bi349sLYkkdn+Fh5s993zNnz3BW8GHxND6Cfk2fJhMhAcF8zJRmgiFy3CT+v8FwJDza6rZlv9T1EN2pHnb4HycMQ01AQMi/197mUvESr107wUrl+jiCQQ5+0Eh+UJx+z/QuPtm7L/vcfT/lwc4v4MsWZq9d4N3lWc4v612fk6HPfa0P8PTdz/B4ZiDrKvciz9P/4TcYJtud7hn73u5DGEJxeXWR9Y116mGdAL3CG4REZ8JoeZZLd3MXdao8f+EnLJYXBjjAeOMN4sxviD+lxTcqm5y/Nsvaxhq1sKapUwvqlMpl8qt5CoUiNfQSNVYreWaWz7FeKbL/joNsc7eP8TP6Gw2G8XVZIvFNLX5pdYFKvbIlrvfCegFVknx15x66nU5yKzmq2qAqa5TZ5N38HGvVAnvvOIBjuGP8HH/LQDD66I7HfSUUi/n30CWJCaK9qDNuMXwOP/FjHnngGzzz2A9JKo9yfYOqoU1UBHOFeUIJX9ne7wOjAArdiq1OW/b+js9z4foc1Xo1Eq3FJqVCidtkMyOP/gDP9ogDx7XJyQKGCSEhAPpLzhfnuLdtNyeuHs/mXnh/UCHo163IZn1T13ydrcyDWNxn5DEtbm2Jv/zWMU5dOUO9A8gLhCAOUFLR6raw67ZPMXnl1X6FoE/3OSvF9wn+JxxnXozFhxvEj5z5LU8c/RaGKZElAykEUp+Fq8+ujN6KsSRpsl2APoUgox9R1Nt1As1WWRoyj8m0dDG57w8gBAIAweX8As++fpil2lWEKykFRT7p7QDIRAZRf6OJ94WlRZ77zkijeEzf7ffTGBCE4Ns++44fwGxO4Jg2lmnGBpLoWvED4l9XzvHGxdOUqmVuFWFI9F1NO4DESzgkbIukcrBUAgQoBPMhYUbLMzl7kvOrF8A3ePgXjzA59Aq+00Qc5DfWePEfYygpkcLQSIQQgODozO9obm9C2gaecnDMBMC84FnGhnq/mz079w4nZichISII4N6WnUzu/2ODydGzv+epPx/C9R1czyahhUxDYXkJlKuiJumw2qlUKrz09pFxhWDq5OW/ZZtEG0ihAQwgKXmzco4vvvg1Xtt7jCa7iXoQ0t/7MGDwo+kRmjt9nISFpUyUoQCoBwE9yS5OL54GmJIIJmbKb+ImHFqTLZEJxg1AapOZ6jvs+eXXWSnlqdVDarWAh+76Mp/u/AxWYJKyXZrcJL6m2UuxLdWOb6c5tfR3gAkBwChju5zPZltlO68vTFM1a+BKjISMfiyrorjH7uU333wJ10yxtrnO0Kv7UV3g+2k8y8E2TQyh6DJ7mP7PG4y9dWScvQxIAASDM5V/5kzTYGf7J0ASIYSIMFKKWebYc2QPh0+NcuCVJyla63hJFzdhk3JcfC/NnemPYUqDo+dezgGDWwPnILkqlYHp0l/pSH+UXe33YBomAEKgEShtUusI+NPyMcptJdLbUijDwFQqas/bvQwplWR4aoRitTjAXnKN8+DbTOSD1YHp9b/QkWrjwe2fo9VuaZxOSmA2JZCWQQgRrvToUhnCimTo+PeZW53X4kzcfCbrYWHKxNjd/m6/J30ntbDK8uZ1NsIynmWTtF1Sms5UOz2p7fhOmjPvneFXZ3+dK1SKkfgth348LEZdM5m9K91Lm/MRutLd2GYCx7SwExZXy0tc31jm5OWTrJRXxoHBuCzc2iCGF+K/LdAHZCIEAPMxU8BEo3Bj/BetLUN6Xm6xxwAAAABJRU5ErkJggg==" alt="Left" style="color:black; width:24px; height: 24px;" onclick="MontreFenetre(-1);"  class="fleche"/>
	<img id="icoLeft" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFmklEQVR4XpWWa2wcVxmGnzlz2dmZ3fXYu7Zcrx2vU0JCE9RtE6hUKpFeKBdREVSJIkpJoiAigtI4lYra8iN2VcqtwaXQBKGiGghtfyBcEVEBaZs4baBRabKhBcVp4qwT4viyTnedXdu7s7PDzFEdoaIo4T16debX857vO590hivqMbJ8lz4eZ4jvsZ8fBP4hQ/yIPp4gyxWkcDk9yoaYEduRbb0xs6L5IyTNFF32Enx8zlTyFKrTjMwe51gpl694lX62M3h1Af1kUXj2i9fenb2z6zMYIsLFapm52hzlYG/4PlYkSkSLYBs2VX+BV6f28ceJvTkUNnI/ucsFSHib1bZ/6/XbnbTdyXS5wPTFAq7n4tEI4NKyiuALIQQpO0kqlmKiOs4z+Z8XZ2qFW9lK7oMBEp5J9Ox/aM13HBqCsQtjzLsLeBLqyb26UJVg1dQuhfgKGKrO0mQGhM/OE98vzrhByLdkCAIJxwn6PbRp5TckfLRw+n24J+16dQrnpkl4MZq8OIXxaWq41IWHK+qU/Tn+OXMc1/f4Ws8mx1KtIXbhXKqAR+kLer7jru51HJ88Qc2rUZdwacqzZT7esZptn98CwL63X2Xglaex03EQyCrARxUq17etYv/kPl6e+FM/W+gTAEHft63ruZvx2fP/A68rgRt1Wp0ki/rUR29j2x1bKE6+h6vWqeseruaxIGqcqoxxa/pOolp0G7txBI+xIRhFp+pVmSlfwPsAPFy+Aa+ffINytcKiPr3qdh64bStn82cZLY0xuTDFTO0CI6V3Kbolssk1DrBOQ+GTN7auoThfeh/ckBNTKc/h1mt4osGCv8BrkyPc9Yt7GPr6b3GiTQB89ro7KMwX2Ly3F7VdB6EAPjW/hq3HCNlhQGa5s4LRQp4GcjFbKNEWTXHTqjVU6vOMV87zse7VoMLw6CG+sPJzLOq+1V9GVQVbX3oQrd3AF1DxKixzlgJkwgAnnO16w710+lKxyDObfoZt2lyNvpL9EucvTvCTo7tQW3V0TSWi6wCOrMD3fRqEbnD6vTGGTx2U8P9HPS3dWLqJbkawNZOIZhCyNQQ5H39tWMXI1LscGDsEeoONg99k/S33ggKKoiACh7tjNrGy/Tr+WycKJ3jyb0/R0uGAoWCrUUzDAMhpKBTPVMY4WzzHgdHXQVcgpTL4r+cZHHkBoQl0VQ0yNVJWC7/76gtU3QaLOnnhJA/8uRdriYmIqIQHvSbSzqxbBCiGAcMHzx1cp5RNEAoIQAcSKoqpoGoamqfRXE6w557n6GlezlzNAwjaeYodw98m3m1hWAaKAl6jQafdwVvjfwcYFii8mJs9QlM0QSrWIkOkVeQuhEDU4L4bNpJxljNfa0gfD9rZ99pDxDM2zc0JHCsWOE463k4q2syx6RzAiwoAAzz7Cev2DdQ1Do0fBlMBS6AaAkPTicxp3Nuznt6bHwbgTOkUT7z5CE0ZiyYngR0JL1WXd5TWuhgtjLHz8MAgm9koAFDoz1UPF5usGKvCCxRIK4SXK1DjGn8Z3cvuN3fyy6NP8fhfH8Ts1LHjloQnojbNdoJliQ9haVF+886eItCPxAD0kq9Q3v5O9QjXtmRYkVyGlJwgELqg1uby0uTveXnmD6idQvZcUzVZYdSIkLG7Sdsd7Hn7eaYq09vZTP5SgNT9DJ5xTw8enXuD5UHALemb5GkWpWgKWouOkYzIQAWkDUWnU1+Cozbz40M/5ZXRA2FrBi//ZD5Nb5PePHBD8mZazCQT81OU6kU8pY6qKcRNi9ZYC+2xVrriHYHT5Eun+fU/ngumKh+e/MkrP/q7yAID11hda5cmPkza7iIeiWHqBqYRIapHUESDc3P/5sjEW+Qmjx0AQnju6v8qAHbLoPUorI3piWzCSMixvejOUqoWc0AI/pUEX0b/AfE4VpRFbkl6AAAAAElFTkSuQmCC" alt="right" style="color:black; width:24px; height: 24px;" onclick="MontreFenetre(1);"  class="fleche"/>
<!--	<input onclick="MontreFenetre(-1);" class="fleche" value="&#x21E6;" type="button"/>	
	<input onclick="MontreFenetre(1);" class="fleche" value="&#x21E8;" type="button"/> -->
	</td></tr></table>
	</div>
	<textarea disabled="disabled" style="visibility: hidden; border:0;" id="sortie"></textarea>
	<canvas style="visibility: hidden;" id="mycanvas" width="480" height="300"></canvas>
	<div id="SaisieTexte">
	<input type="button" onclick="var textentryfilename=Saisie('Enter the filename'); if (textentryfilename!=null) writeFile(textentryfilename,getEntreetexte())" value="Save text entry" /><br>
	<textarea id="MonTexte" style="border:0; width: 480px; height: 300px; background-color: rgb(200,200,255); z-index:1000;">Your text here</textarea></div>
	<div style="visibility: hidden; overflow: scroll;" id="Aide">
<h2>Memento</h2>
<dl>
<dt><span>a=getString();</span><div><div>Function that reads a string on the standard input (prompt). French translation = Saisie</div></div> [or <span>getString([message]</span><div><div>Function that reads a string on the standard input, a optional message is printed.</div></div>) or <span>getInt([message])</span><div><div>Function that reads an integer on the standard input, same syntax as getString. French translation = SaisieEntier.</div></div> ou <span>getReal([message])</span><div><div>Function that reads a real number on the standard input, same syntax as getString. French translation = SaisieReel.</div></div>]</dt>
<dd>Allows to enter a string, an integer or a real number.</dd>
<dt><span>toInt(x);</span><div><div>Function that casts a string to an integer number (Example, toInt('123') is equal to the number 123)</div></div> [or <span>toReal(x)</span><div><div>Function that casts a string to a real number (Example, toReal('1.23') is equal to the number 1.23)</div></div> or <span>toString(x)</span><div><div>Function that casts a number to a string (Example, toString(123) is equal to the string '123')</div></div>]</dt>
<dd>Conversion functions to integers, reals or strings.</dd>
<dt><span>Write(ch);</span><div><div>Function that prints the string ch on the standard text output. Adds a newline.</div></div> [or <span>Print(ch)</span><div><div>same as Write(ch) but without the newline.</div></div>]</dt>
<dd>Prints ch on the standard output [and continue of the same line].</dd>
<dt><span>ClearScreen();</span><div><div>Clear the standard text output.</div></div></dt>
<dd>Clear the standard text output.</dd>
<dt><span>Stop('variable1,variable2');</span><div><div>Debugging function that breaks the execution at a given point and prints the values of some given variables.</div></div></dt>
<dd>Debugging function that breaks the execution at a given point and prints the values of variables <tt>variable1</tt> and <tt>variable2</tt>.</dd>
<dt><span>Help();</span><div><div>Print this manual</div></div></dt>
<dd>Print this manual.</dd>
<dt><span>InitializeGraphics();</span><div><div>Clear the graphic window and et put the turtle at its initial position.</div></div> <span>Viewport(minx,miny,maxx,maxy,dir);</span><div><div>Défini le système de coordonnées qui est utilisé lors des affichages graphiques. dir définit le sens d'affichage, minx et miny définit les coordonnées du coin supérieur (inférieur si dir=-1) gauche et maxx et maxy définit les coordonnées du coin inférieur (supérieur si dir=-1) droit.</div></div></dt>
<dd>Initialize the graphic window.</dd>
<dt><span>Turtle_go(l);</span><div><div>Go forward by l unities (depends on the coordinate system defined by viewport). A line is drawn is the turtle is down.</div></div> <span>Turtle_right(a);</span><div><div>Turn right the turtle by a given an angle in degrees.</div></div> <span>Turtle_left(a);</span><div><div>Turn left the turtle by a given angle in degrees.</div></div> <span>Turtle_up();</span><div><div>Disable the line drawing.</div></div> <span>Turtle_down();</span><div><div>Enable the line drawing.</div></div> <span>Turtle_move(x,y);</span><div><div>Put the turtle at a given position (default is position 0,0).</div></div> <span>Turtle_color(c);</span><div><div>Change the color of the line drawing.</div></div></dt>
<dd>Usual manipulation functions for the LOGO turtle.</dd>
<dt><span>Point(x,y,color);</span><div><div>Draw a point at coordinates x,y with the given color. The coordinate system is either the default one (expressed in pixels with an origine to the upper left corner), or provided by the Viewport function.<br/>Example: <pre>Point(100,200,'red');</pre></div></div> 
<span>Line(x0,y0,x1,y1,color);</span><div><div>Draw a line joining the points at coordinates x0,y0 and x1,y1 using the given color. The coordinate system is either the default one (expressed in pixels with an origine to the upper left corner), or provided by the Viewport function.<br/>Example: <pre>Line(100,200,300,50,'red');</pre></div></div>  
<span>Rectangle(x,y,l,h,color);</span><div><div>Draw (the border of) a rectangle whose upper left corner is at position x,y, having length l and height h with the given color. The coordinate system is either the default one (expressed in pixels with an origine to the upper left corner), or provided by the Viewport function.<br/>Example: <pre>Rectangle(100,200,150,50,'red');</pre></div></div> 
<span>FilledRectangle(x,y,l,h,color);</span><div><div>Draw a rectangle whose upper left corner is at position x,y, having length l and height h with the given color. The coordinate system is either the default one (expressed in pixels with an origine to the upper left corner), or provided by the Viewport function.<br/>Exemple: <pre>FilledRectangle(100,200,150,50,'red');</pre></div></div> 
<span>Circle(x,y,r,color);</span><div><div>Draw a circle whose center is at coordinate x,y, and diameter is r with the given color. The coordinate system is either the default one (expressed in pixels with an origine to the upper left corner), or provided by the Viewport function (in this latter case, the circle can appear as an ellipse).<br/>Example: <pre>Circle(100,200,50,'red');</pre></div></div> 
<span>FilledCircle(x,y,r,color);</span><div><div>Draw a disk whose center is at coordinate x,y, and diameter is r with the given color. The coordinate system is either the default one (expressed in pixels with an origine to the upper left corner), or provided by the Viewport function (in this latter case, the disk can appear as an ellipse).<br/>Example: <pre>FilledCircle(100,200,50,'red');</pre></div></div> 
<span>Ellipse(x,y,rx,ry,color);</span><div><div>Draw an ellipse whose center is at coordinate x,y, and horizontal and vertical diameters are rx and ry with the given color. The coordinate system is either the default one (expressed in pixels with an origine to the upper left corner), or provided by the Viewport function.<br/>Example: <pre>Ellipse(100,200,50,'red');</pre></div></div> 
<span>FilledEllipse(x,y,rx,ry,color);</span><div><div>Draw a filled ellipse whose center is at coordinate x,y, and horizontal and vertical diameters are rx and ry with the given color. The coordinate system is either the default one (expressed in pixels with an origine to the upper left corner), or provided by the Viewport function.<br/>Example: <pre>FilledEllipse(100,200,50,'red');</pre></div></div> 
<span>Text(x, y, ch, color);</span><div><div>Write the text ch on the graphical window at position x,y with the given color.<br/>Example: <pre>Text(100,200,'Hello world','red');</pre></div></div>  
<span>setCanvasFont(fontname, fontsize, fontstyle);</span><div><div>Modify the default font. fontname is the name of the font family (eg. 'times', 'helvetica',...) that is installed of the system. fontsize is the size of the font expressed in pt (points) or px (pixels) (eg. '25pt'). fontstyle allows the change the style of the font (eg. 'bold', 'italic', 'bold italic').<br/>Example: <pre>
setCanvasFont('helvetica', '25pt', 'bold');
Text(100,100,'Hello world','blue');
setCanvasFont('helvetica', '25px', 'bold italic');
Text(100,200,'Hello world','red');</pre></div></div> 
<span>DrawImage(imageurl,x,y,w,h);</span><div><div>Draw an image on that graphical window. The image, given by its url, is drawn at position x,y, with length w and height h. The use of the function is quite complex, mainly due to some security processes developed by the browser in order to forbid unusual use of externel images (for instance, the use of external images require to disable the logo turtle functionality by adding the instruction turtleEnabled=false;). Here are two examples:<ul>
<li>Use of an external image.
<pre>
turtleEnabled=false;
Initialiser();
DrawImage('http://www.mozilla.org/media/img/home/firefox.png',150,200,100,100);
</pre>
</li>
<li>Use of an image from the internal filesystem (compatible with the turtle and faster when on the low bandwidth internet connections). <em>The image must by integrated in the internal filesystem before</em> by using the following procedure: go to the "File Manager" of the environnement, then to "External FS". Browse your disk and select the image file (let say 'image.png' is store on your disk). Then select "Data file to Internal FS". After a few second, the file Data/image.png should appear in the internal filesystem. It can be used then with,
<pre>
Initialiser();
DrawImage(readFile('Data/image.png'),150,200,100,100);
</pre>
</li>
</ul></pre></div></div>
<span>rgb(cr,cv,cb); rgba(cr,cv,cb, opacité);</span><div><div>Define a color by providing its rgb components (three integers between 0 and 255), and for rgba by adding a transparency coefficient (real number between 0 and 1). These fonction can be used each time a color is required. <br/>Example: 
<pre>
FilledRectangle(200,200,300,50,rgb(255,0,255));

// or another example
for(var i=0; i<10; i=i+1) {
   FilledRectangle(Hasard(500),Hasard(500),50,50,rgb(Hasard(255),Hasard(255),Hasard(255)));
}

FilledRectangle(200,200,300,50,rgba(255,0,255,0.5));
FilledRectangle(350,225,300,50,rgba(255,0,255,0.5));

</pre></div></div>
<span>LinearGradient(color1,color2,xd,yd,xf,yf);</span><div><div>Define a gradient of color between two colors (color1 and color2). Point xd,yd has color color1 and point xf,yf has color color2.<br/>Example: <pre>FilledCircle(200,200,100,LinearGradient('red','yellow',150,200,250,200));</pre></div></div>
<span>ShadowOn(); ShadowOff();</span><div><div>Enable or disable the shadow effect.<br/>Example: 
<pre>
ShadowOn();
FilledRectangle(100,100,200,80,'red');
ShadowOff();
FilledRectangle(100,200,200,80,'red');
</pre></div></div> 
</dt>
<dd>Usual functions for the graphical output.</dd>
<dt>
<span>ch[i];</span><div><div>Return the character at indice i is string ch (the first character is at indice 0).</div></div>
<span> Length(ch);</span><div><div>Return the length of ch.<br/>Example: <t>Write(Length('Hello'));</t> prints 5.</div></div>
<span> Substr(ch,begin,length);</span><div><div>Return a substring of ch composed by length characters from indice begin.<br/>Example: <t>Write(Substr('Bonjour',3,2));</t> prints 'jo'.</div></div>
<span> Search(ch,ch_searched);</span><div><div>Return the position of the first occurrence of ch_searched is ch (or -1 if ch_searched is not a substring of ch).<br/>Example: <t>Write(Search('Bonjour','jour'));</t> prints 3.</div></div>
</dt>
<dd>Standard manipulation functions of strings.</dd>
<dt>
<span> toAscii(c);</span><div><div>Return the ASCII code of character c (also works with unicode).<br/>Exemple: <t>Write(toAscii('A'));</t> prints 65.</div></div>
<span> fromAscii(n);</span><div><div>Return the symbol corresponding to the ASCII code n (also works with unicode).<br/>Example: <t>Write(fromAscii(66));</t> prints 'B'.</div></div>
<span> Uppercase(c);</span><div><div>Transform a lettre in uppercase.<br/>Example: <t>Write(Uppercase('é'));</t> prints 'E'.</div></div></dt>
<dd>Functions for symbol manipulations.</dd>
<dt><span>Tableau(n); </span><div><div>Create an array of size n. The other standard way of defining an array are:
<ul>
<li>By providing the list of its elements: var T=[1,2,3];</li>
<li>By creating an array of size 0: var T=[];</li>
<li>By using the javascript object Array: var T=new Array(10)</li>
</ul>
The element at index i is accessible for reading and writing by using T[i].
</div></div>
<span>Size(T); </span><div><div>Return the size of T.<br/>Example: 
<pre>var T=[3,4,5];
Write(Size(T));</pre> prints 3.</div></div>
<span>PrintTable(T); </span><div><div>Pretty print of the array on the standard text output.<br/>Example: 
<pre>var T=[[2,6],[4,5],[7,8]]; // 2D array
PrintTable(T);</pre> prints 
<pre>
2	6
4	5
7	8
</pre></div></div>
<span>DrawTable(T);</span><div><div>Create a diagram (in the graphical output) using the values stored in T.<br/>Example: 
<pre>var T=[[2,6],[4,5],[7,8]]; // 2D array
DrawTable(T);</pre>
Numbers of options are associated to this function. Here is its complete syntax: DrawTable(T,addition,fill,color,type,thickness) where
<ul>
<li>addition is a boolean (default to false) indicate if the curve must be added to the preceding one.</li>
<li>fill is a boolean (default to true) indicate wether the area under the curve must be filled or not.</li>
<li>color is the color of the curve, (default to red).</li>
<li>type is a string defining the type of points: 'O', 'X' or ' ' (default to 'O').
<li>thickness is the thickness of the curve (default to 2).</li>
</ul>
</div></div>
<span>InitTable(T, value);</span><div><div>Assign the same value to all the elements of the tablea T.<br/>Example: <pre>var T=new Array(5);
InitTable(T, 0);
</pre></div></div>
<span>ConcatTable(T1,T2);</span><div><div>Concatenate two tables.</div></div>
<span>CombineTableByRow(T1,T2);</span><div><div>Construct a two dimensional table whose first column is T1 and second column is T2.</div></div>
<span>CombineTableByColumn(T1,T2);</span><div><div>Construct a two dimensional table whose first row is T1 and second row is T2.</div></div>
<span>Renverse(T);</span><div><div>Construct the inverse of table T.</div></div>
<span>SortNumericalOrder(T);</span><div><div>Sort T using a numerical order.</div></div>
<span>SortLexicographicOrder(T);</span><div><div>Sort T using a lexicographical order.</div></div>
<span>SubTable(T, begin, length);</span><div><div>Extract a subtable from T.</div></div>
</dt>
<dd>Table manipulation functions.</dd>
<dt>
<span>LoadAudio(url); </span><div><div>Return an audio object, read from a given url, that can be played by the method play(). Notice that the supported song format may vary depending on the browser (nevertheless, .wav files are largely supported). As for images, two usages are possible:<ul>
<li>Use of an external url.
<pre>
var song=LoadAudio('http://www.moviesoundscentral.com/sounds/star_wars/empire_strikes_back/jedi3.wav');
song.play();
</pre>
</li>
<li>Use of a song stored in the internal filesystem. <em>The song must by integrated in the internal filesystem before</em> by using the following procedure: go to the "File Manager" of the environnement, then to "External FS". Browse your disk and select the song file (let say 'song.wav' is store on your disk). Then select "Data file to Internal FS". After a few second, the file Data/song.wav should appear in the internal filesystem. It can be used then with,
<pre>
var song=LoadAudio(readFile('Data/song.wav'));
song.play();
</pre>
</li>
</ul></pre></div></div>
<span>CreateAudio(Table,SampleRate); </span><div><div>Create an audio object by using an array of values (integer between 0 and 255) that corresponds to the sample of the song at a given samplerate. It can be played using method play(). <br/>Example:
<pre>
var data=[]; for(var i=0; i<22050; i++) {data[i]=128+Math.floor(127*Math.sin(i*0.125315));}
var LA=CreateAudio(data,22050);
LA.play();
</pre>
</div></div> 
<span>ImportAudio(filename); SampleRate(nomfichier);</span><div><div>Create an array that corresponds to the sample of the song (only 8bit, mono wav files or supported). The song must be stored in the internal filesystem. The obtained table can be manipulated and replayed using the CreateAudio function. The sample rate of the original song can be retrieved by using the SampleRate function.
<pre>
var data=ImportAudio('Data/jedi3.wav');
var SR=SampleRate('Data/jedi3.wav');
var son=CreateAudio(data,SR*1.5);
son.play();
</pre>
</div></div>
<span>SaveAudio(filename, data, samplerate);</span><div><div>Generate a wav file and store the resulting file in the internal filesystem.
</div></div>
<span>ExportAudio(data, samplerate); </span><div><div>Generate a wav file on a url encoded form. Can be saved using the "save as" functionality of the browser.
</div></div>
</dt>
<dd>Functions for manipulating HTMLaudio objects.</dd>
<dt>
<span>Random(n); </span><div><div>Return a uniform random integer between 0 and n-1. <br/>Example: <t>Write(Random(10));</t></div></div>
<span>ExecutionTime(codeJS);</span><div><div>Return the execution time (in milliseconds) used by the given JS code<br/>Example: <pre>
Write(ExecutionTime('var c; for(var i=0; i<1000000; i++) {c=c+i;}'));
</pre></div></div> 
<span>getTextEntry(); setTextEntry(chaine);</span><div><div>Input/output functions from/to the text input window. getTextEntry() returns a string corresponding the the content of the window and setTextEntry(ch) replaces the content of the window by the content of ch.</div></div>
<span>HTMLoutput(ch);</span><div><div>Interpret the HTML code ch. The result is displayed in the HTML output window.</div></div>
</dt>
<dd>Miscellaneous functions.</dd>
<dt>
<span>includeFile(filename);</span><div><div>Execute the javascript content of filename. This function can be used to define some external libraries. (ex: <t>includeFile('Library/libRS.js');</t>).</div></div>
<span>readFile(filename);</span><div><div>Read the content of file filename et return a string that corresponds to its content.</div></div>
<span>writeFile(filename,content);</span><div><div>Save the given content in filename</div></div>
<span>removeFile(filename);</span><div><div>Remove file filename.</div></div>
<span>renameFile(oldname, newname);</span><div><div>Rename a file.</div></div>
<span>ls();</span><div><div>List all the files stored in the internal filesystem.</div></div>
</dt>
<dd>File manipulation functions.</dd>
</dl>

<h2>Variable inspector</h2>
The variable inspector allows to follow the values of some variables by constructing a execution trace.
In order to follow a variable, it must be entered in the inspect field (several variables separated by a comma).
An execution trace is then constructed (evaluation of all the variables each time a ';' is reached).

<div id="exemples" style="font-size: 1.3em;">
<h2>A few examples (see the internal FS for further examples)</h2>
<script type="text/javascript">
ConstruitExemples();
for(var i=0; i<20; i++) document.write('<br/>');
</script>
<!--
<h2>Petit m&eacute;mento</h2>
<dl>
<dt><span>a=Saisie();</span><div><div>Fonction permettant de saisir une chaîne de caractères</div></div> [ou <span>Saisie([message]</span><div><div>Fonction permettant de saisir une chaîne de caractères, un message optionnel peut être affiché au moment de la saisie</div></div>) ou <span>SaisieEntier([message])</span><div><div>Fonction permettant de saisir un nombre entier, sa syntaxe est la même que la fonction Saisie()</div></div> ou <span>SaisieReel([message])</span><div><div>Fonction permettant de saisir un nombre réel, sa syntaxe est la même que la fonction Saisie()</div></div>]</dt>
<dd>Permet la saisie d'une cha&icirc;ne de caract&egrave;re (ou d'un entier ou d'un réel).</dd>
<dt><span>enEntier(x);</span><div><div>Fonction permettant transformer une chaîne de caractères en un nombre entier (par exemple, enEntier('123') renvoie la valeur entière 123)</div></div> [ou <span>enReel(x)</span><div><div>Fonction permettant transformer une chaîne de caractères en un nombre réel (par exemple, enReel('1.23') renvoie la valeur réelle 1.23)</div></div> ou <span>enChaine(x)</span><div><div>Fonction permettant transformer un nombre en une chaîne de caractères (par exemple, enChaine(123) renvoie la chaîne '123')</div></div>]</dt>
<dd>Convertit x en entier (ou r&eacute;&egrave;l ou cha&icirc;ne de caract&egrave;re).</dd>
<dt><span>Ecrire(ch);</span><div><div>Fonction d'affichage. La chaîne ch est affichée dans la fenêtre de sortie texte. Il y a un retour à la ligne après l'affichage.</div></div> [ou <span>Afficher(ch)</span><div><div>Idem à Ecrire(ch). Cette fonction est conservée pour assurer une compatibilité.</div></div> ou <span>Afficher_srl(ch);</span><div><div>Idem à Ecrire(ch) sauf qu'il n'y a pas de retour à la ligne après l'affichage.</div></div>]</dt>
<dd>Affiche la cha&icirc;ne de caract&egrave;res ch [sans retour &agrave; la ligne].</dd>
<dt><span>EffacerEcran();</span><div><div>Efface la sortie texte.</div></div></dt>
<dd>Efface la sortie texte.</dd>
<dt><span>Stop('variable1,variable2');</span><div><div>Bloque l'exécution à un endroit déterminé est affiche les valeurs de variables données en paramètre</div></div></dt>
<dd>Suspend l'ex&eacute;cution du programme et affiche l'&eacute;tat courant des variables <tt>variable1</tt> et <tt>variable2</tt>.</dd>
<dt><span>Help();</span><div><div>Affiche l'aide</div></div></dt>
<dd>Affiche cette aide.</dd>
<dt><span>Initialiser();</span><div><div>Efface la fen&ecirc;tre graphique et replace la tortue en position initiale.</div></div> <span>Viewport(minx,miny,maxx,maxy,dir);</span><div><div>Défini le système de coordonnées qui est utilisé lors des affichages graphiques. dir définit le sens d'affichage, minx et miny définit les coordonnées du coin supérieur (inférieur si dir=-1) gauche et maxx et maxy définit les coordonnées du coin inférieur (supérieur si dir=-1) droit.</div></div></dt>
<dd>Fonctions d'initialisation de la fenêtre graphique.</dd>
<dt><span>Avancer(l);</span><div><div>Avance la tortue de l unités (dépend du système de coordonnées défini par Viewport). Une ligne est tracée si la tortue est baissée.</div></div> <span>Droite(a);</span><div><div>Tourne la tortue de a degrés dans le sens des aiguilles d'une montre.</div></div> <span>Gauche(a);</span><div><div>Tourne la tortue de a degrés dans le sens inverse des aiguilles d'une montre.</div></div> <span>Lever();</span><div><div>Baisse la tortue (et donc la tortue laisse des traces lorsqu'elle avance).</div></div> <span>Baisser();</span><div><div>Lève la tortue (et donc supprime les traces laissées par la tortue lorsqu'elle avance).</div></div> <span>Deplacer(x,y);</span><div><div>Place la tortue en une position fixée de l'écran (par défaut, elle est en position 0,0).</div></div> <span>Couleur(c);</span><div><div>Change la couleur de la trace laissée par la tortue.</div></div></dt>
<dd>Op&eacute;rations usuelles de manipulation de la tortue.</dd>
<dt><span>Point(x,y,couleur);</span><div><div>Trace un point aux coordonnées x,y avec la couleur donnée. Le système de coordonnée est soit celui par défaut (exprimée en pixel avec une origine au coin supérieur gauche), soit celui fourni par la commande Viewport.<br/>Exemple: <pre>Point(100,200,'red');</pre></div></div> 
<span>Ligne(x0,y0,x1,y1,couleur);</span><div><div>Trace une ligne joignant les points de coordonnées x0,y0 et x1,y1 avec la couleur donnée. Le système de coordonnée est soit celui par défaut (exprimée en pixel avec une origine au coin supérieur gauche), soit celui fourni par la commande Viewport.<br/>Exemple: <pre>Ligne(100,200,300,50,'red');</pre></div></div>  
<span>Rectangle(x,y,l,h,couleur);</span><div><div>Trace (les bords d')un rectangle dont le coin supérieur gauche est le point de coordonnées x,y, de longueur l et de hauteur h avec la couleur donnée. Le système de coordonnée est soit celui par défaut (exprimée en pixel avec une origine au coin supérieur gauche), soit celui fourni par la commande Viewport.<br/>Exemple: <pre>Rectangle(100,200,150,50,'red');</pre></div></div> 
<span>RectanglePlein(x,y,l,h,couleur);</span><div><div>Trace un rectangle plein dont le coin supérieur gauche est le point de coordonnées x,y, de longueur l et de hauteur h avec la couleur donnée. Le système de coordonnée est soit celui par défaut (exprimée en pixel avec une origine au coin supérieur gauche), soit celui fourni par la commande Viewport.<br/>Exemple: <pre>RectanglePlein(100,200,150,50,'red');</pre></div></div> 
<span>Cercle(x,y,r,couleur);</span><div><div>Trace un cercle dont le centre est le point de coordonnées x,y, et le rayon est r avec la couleur donnée. Le système de coordonnée est soit celui par défaut (exprimée en pixel avec une origine au coin supérieur gauche), soit celui fourni par la commande Viewport (dans ce cas, le cercle peut apparaître déformé).<br/>Exemple: <pre>Cercle(100,200,50,'red');</pre></div></div> 
<span>CerclePlein(x,y,r,couleur);</span><div><div>Trace un disque dont le centre est le point de coordonnées x,y, et le rayon est r avec la couleur donnée. Le système de coordonnée est soit celui par défaut (exprimée en pixel avec une origine au coin supérieur gauche), soit celui fourni par la commande Viewport (dans ce cas, le cercle peut apparaître déformé).<br/>Exemple: <pre>CerclePlein(100,200,50,'red');</pre></div></div> 
<span>Ellipse(x,y,rx,ry,couleur);</span><div><div>Trace une ellipse dont le centre est le point de coordonnées x,y, et les rayons sont rx et ry avec la couleur donnée. Le système de coordonnée est soit celui par défaut (exprimée en pixel avec une origine au coin supérieur gauche), soit celui fourni par la commande Viewport.<br/>Exemple: <pre>Ellipse(100,200,50,'red');</pre></div></div> 
<span>EllipsePlein(x,y,rx,ry,couleur);</span><div><div>Trace une ellipse pleine dont le centre est le point de coordonnées x,y, et les rayons sont rx et ry avec la couleur donnée. Le système de coordonnée est soit celui par défaut (exprimée en pixel avec une origine au coin supérieur gauche), soit celui fourni par la commande Viewport.<br/>Exemple: <pre>EllipsePlein(100,200,50,'red');</pre></div></div> 
<span>Texte(x, y, ch, couleur);</span><div><div>Ecrit le texte ch sur la sortie graphique à partir du point de coordonnées x,y avec la couleur donnée. Le système de coordonnée est soit celui par défaut (exprimée en pixel avec une origine au coin supérieur gauche), soit celui fourni par la commande Viewport.<br/>Exemple: <pre>Texte(100,200,'Bonjour tout le monde','red');</pre></div></div>  
<span>setCanvasFont(fontname, fontsize, fontstyle);</span><div><div>Modifie la police de caractères par défaut. fontname est le nom d'une police de caractères (ex: 'times', 'helvetica',...) qui doit être installée sur le système. fontsize est la taille de cette police exprimée en unité pt (points) )ou px (pixels) (par ex: '25pt'). fontstyle permet de changer le style de cette police (ex: 'bold', 'italic', 'bold italic').<br/>Exemple: <pre>
setCanvasFont('helvetica', '25pt', 'bold');
Texte(100,100,'Bonjour le monde','blue');
setCanvasFont('helvetica', '25px', 'bold italic');
Texte(100,200,'Bonjour le monde','red');</pre></div></div> 
<span>DrawImage(imageurl,x,y,w,h);</span><div><div>Place une image dans le canvas. L'image, donnée par son url est placée au point de coordonnées x,y et affichée avec une largeur w et une hauteur h. L'utilisation de cette fonction est complexe, notamment car il y a des processus de sécurités développés par le serveur pour empêcher l'utilisation frauduleuse d'images externes (Il est possible d'utiliser ce type d'images mais il faut avoir au préalable desactivé la fonctionnalité "Tortue" de l'interface via l'instruction turtleEnabled=false;). Voici deux exemples:<ul>
<li>Utilisation d'une url externe.
<pre>
turtleEnabled=false;
Initialiser();
DrawImage('http://www.mozilla.org/media/img/home/firefox.png',150,200,100,100);
</pre>
</li>
<li>Utilisation d'une image du gestionnaire de fichiers interne (compatible avec l'utilisation de la tortue). <em>Il faut avoir intégré l'image correspondante dans le gestionnaire de fichiers interne</em> par la procédure suivante: aller dans GestionsFichiers, puis dans "External FS". Parcourez votre disque pour sélectionner l'image (imaginons qu'elle s'appelle 'image.png' sur votre disque). Cliquez sur "Data file to Internal FS". Normalement vous devriez voir apparaître le fichier image.png dans le répertoire Data du gestionnaire de fichiers interne. Pour l'utiliser,
<pre>
Initialiser();
DrawImage(readFile('Data/image.png'),150,200,100,100);
</pre>
</li>
</ul></pre></div></div>
<span>rgb(cr,cv,cb); rgba(cr,cv,cb, opacité);</span><div><div>Définit une couleur en fonction de ses composantes de rouge, vert et bleu (trois entiers entre 0 et 255), et pour rgba d'un coefficient d'opacité compris entre 0 et 1. Ceci peut être placé à chaque fois qu'une couleur est demandée. En général, l'attribut couleur peut être soit un nom 'red', 'blue',..., soit rgb(10,100,255), soit GradientLineaire('red',rgb(10,100,255),0,0,500,600);<br/>Exemple: 
<pre>
RectanglePlein(200,200,300,50,rgb(255,0,255));

// ou un autre exemple 
for(var i=0; i<10; i=i+1) {
   RectanglePlein(Hasard(500),Hasard(500),50,50,rgb(Hasard(255),Hasard(255),Hasard(255)));
}

RectanglePlein(200,200,300,50,rgba(255,0,255,0.5));
RectanglePlein(350,225,300,50,rgba(255,0,255,0.5));

</pre></div></div>
<span>GradientLineaire(couleur1,couleur2,xd,yd,xf,yf);</span><div><div>Définit un gradient de couleur entre deux couleurs (couleur1 et couleur2). Les points situés en xd,yd auront pour couleur couleur1, ceux situés en xf,yf auront pour couleur couleur2, les autres auront un mélange des deux couleurs.<br/>Exemple: <pre>CerclePlein(200,200,50,GradientLineaire('red','yellow',150,200,250,200));</pre></div></div>
<span>ShadowOn(); ShadowOff();</span><div><div>Active ou désactive l'effet d'ombre. Lorsque l'effet est activé, tout ce qui est tracé apparaît avec une légère ombre<br/>Exemple: 
<pre>
ShadowOn();
RectanglePlein(100,100,200,80,'red');
ShadowOff();
RectanglePlein(100,200,200,80,'red');
</pre></div></div> 
</dt>
<dd>Fonctions usuelles pour le mode graphique.</dd>
<dt>
<span>CaractereEn(ch,i);</span><div><div>Renvoie le caractère à l'indice i de la chaîne ch (le premier caractère est à l'indice 0). La notation ch[i] est un équivalent à cette fonction.<br/>Exemple: <t>Ecrire(CaractereEn('Bonjour',3));</t> affiche 'j'.</div></div>
<span> Longueur(ch);</span><div><div>Renvoie la longueur de la chaîne ch.<br/>Exemple: <t>Ecrire(Longueur('Bonjour'));</t> affiche 7.</div></div>
<span> SousChaine(ch,debut,longueur);</span><div><div>Renvoie un sous-chaîne composée des longueur caractères de la chaîne ch à partir de l'indice début.<br/>Exemple: <t>Ecrire(SousChaine('Bonjour',3,2));</t> affiche 'jo'.</div></div>
<span> PositionDans(ch,ch_cherchee);</span><div><div>Renvoie la première occurrence de la chaîne cherchée dans la chaîne ch (ou -1 si elle ne s'y trouve pas).<br/>Exemple: <t>Ecrire(PositionDans('Bonjour','jour'));</t> affiche 3.</div></div>
</dt>
<dd>Fonctions de manipulation de cha&icirc;nes de caract&egrave;res.</dd>
<dt>
<span> Caractere_vers_Ascii(c);</span><div><div>Renvoie le code ASCII du caractère c (fonctionne aussi avec les caractères UTF-8).<br/>Exemple: <t>Ecrire(Caractere_vers_Ascii('A'));</t> affiche 65.</div></div>
<span> Ascii_vers_Caractere(n);</span><div><div>Renvoie le caractère correspondant au code ASCII n (fonctionne aussi avec les caractères UTF-8).<br/>Exemple: <t>Ecrire(Ascii_vers_Caractere(66));</t> affiche 'B'.</div></div>
<span> Majuscule(c);</span><div><div>Transforme une letre en majuscule lorsque c'est possible.<br/>Exemple: <t>Ecrire(Majuscule('é'));</t> affiche 'E'.</div></div></dt>
<dd>Fonctions de manipulation de caract&egrave;res.</dd>
<dt><span>Tableau(n); </span><div><div>Crée un tableau de taille n (toutes les cases de ce tableau sont non définies). Les autres manières de déclarer sont:
<ul>
<li>En donnant la liste de ses valeurs: var T=[1,2,3];</li>
<li>En créant un tableau de taille 0: var T=[];</li>
<li>En l'objet javascript Array.</li>
</ul>
On accède alors à l'élément du tableau situé à l'indice i par T[i].
</div></div>
<span>Taille(T); </span><div><div>Renvoie la taille du tableau T.<br/>Exemple: 
<pre>var T=[3,4,5];
Ecrire(Taille(T));</pre> affiche 3.</div></div>
<span>AfficherTableau(T); </span><div><div>Affiche le tableau, y compris s'il est à deux dimensions.<br/>Exemple: 
<pre>var T=[[2,6],[4,5],[7,8]];
AfficherTableau(T);</pre> affiche 
<pre>
2	6
4	5
7	8
</pre></div></div>
<span>AfficherCourbe(T);</span><div><div>Trace (dans la fenêtre graphique) la courbe correspondant aux valeurs stockées dans le  tableau (si le tableau est à deux dimensions, les valeurs d'abscisses sont celles d'indice 0 et les valeurs des ordonnées sont celles d'indice 1).<br/>Exemple: 
<pre>var T=[[2,6],[4,5],[7,8]];
AfficherCourbe(T);</pre>
Il y a un certain nombre d'options à cette fonction. Voici sa syntaxe complète: AfficherCourbe(T,addition,remplissage,couleur,type,epaisseur) où
<ul>
<li>addition est un booléen (défaut false) qui indique si la courbe doit être tracée dans le même repère que la courbe précédente.</li>
<li>remplissage est un booléen (défaut true) qui indique si l'aire sous la courbe doit être tracée.</li>
<li>couleur est la couleur de la courbe (défaut rouge).</li>
<li>type est le type de tracé des points de la courbe. Peut-être 'O' (un gros point, c'est le défaut), 'X' (une croix) ou ' ' (rien du tout).
<li>épaisseur est l'épaisseur de la courbe (défaut 2).</li>
</ul>
</div></div>
<span>InitialiserTableau(T, valeur);</span><div><div>Donne à toutes les cases du tableau T la même valeur.<br/>Exemple: <pre>var T=Tableau(5);
InitialiserTableau(T, 0);
</pre></div></div>
<span>ConcateneTableaux(T1,T2);</span><div><div>Construit un tableau qui est la concatenation des deux tableaux T1 et T2.</div></div>
<span>CombineTableauxL(T1,T2);</span><div><div>Construit un tableau à deux dimensions dont la première colonne est T1 et la deuxième colonne est T2.</div></div>
<span>CombineTableauxC(T1,T2);</span><div><div>Construit un tableau à deux dimensions dont la ligne colonne est T1 et la deuxième ligne est T2.</div></div>
<span>Renverser(T);</span><div><div>Construit l'inverse du tableau T.</div></div>
<span>OrdreNumerique(T);</span><div><div>Trie le tableau T en utilisant un ordre numérique.</div></div>
<span>OrdreLexicographique(T);</span><div><div>Trie le tableau T en utilisant un ordre lexicographique.</div></div>
<span>SousTableau(T, debut, longueur);</span><div><div>Extrait du tableau T un sous-tableau de taille longueur à partir de l'indice début.</div></div>
</dt>
<dd>Fonctions de manipulation de tableaux.</dd>
<dt>
<span>ChargerSon(url); </span><div><div>Renvoie un objet audio, chargé à partir d'une url, qui peut être joué par la suite avec la méthode play(). Les formats sonores supportés dépendent du navigateur (les fichiers .wav sont les plus largement supportés). Voici deux exemples d'utilisation:<ul>
<li>Utilisation d'une url externe.
<pre>
var son=ChargerSon('http://www.moviesoundscentral.com/sounds/star_wars/empire_strikes_back/jedi3.wav');
son.play();
</pre>
</li>
<li>Utilisation d'un son du gestionnaire de fichiers interne. <em>Il faut avoir intégré l'image correspondante dans le gestionnaire de fichiers interne</em> par la procédure suivante: aller dans GestionsFichiers, puis dans "External FS". Parcourez votre disque pour sélectionner le fichier son (imaginons qu'il s'appelle 'son.wav' sur votre disque). Cliquez sur "Data file to Internal FS". Normalement vous devriez voir apparaître le fichier son.wav dans le répertoire Data du gestionnaire de fichiers interne. Pour l'utiliser,
<pre>
var son=ChargerSon(readFile('Data/son.wav'));
son.play();
</pre>
</li>
</ul></pre></div></div>
<span>CreerSon(Tableau,Echantillonnage); </span><div><div>Renvoie un objet audio, créé à partir du tableau donné (d'entiers compris entre 0 et 255) correspondant à un échantillonnage de ce son à la fréquence d'échantillonnage donnée. Il peut être joué par la suite avec la méthode play(). <br/>Exemple:
<pre>
var data=[]; for(var i=0; i<22050; i++) {data[i]=128+Math.floor(127*Math.sin(i*0.125315));}
var LA=CreerSon(data,22050);
LA.play();
</pre>
</div></div> 
<span>ImportSon(nomfichier); SampleRate(nomfichier);</span><div><div>Renvoie le tableau de valeur correspondant au son stocké dans le fichier (uniquement format .wav, une seule voie, 8bits). Le son doit se trouver dans le gestionnaire de fichiers interne. Le tableau obtenu peut ensuite être manipulé et rejoué par exemple en utilisant la fonction CreerSon. Pour récupérer le taux d'échantillonnage du son, il faut utiliser la fonction SampleRate.
<pre>
var data=ImportSon('Data/jedi3.wav');
var SR=SampleRate('Data/jedi3.wav');
var son=CreerSon(data,SR*1.5);
son.play();
</pre>
</div></div>
<span>SauverSon(nomfichier, data, samplerate);</span><div><div>Génère le son au format .wav et l'enregistre dans le gestionnaire de fichiers interne. Il peut ensuite être rechargé avec la fonction ChargerSon.
</div></div>
<span>ExportSon(data, samplerate); </span><div><div>Génère le son au format .wav et avec le son chargé sous forme d'url. Il peut alors être enregistré (via le navigateur) sur le disque et joué avec n'importe quel autre outil.
</div></div>
</dt>
<dd>Fonctions de cr&eacute;ation de son (&agrave; partir d'un fichier ou directement en g&eacute;n&eacute;rant le son). A chaque fois, on objet HTMLAudio est retourn&eacute; qui peut &ecirc;tre jou&eacute; par sa m&eacute;thode play().</dd>
<dt>
<span>Hasard(n); </span><div><div>Renvoie un nombre au hasard (uniforme) compris entre 0 et n-1. <br/>Exemple: <t>Ecrire(Hasard(10));</t></div></div>
<span>chronometre(codeJS);</span><div><div>Renvoie le temps d'exécution en millisecondes mis par le code AlgoScript. <br/>Exemple: <pre>
Ecrire(chronometre('var c; for(var i=0; i<1000000; i++) {c=c+i;}'));
</pre></div></div> 
<span>getEntreetexte(); setEntreetexte(chaine);</span><div><div>Permet de manipuler la fenêtre d'entrée de texte long. getEntreetexte() retourne une chaîne de caractère correspondant au contenu de la fenêtre et setEntreetexte(chaine) remplace le contenu de la fenêtre par le contenu de chaîne.</div></div>
<span>HTMLoutput(ch);</span><div><div>Interpr&egrave;te le code HTML stock&eacute; dans la cha&icirc;ne ch. Le r&eacute;sultat est affich&eacute; dans la fen&ecirc;tre de sortie HTML. NB: cette fonctionnalit&eacute; se combine tr&egrave;s bien avec le champ d'entrée de texte long (taper le code HTML dans le champ de texte long et interpr&eacute;ter le r&eacute;sultat via la commande "HTMLoutput(getEntreetexte());" dans la fen&ecirc;tre Code JS).</div></div>
</dt>
<dd>Divers.</dd>
<dt>
<span>includeFile(filename);</span><div><div>Exécute le contenu du fichier filename. Cette fonction permet par exemple de travailler avec des bibliothèques de fonctions (ex: <t>includeFile('Library/libRS.js');</t>).</div></div>
<span>readFile(filename);</span><div><div>Lire le contenu du fichier filename et retourne la chaîne de caractères correspondante.</div></div>
<span>writeFile(filename,content);</span><div><div>Sauvegarde le contenu content dans le fichier filename.</div></div>
<span>removeFile(filename);</span><div><div>Supprime le fichier filename.</div></div>
<span>renameFile(oldname, newname);</span><div><div>Renomme le fichier de oldname à newname.</div></div>
<span>ls();</span><div><div>Ecrit la liste de tous les fichiers contenu dans le gestionnaire de fichiers internes.</div></div>
</dt>
<dd>Fonctions de gestion de fichiers (en particulier, includeFile permet d'inclure le code d'une biblioth&egrave;que au moment de l'ex&eacute;cution du code).</dd>
</dl>
<h2>Inspecteur de variables</h2>
L'inspecteur de variables permet de suivre l'&eacute;volution des valeurs des variables au cours de l'ex&eacute;cution. Les valeurs de variables saisies dans le champ Inspecteur (noms de variables s&eacute;par&eacute;s par des virgules) sont calcul&eacute;es &agrave; chaque fois qu'un ; est rencontr&eacute;. Un tableau r&eacute;capitulatif des diff&eacute;rentes valeurs est affich&eacute; &agrave; la fin de l'ex&eacute;cution.

<div id="exemples" style="font-size: 1.3em;">
<h2>Quelques exemples</h2>
<script type="text/javascript">
ConstruitExemples();
for(var i=0; i<20; i++) document.write('<br/>');
</script>
-->

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
</div>
</div>
<div id="divtuto">
<h3 style="text-align:center;">AlgoScript: a multi-platform development tool for javascript</h3>
<table>
<tr><th>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFn0lEQVR4Xp2Qe4xcZRmHn/c7Z3ZuO9vZW3e73bSFtlto2i5aWRZK0UZbLTXUYEktW4iKQgy6a21qYiAE/wBNiFUk/qd4wVtTQzSYEAxFGosp1mgF6lrpZblIpXSuO9dz+V5nZmcbSBog/nKe8zsn53vPk7y8W4av+7Oz8uP/umHT58/et3Xq3C+2f+P8k5/c99/fbr7rzCOj257+7MC67y3iPWK4RBaNH+1Y+6mXJ1ePLTs1ccfQs7vvHPzm5FTvrfumej6xd6r3pi/cPfTl274y/uiWiYmZ0e1PHewb2bf2fQsWbzyxevHKRX+58dMLH578Uu+yzR+OM3plhKFFDukeQ2+fw4plETasj3HHrgUdd05dv2Ps5j3HBkcfui/Ws8l9V8HAtS9cNzySPrLzMz3rrlkfVYmJVhDK2mjbhCZUtNFAVUSHh13dvSPd8ZGdn7u/c+mtP3NT47FLCrpG/zbSvTj9xLatnd3pXoeSipRCGijNLgZIwW81sxYpWWmdaVIzwg3jMdmwbfuujoU3fVeilzvvEHQsf8pxksnHrt+Q6HHihkIoFAIYTigj8ZB6pUy+FlD0oRg0EQr2bYSGohWuWhtl+fjtd0l8zS3vEEh04PbLRjqvjqaMZn3RXCBk/FBH0q4u6ezgY4OdusJ4WswVNFsJKPmqJR8KoWjOGs2FQmNGCwE62pAkLpt6AGdh+qLATcT2DAw6ZOoiGa9BYMgGIqFFAoVQRZank7J1KCULqkVeeD0r03mf18oqGV8kExoyvpELnkjjYnjFyOUm+aGbAdzIij+t7uqLr6kq+DWIeoLrG2oFH89CREFEQSHmGrYs7WFswOeJMwUOZ1zKksKxDq4v1OtC4EFXj4PTu3mHnX3m565E4hs74kLeA+qiVA1+SeiKaCPMRVFEmX9PRyM6cWUfG/M1/fGJLH/MxAnrMU14Aj5Yg3Z0X/0B/2zQZTBmpa9IwaMpkbfqIrVA8AIEVNoSARFpMf+uDC+IyT3X9su3Pij0a1bOVwLJe1CsqziJwX4k2mewuW4L6lvwVVQFDSx4vqpVVFHmqgE6d2/3/Mf1Q0m+89Eu9UoXtBpALVDFcQ3ipFysV1ZF2v8R2oOh5eKzImIFRGFOIvMLE0XIlqr6g0P/FqQbtL1Qay0ahq76xVdtoBBYaLe1SmBgfjuqXIzOt0LVC/jV0dM8erxIsWMpJhqHoocNFFvLldBKwdjyiWN+TVHPghdC3WI9xQ8F1Sag0Grb7sAqTx4/y8RP/8oPZzqpDFyFcdOIr+CH2Lri5/9xGjTfEDx31Cvk3rQ1C7VQpRoolQDPl/aaQRW1bY6eOscXH3teH3pRyfSPapAaUhs4UAmVagv8imqQ+cMRoGi0dKjuvXnoJ/6sQjkQSr4w62Mbz1ZpWSwiJ9/IyVd/fUy+frjAmdQaCdLLqGpMvJq2zktzrjlTDqlls2Wb//1BwDcAYeZ3+yvnL7wVFkNah4tNQv7+SonXM2Xuffw4ux9/jedZhdc7QpkkpbqDV7ZQ8Bt4UPRbs/WCpXbmkd9gS8cBhHZM966dqXUP/DI5GBHpjkDKxTolrJSQ3n5MKg2uAwqECvUQKgFSDqDotUTehYDiy8+drJ+87RYIXwJwacfOPnuwNL1/BNl7f8KqmMCKSSYwiZRScoW6hxoBUAms4FmlFgpNwayvXi6U2Znp/9RP3f01CKdpR3h7nH7HLNgymVh174OJ/kTMTRkk7ihRR3ANGEBRQhX8lmBu53nV8szhf3qnJ/di888A/qUFAKbTSGTJeGR477djizdtiKYccWKCici8AA0V64FfVmqZc4XazMMHbPbA98GeBELeXyIJoldscQb3/Ch6xYGXEuuP5ZLXTNeTYy9W4uuefiOybP8R03Xjg0h0DOjk/4+4wAJgCbCqzVKgG3B5j/wPFVAowDGOz14AAAAASUVORK5CYII=" id="MemExec" class="fleche" alt="Exec"/>
<!-- <input value="&#x2714;" style="color:green;" type="button" class="fleche"> -->
</th>
<td>
Execution
</td>
</tr>
<tr><th>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFsUlEQVR4Xq1VaYwVVRb+TlW9qrd1DzS22DsD3awSbOxhSTDMoD80LkggxgkxmExmEpZB42SAQSXqgE0i9g9+KG6hwz/XSVxiTIuMYRlIBjrQAWdCQpOAo92v19f9qurVdubcevUI/0yMJ/n63q5b733n+86550FFk+CB9nbCLxQ3Ll9GM0BQUV/doPov5gu6BGsEawX3Cx4UPCJ4XLBB8Kh6lpytTd5dIVgkaEQSXUhY6oDZrfn820s6l3fVNzRwzYwZacuyUrpuaLqha4Zh6AJNl5UICPwgCoIgDH0/DAI/CsMw8svlYKpYLI8VhqP/XBoYvDYysmMYuIgkNvXsfZ5LRZvtKZd/Vnge22Oj7I6P8dGD3QzgXSxeVGckBHc2z5mLbE0GZSfgcydOUuHHH+CVHbglG4HnQVKFZAvmCLqmQ5TB0HWYlgUrnUauJo8l99yDho75aGxphkQGxanaKsHMbC4HFZOjI7T/me08MDAAAyAP4ABABJCAIaEBJGAdQCrZ18jnD7z5BgkBm6ZJOcAqTU+ZMYEBZNOZDCRY04g+OnMW4iWmJiZgl0qipIwoDJT3AEeQekDTNeiyZrNZ5PJ5ZHNZpEUJQk/OdMjOKNlOOiZY17Ggftbs2YhC4KUdWzH/7qW085WX0QCAPZ8IXMlTSzqOWYEUGSKWJSSpNKTQQBQRJAggMJPGzO919x7b2DyvHYXhAnzbwcmPPuA9Tz/NY0MFkEbs2DZz6IN9nwPHYfWO59jsuy4HXlmRsQjnSAhjZgL0hMD46+anNgSBN9NKZyLJgkyR/pc//QFff/4FdmxYj4O9vWhta0Xv4cO4cOZfFcu8stjlxxaJ3wILS7uWY8v2bYjFguI6iRrNuHr5Us1rPYfww5UrVBwbpdqaZUgT0UMrV0A/8U/s2byZXjxyBKOibvDqVfI9DwrS+6Q6KZUylUq6Y3Y9wFFFAKFKQIZlWnpdSuei71Iuk2F3cpwK45Ncnp7GqoWLaPrkKe7etQvH+vpo+96/see6quAURZGyBaRrZJkmm5aJsuuqujBJ6IpDYEwXp2igf4CHbw4Bno+yWKCgfDaCAIPjRdR1zoqzI2YAgqTQTACpVSGKgORcyBECEQgwHMn05rVrNHTze56eLFI2lcIM0yRdPP7m/AVoS5fQ7gN/x6Fdu/HtV19VLPLVxROLdB2GmYJGGt27eiV2v7ofIKIw8OEAPlJmqHV0duL4xQEMej4X8nnuv3ETkyMjfPzf5xmLF6Kn9yg33tXAs+6sx5yOedzU1sqNLa1oaGnmxtYWbm5rw6/bK891TQNYNVygCAKk057x1meffth/9vzv5rTPvUNl9tz6x/Dh6dNY/fsnsa/ndcysrYVjl7Bl2zbBVgRhcMsOAkAEKCUMhiu2Aky+KHABXwh8g4ieWNPYdPj1Y8f+fO/qVazX1tDDz+6kfYcOQUXkOpTJZFBpDSIzZdzqlnhVfkcRqay58jyeXawUECIDEqf+9/3w2NAQ9GwW3UfeQCad4evyozE5MU5OqcQyKtSwIxnRnIwKknHAKTOlRgXlcnmunVGLGkkO6kb7PiQCASfDTt1yV2VGjXPn4Y8PPoS+vj5YAMqCUBAlUKElMASmwBOsW/dbvPPx++AggOs6kPCUpCrBhC3dBDkM5HDHC8/Txi1Pqb4W/20KKhcrVgHEnqthRynpOGWflbaoSUZ0FATqOaT1IVFS9t0iGBseBqJQycey+9ZgGen46QgADiHMkLThOQ4iP0RB7I4Jwiisjuv+L//xyXe2XVo0s65O+QpdiklE0DSCTpqsMZTq2GPp9XgN/MoPkdSJZU75o4UR+vb4if8ScJ2LRSYDIJUHgN8INglSibW6QLsNlKzVAobV9ba9I7AFNyQbWyw6R7g9Fsz/FRzXArOOMFZHqL6RtP2t9mQgqTtXwKpfgTBkTE2xyFKEo/8HH2I/LpzikbAAAAAASUVORK5CYII=" id="MemIndent" class="fleche" alt="Indent"/>
<!-- <input value="&#x21F6;" style="color:black;" type="button" class="fleche">-->
</th>
<td>
Automatic indentation
</td>
</tr>
<!--<tr>
<th>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABWElEQVR42u2XIUjEYBiGd8KKqO3QbBBMgvWaFoPh8iFr3rXrBsUy1LszLMqJSbQaNC94xQWTTBaGDFaG6Jr183t/dnBjisPd/v/CPnh4+creB/ZvYxoRKaUSmB0BnjWmybRLpomulADPpmmaB2EYPkdRRGWCDnShc1Jgz/f9d/t8QMONdUIGQUCjux7dHq0ixX79cEz7PR2J/d+gC52TAm3XdelpZ4s+d7dFYn+9aRA9NpBiP7lfocuXeST2QqAzJeA4Dn1cDSEgEvuXewEBpNhHb2cQQGIvQlbAtm3yPI/iOBaZYy9CVsCyLJJIVoDkzs8ChmGkmMpkr/u3QEmTTyDJMsoRuQSmKvHLdZUewkqgElAuoPQxnN0XUUfBq7iDwOhMV8HHqJt0a4vMIUkedCbd2gLTYk6ZPjMomX7S1UL3+BYsMXVmWRL1pFMfH8IaMyeZWvVvCL4BhCbDBZfU9WwAAAAASUVORK5CYII=" id="MemResize" class="fleche" alt="Resize"/> -->
<!-- <input type="button" class="fleche" style="color: blue; letter-spacing: -8px; text-align:center;" value="&#x21F1;&#x21F2;" /> -->
<!--</th>
<td>
Agrandir la fen&ecirc;tre aux dimensions de l'&eacute;cran.
</td>
</tr> -->
<tr>
<th>
<label style="vertical-align: middle; font-style: italic; font-size: 0.7em; font-family: helvetica, sans-serif, arial; color: blue">Inspect&nbsp;<input class="other" type="text" style="color: blue; background-color: white; width: 10px;" value=""/></label>
</th>
<td>
Variable inspector/construction of an execution trace
</td>
</tr>
<tr>
<th>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAF9UlEQVR42p2VCUxUVxSGZwbEJUq1riB1qTbWNi6YVsSo0RpAVmURccOtKlJFQTYHGJiRURydUkYKtHFFQKVSt6qoIKssgwi4NDpV0aQCIog4RJHl/D0zEYsUa9o/+XPve3nvO/89980dwfvktnChqPO1sXG/kUKh0Imn622sre/MsLG5NcnKpmnCnG/+4HvT2YaC/yGTCRMmis3Npxx3dHSq8vRcjm3b/HEqLQUH0o7hW1U8bL28YdDDUMXPmnZL8HRfIuyY2zo6jOFh5tChJlJrG5vnHh7ukEjCkJyciCtXziEv7xKKirKoWJ1LN8oK8V20ipbJd2HkxMmV/J7VQLMRvd6X1H34qFH7HR0cGzdu3IiIiBCcPJmK0tJ8PTQnJ53U6jxoNL/TkydVaG5+BZ0yS8vgLNkOiwWurcyIMDQyMvkH2cbe4dIGSQRWyuRITjuO0pJcKi7Opvz8DE6bg8pKDbW1taKTqLGxgV40NuBZ43Ns2hsP+y0B6D90WB7jJgm6KiBUoi2v/BOrFErsSjxMZdeu0oMHGjx7VtcB1BdgKGpra/D0aQ1ptS8Ib3Q0M5ts/YIxznJGvcjAYBUj323TV9MsU7PV16E4dgIroxRoevkSHXr16iUDn1BNzWM0Nb1AW1sbWKSzLkBDQx2q6+rhufP7tmku7jAwNNzHyFGCLlom3x2NCyVlcJPIKCXjCnSqrqnSwfH6dfPbtC0tLaivf6orqFsF2tsJOimPpZHdlkCMnjSlnnn2xoMG93nnU7ScMas8o/g6tv74E/moYkkn3kjqSMsw3txqdhU1NWnf3mfpx4fVNZgfFglLV3cwL7a7VQQnHE7Gz2cuwDksApdLSqmjRdXVjzl1rT59Z+nYnRWy7xAc/EPw8XAzDfOc2UadC4y0W+Dy4krZLSyLjKLIxGQdgKGv0dba2i20Q7crH0KyPxFLpFG0WL4b5nZOYJ6Sbda5gGioiWnSzymp+OHEGbILDkHFvfv0N5fQ1t7+ts6TZw10Or8AS2VRcAyWwGqrmJzEUvLgawffIPTpP6CCmXO7rsJ+g18g0vKKsSg8khQpxwnAO752R0OyQ0m0eqeSZm7yJ6dt4TRfLEVAdCz5yHcRt4g8tu/GWIvprczb0KNX7/6dC/T/crJ5Vsr5DGyNTWj3kMrxoLoaVXX1lF5cQp6RCnIJkdIcnwCy8g0i7z0qikk6ShcuZeLu7Tt0cP9+slrvA5cwOay8tnCbhGf5cBwv6KIgmVKFuJPn9KvwUcWRa5gMtv5icFq4hUqhOn4C6pu3UFdbi4f37iErKxdlpddRVlxEbt4+sA8MhxN7yKdj7+rb1KGE1JNCHoabW0yr+jW7ECvlCnJmoFvYdqzbuQdJZ87ifuUDZGRlY96KNTh46gwK8gv5aLnOVuNGeTmFymSY7bUZ7twmS4/lYJ5C0FV9jT+KjtybAHnisZaFDHcNlZGPMoYT16C5SQvXtV40y9uXvBTRKCpUo5zTX1OrKTcnl9Ivnqc5K9fB+js/jLWcCcOevZIF3Wiy89IV2sQLWfzp7aDFETswLyAUp7OyCQApY2Jortdmsg8Mo8ycfCq/VoLCqwVUUHCVTp8/BasF81v7mZo9Yk4K74FfdwV6mJiNOBpzJBWbo+NaXXkVLqHbaV2Ukpq0WrpZUQEL18Ww3hpKioNJ9EhzF+kXL2OzOASffz21SiAySH/zO3Bnf8ruVt6+4XLsTjpBztvC211CZHAIkiC7qBja5w0k3qWE/w/x9Mu58wjfEYVxX1vwGSTM4fdSRXxUCEUiT54P7Ja8xl8s5GHA6HHj7xz4LRO+qp/aF3GbrP3ECIpNwH2NhvLzCqGI2YsvLKY3CPt9VMjPH2Gr2AFsG/Yngg+pZ6/eay1mz61b7RsISdwBBMcfwgppFDw3+cJynkOLwYCBZQKRKFXAibnXgTzasz9j92ZzyA/LmO3Ejh48zLRi0lTLmkHDTB/3HjTkhkCoB8ext7Bt2SP1fzT/UUKjnj379jAyGvOmkJQdwd7AXsq2Y4/RJ/4X/QX99SaY+5lDRAAAAABJRU5ErkJggg==" id="MemSave" class="fleche" alt="Save"/>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFY0lEQVRIx5WUS2xcVxnHf9+5594Zj8eTTDPj+NXGKY6V2A7GUtoCxVmQPkAVlkDQbrqoKJAFUiqBWGTDigU7WLCgIBZsKhYQlRQStQVEneIWlFC1KE5wkrp+27HnYc/b9/Gx8ExtJ0jQI13p09G53//7P84RgFuvf30oCkrnkr1fOrtdWUOjAI0iospMUKHXOid+Pn7yqLy9dHvSqa9djkoLl/ASnTI08WbEf1l/u3DWefxrL4cAVlXNzd+ffrdr9AcdblsmdBOuY+MexnWBQbsw9UOuTZ6/oqr9IjK3p48W5v7040rhznhp9Z1GozhDUPy75/Z8dXp04uXvtA7JrTee+24iffJnPae+ofCGgAdEQIBGIOZ5/eAPL0kYO0JP12G262WiRgFDRPxgltiBbuIHuvFS/UCFt375LLOVR175yhNDrx4aOX9BZv/6rVLv6Lmke/AaaKCgrQFBFNWEiP+khrXrYSR+JLYmjmcIg7xWN27bxtaaqRfntLw2jeNlBXssSGQesbn5Sfyuc/+wQWU16R5sU6UsIh4K8jE9BJEaeH+U1Q9esX45AFKqUUI0aqMtfZx4+hSZ4wM8+LnjIC7kJi2HTuuNd3/F3PrMo1bEAgURFVQVMQawgMsOls+tSz+iPfMifZ99EeMoxu0A2oA6UAMaaPgR6niwfBlz6LQU8ysa9fVgnfYB8MugISKGsJSjmp+nWliiVlwmqPm0H36BnlMvAbNNbuuAok2yoiASAiF4KWCBQq1dstlswwb1FajXWbt+mdz8h3jJY7Slh4ilRukcGsVNZHFTKeAqqgYRQRVE2LVLAI0AFzEOjc0bNOhCVX5tVSNqq9PklvIMPfuO7NAuNqmXm1OHqDot83c9ElBtRUIFLIihsTWLbw5TLNUvWe/AAH55nQeOPAPcUeXfIjjNsZrfbs8dZUBo5k1agSNScATHoVa8SZ0sA0cOYdXfpB6UUO8B4K4IVRSzy7xZ7FFkT8r2gKCiGMQ4bG/d0dAMykB/xrGIy3ZllVhqEKirRr6A+biL7N4K9pSyrwBQVXEcIdhifaMgiY4MnZ3ZwMZSAxpVruO1JSGsQBCqcP8Tc4+nuo/KDsCOfEGJXDEUcBatG3/balhlK/cvSR59Cvy6EviiyP6f72GwN0Syu4cggr/JRt5HbOKGiOQtGoao2liyF7ZXIArune3/WtKEICizWQrIfqrHAtjKzZ98GRN/U7QG2xUR3YmJ3i/L/zAZAQP+FoVN4eGefgBs1W8c9OtrODYOvt+kL/u0v1ctuQ9EETGKa6VSrRFKmkwmbQBs6FcCMRYbT2uUL4lx2rT14DXvkewxVlpSgyhiwBgR60F1Q4LCDOur7wdO/IxNpPp+CmBt5gx+8Sr4JfAbSmT3S6JNwYxFjAcYJaoIVPBLa7Kyshguzs0E86vbulI9Gi/oF23fwJnoRL/76sWLF43VqEGsvQsiXyQIFQ1ExOwMakQwDhARlpelvDlHvbzE9GyVD1ddWdtM0LDHnLbMM062/wQZL3ZhOJueeuqJx39z9uy3mZiYiKziYL0k+GUkigliINyEaIt8bpmFxflgcXVDl3JedDcYizXcJ6U91Us82/nPsdOfiXV3d782NtJ3XlWTIlJueXPlyhUZHx9Xm+h+2iP3Go31a7q5+Ge5WyjrzLIjs+sJtoIHsR1P20RmjIcee5iOMPr+8GBfeXj4xJy1zuv7YrqnOcD4+LgC2FSHd3thqYNf/Paq5PwxTPKktLd3LKc/fWT6C8NDtqd/8HsPZeQ9VRUR0U98PwB+N6mPhfm3vmklvPT5Rwdjh7v6/iIiG61DU1NTTiqVikZGRj4xwH8AiTZ+be0Tvg0AAAAASUVORK5CYII=" id="MemLoad" class="fleche" alt="Load"/>
<!-- <input style="color:black;" value="S" type="button" class="fleche" />
<input style="color:black;" value="L" type="button" class="fleche" /> -->
</th>
<td>
Save/Load a script file
</td>
</tr>
<tr>
<th>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFIElEQVR4XnWWTYhdZx3Gf8//fc+5d27SzCSd6dS2ZmBI8YNWrBWFunBR0k1BFNyo6M7uunAhVgU/QIS6aENBEVFXgq66EFxoJF0FY0JFK01RkoY0M0mbzMzN3Myd+3neRzKXCwHJAw/vjwPP84f/ORxebW5ulsiVpuOhm94tclWLSAZACGQQmrMAJMCzgxkDLo2a8cj5yEMIy7ZzpEqj/i7Nu+d11ANadQtSJUWAEkQSERxYdzmhA44DRpqxhG0Glu7sDMnHjhNCuTEevn1GHx7ccGd5DYb7QphI8+CMJaFk5uWS0Zxj9jyyFg4fcW6GbN9+X+0HH3XuXbvIwqVzdNYeh60NPCuY+YBBuV1IVcKNiASpLjQTDKEIrHlGqHeTI60Ftugz7BwlD3tdVRv/gdVHBAECFNIsZHKlfvdK6u11XRRdKVKWFh9cXSctPGBPjSJkidnwJG5/wN7WZVoPris7ZU92t0Vvy3QWoRSJsEMoZe11r3PtxqWf/e43p189d41RAX/3heOPf+Txz5x6bO0Tz6S6gwEijELULU93txhs76idsnNE0Az60O9BqqE0OAWKVMrUabe/88rHf3T6O7ZbnPnFkywsDfXM1y7Ae5/r/vrh95eOrKxijAJFAIW7X2PTvYVSRQapNFMY7YvpECjzF5cahZfWn3jN/kPy6z+4qMlo3bGJ//jTl/WF771ULR77JdP9H+IooGQlFCH+/QbOq5CysoQJC8bGBwOEwxSpOnS0G0dXe/zpJ0+q6a8z2d+XokPm5Mj+fv3nVy6zswGWIazqkPjvWZd33oFPHRcuziDIYIbIA6AgEihw038gckQp+zDtQ7PXgYBpVdeg0ow6UfZRqjEVXL0AF0/jFkRKAGQJqRJoIhgh2Ti00+01+9Xo7OKH9if9re29Zu/W5TLYvQU6nA5P3nwEytbu9sZo88qtlZWHV9q7G3D5nKksOkAARhnhqCRpMluRkJW4Q/Xi0z+/9Nu3T316cu5qr9/b2f3sfm+n4BKHlsrk61Cu7vT++pVX/7L+zxefep3bV05SI3LLGk6JJBmcEaQKiBFoiCWIzNrnnzuz/e2XRqvXfsWXfvwewDb36BuvCWB014dT9y23dFKpgqlRG5QEhhBSVIDGgpGIMYoxbG8cAmDti9xPPvWxBEB7oVa7gla6a0ULRRZgzVZUS6SpD8oVchhpAgAxEWD+X1AngFnxZP5ztKMVKEkwX1EdEGOQIALFBMcQADTkvmrfM2CacYAmhWgnUiUwZECpBtJYqGAJlICBAWBo7iO3WwC4DmsSiAAh1UEkAShLOFUSdZhK6IATtJcHAHru99xP8dXzDbNVNUwCSICsOkgZAc6SSK0EdYE64VqoTlDe/ZbPPvuyB9dr5WxCYABDY5g2eDy2Vp5d9vULz1FpPgBamagENrlRUtNZhFZPzkCV7MpouvmC1fomdeqSIhECDEUgg7C0gLvnl6QB1FFMkYpFK2jaRwmSstur3qif0KMLb1oVkBB1QO1G1ShRVcdIAQIkaAoUwzRg3KDxqIBAKSSgqrxbjnOzPqET7bbz8vIq/1p6nr9t7/H08T3qhSFU2VQRVIIUJgkCYZliKBZNMblAVYKJTdWYEbrZW+DvgzVWPvk87TxFN25c9/7IvPWPs4xvvEGnDSaQAAHccxoM4HttPGPKtGGvLPLYU1/moyfWcGmYXVtCMuEPtvbY7d3RLCXAAs1rxQxmLFlzngVIOeuh5SUvHa5pmiLb/h8Qv2S8gSe3MQAAAABJRU5ErkJggg==" style="background-color: white;" id="MemLock" class="fleche" alt="Lock"/>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFIElEQVR4XnWWTYhdZx3Gf8//fc+5d27SzCSd6dS2ZmBI8YNWrBWFunBR0k1BFNyo6M7uunAhVgU/QIS6aENBEVFXgq66EFxoJF0FY0JFK01RkoY0M0mbzMzN3Myd+3neRzKXCwHJAw/vjwPP84f/ORxebW5ulsiVpuOhm94tclWLSAZACGQQmrMAJMCzgxkDLo2a8cj5yEMIy7ZzpEqj/i7Nu+d11ANadQtSJUWAEkQSERxYdzmhA44DRpqxhG0Glu7sDMnHjhNCuTEevn1GHx7ccGd5DYb7QphI8+CMJaFk5uWS0Zxj9jyyFg4fcW6GbN9+X+0HH3XuXbvIwqVzdNYeh60NPCuY+YBBuV1IVcKNiASpLjQTDKEIrHlGqHeTI60Ftugz7BwlD3tdVRv/gdVHBAECFNIsZHKlfvdK6u11XRRdKVKWFh9cXSctPGBPjSJkidnwJG5/wN7WZVoPris7ZU92t0Vvy3QWoRSJsEMoZe11r3PtxqWf/e43p189d41RAX/3heOPf+Txz5x6bO0Tz6S6gwEijELULU93txhs76idsnNE0Az60O9BqqE0OAWKVMrUabe/88rHf3T6O7ZbnPnFkywsDfXM1y7Ae5/r/vrh95eOrKxijAJFAIW7X2PTvYVSRQapNFMY7YvpECjzF5cahZfWn3jN/kPy6z+4qMlo3bGJ//jTl/WF771ULR77JdP9H+IooGQlFCH+/QbOq5CysoQJC8bGBwOEwxSpOnS0G0dXe/zpJ0+q6a8z2d+XokPm5Mj+fv3nVy6zswGWIazqkPjvWZd33oFPHRcuziDIYIbIA6AgEihw038gckQp+zDtQ7PXgYBpVdeg0ow6UfZRqjEVXL0AF0/jFkRKAGQJqRJoIhgh2Ti00+01+9Xo7OKH9if9re29Zu/W5TLYvQU6nA5P3nwEytbu9sZo88qtlZWHV9q7G3D5nKksOkAARhnhqCRpMluRkJW4Q/Xi0z+/9Nu3T316cu5qr9/b2f3sfm+n4BKHlsrk61Cu7vT++pVX/7L+zxefep3bV05SI3LLGk6JJBmcEaQKiBFoiCWIzNrnnzuz/e2XRqvXfsWXfvwewDb36BuvCWB014dT9y23dFKpgqlRG5QEhhBSVIDGgpGIMYoxbG8cAmDti9xPPvWxBEB7oVa7gla6a0ULRRZgzVZUS6SpD8oVchhpAgAxEWD+X1AngFnxZP5ztKMVKEkwX1EdEGOQIALFBMcQADTkvmrfM2CacYAmhWgnUiUwZECpBtJYqGAJlICBAWBo7iO3WwC4DmsSiAAh1UEkAShLOFUSdZhK6IATtJcHAHru99xP8dXzDbNVNUwCSICsOkgZAc6SSK0EdYE64VqoTlDe/ZbPPvuyB9dr5WxCYABDY5g2eDy2Vp5d9vULz1FpPgBamagENrlRUtNZhFZPzkCV7MpouvmC1fomdeqSIhECDEUgg7C0gLvnl6QB1FFMkYpFK2jaRwmSstur3qif0KMLb1oVkBB1QO1G1ShRVcdIAQIkaAoUwzRg3KDxqIBAKSSgqrxbjnOzPqET7bbz8vIq/1p6nr9t7/H08T3qhSFU2VQRVIIUJgkCYZliKBZNMblAVYKJTdWYEbrZW+DvgzVWPvk87TxFN25c9/7IvPWPs4xvvEGnDSaQAAHccxoM4HttPGPKtGGvLPLYU1/moyfWcGmYXVtCMuEPtvbY7d3RLCXAAs1rxQxmLFlzngVIOeuh5SUvHa5pmiLb/h8Qv2S8gSe3MQAAAABJRU5ErkJggg==" style="background-color: red;" id="MemUnlock" class="fleche" alt="Unlock"/>
</th>
<td>
Lock/unlock a window and split the screen in two parts.
</td>
</tr>
<tr>
<th style="width: 100px">
<span style="color: black; font-size: 1em; font-family: helvetica, arial, sans-serif; border: none; font-style: italic; font-weight: bold;">Code JS</span>
</th>
<td>
Name of the current window
</td>
</tr>
<tr>
<th>
<img id="MemLeft" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFbklEQVR4XoWWbWhcxxWGn5k7d+/X7upKkVpJtqQlTeK2ckiM21LSpAqllJi2VIGWkoTAKhBsXNxa6EdJi6FqQKENqdxAmxIokmnaUhOKTNvgxk0V4aqOiymJK5zUkWXVlhTbsqJdaT+k/bi349sLYkkdn+Fh5s993zNnz3BW8GHxND6Cfk2fJhMhAcF8zJRmgiFy3CT+v8FwJDza6rZlv9T1EN2pHnb4HycMQ01AQMi/197mUvESr107wUrl+jiCQQ5+0Eh+UJx+z/QuPtm7L/vcfT/lwc4v4MsWZq9d4N3lWc4v612fk6HPfa0P8PTdz/B4ZiDrKvciz9P/4TcYJtud7hn73u5DGEJxeXWR9Y116mGdAL3CG4REZ8JoeZZLd3MXdao8f+EnLJYXBjjAeOMN4sxviD+lxTcqm5y/Nsvaxhq1sKapUwvqlMpl8qt5CoUiNfQSNVYreWaWz7FeKbL/joNsc7eP8TP6Gw2G8XVZIvFNLX5pdYFKvbIlrvfCegFVknx15x66nU5yKzmq2qAqa5TZ5N38HGvVAnvvOIBjuGP8HH/LQDD66I7HfSUUi/n30CWJCaK9qDNuMXwOP/FjHnngGzzz2A9JKo9yfYOqoU1UBHOFeUIJX9ne7wOjAArdiq1OW/b+js9z4foc1Xo1Eq3FJqVCidtkMyOP/gDP9ogDx7XJyQKGCSEhAPpLzhfnuLdtNyeuHs/mXnh/UCHo163IZn1T13ydrcyDWNxn5DEtbm2Jv/zWMU5dOUO9A8gLhCAOUFLR6raw67ZPMXnl1X6FoE/3OSvF9wn+JxxnXozFhxvEj5z5LU8c/RaGKZElAykEUp+Fq8+ujN6KsSRpsl2APoUgox9R1Nt1As1WWRoyj8m0dDG57w8gBAIAweX8As++fpil2lWEKykFRT7p7QDIRAZRf6OJ94WlRZ77zkijeEzf7ffTGBCE4Ns++44fwGxO4Jg2lmnGBpLoWvED4l9XzvHGxdOUqmVuFWFI9F1NO4DESzgkbIukcrBUAgQoBPMhYUbLMzl7kvOrF8A3ePgXjzA59Aq+00Qc5DfWePEfYygpkcLQSIQQgODozO9obm9C2gaecnDMBMC84FnGhnq/mz079w4nZichISII4N6WnUzu/2ODydGzv+epPx/C9R1czyahhUxDYXkJlKuiJumw2qlUKrz09pFxhWDq5OW/ZZtEG0ihAQwgKXmzco4vvvg1Xtt7jCa7iXoQ0t/7MGDwo+kRmjt9nISFpUyUoQCoBwE9yS5OL54GmJIIJmbKb+ImHFqTLZEJxg1AapOZ6jvs+eXXWSnlqdVDarWAh+76Mp/u/AxWYJKyXZrcJL6m2UuxLdWOb6c5tfR3gAkBwChju5zPZltlO68vTFM1a+BKjISMfiyrorjH7uU333wJ10yxtrnO0Kv7UV3g+2k8y8E2TQyh6DJ7mP7PG4y9dWScvQxIAASDM5V/5kzTYGf7J0ASIYSIMFKKWebYc2QPh0+NcuCVJyla63hJFzdhk3JcfC/NnemPYUqDo+dezgGDWwPnILkqlYHp0l/pSH+UXe33YBomAEKgEShtUusI+NPyMcptJdLbUijDwFQqas/bvQwplWR4aoRitTjAXnKN8+DbTOSD1YHp9b/QkWrjwe2fo9VuaZxOSmA2JZCWQQgRrvToUhnCimTo+PeZW53X4kzcfCbrYWHKxNjd/m6/J30ntbDK8uZ1NsIynmWTtF1Sms5UOz2p7fhOmjPvneFXZ3+dK1SKkfgth348LEZdM5m9K91Lm/MRutLd2GYCx7SwExZXy0tc31jm5OWTrJRXxoHBuCzc2iCGF+K/LdAHZCIEAPMxU8BEo3Bj/BetLUN6Xm6xxwAAAABJRU5ErkJggg==" alt="Left" style="color:black; width:24px; height: 24px;"  class="fleche"/>
<img id="MemRight" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFmklEQVR4XpWWa2wcVxmGnzlz2dmZ3fXYu7Zcrx2vU0JCE9RtE6hUKpFeKBdREVSJIkpJoiAigtI4lYra8iN2VcqtwaXQBKGiGghtfyBcEVEBaZs4baBRabKhBcVp4qwT4viyTnedXdu7s7PDzFEdoaIo4T16debX857vO590hivqMbJ8lz4eZ4jvsZ8fBP4hQ/yIPp4gyxWkcDk9yoaYEduRbb0xs6L5IyTNFF32Enx8zlTyFKrTjMwe51gpl694lX62M3h1Af1kUXj2i9fenb2z6zMYIsLFapm52hzlYG/4PlYkSkSLYBs2VX+BV6f28ceJvTkUNnI/ucsFSHib1bZ/6/XbnbTdyXS5wPTFAq7n4tEI4NKyiuALIQQpO0kqlmKiOs4z+Z8XZ2qFW9lK7oMBEp5J9Ox/aM13HBqCsQtjzLsLeBLqyb26UJVg1dQuhfgKGKrO0mQGhM/OE98vzrhByLdkCAIJxwn6PbRp5TckfLRw+n24J+16dQrnpkl4MZq8OIXxaWq41IWHK+qU/Tn+OXMc1/f4Ws8mx1KtIXbhXKqAR+kLer7jru51HJ88Qc2rUZdwacqzZT7esZptn98CwL63X2Xglaex03EQyCrARxUq17etYv/kPl6e+FM/W+gTAEHft63ruZvx2fP/A68rgRt1Wp0ki/rUR29j2x1bKE6+h6vWqeseruaxIGqcqoxxa/pOolp0G7txBI+xIRhFp+pVmSlfwPsAPFy+Aa+ffINytcKiPr3qdh64bStn82cZLY0xuTDFTO0CI6V3Kbolssk1DrBOQ+GTN7auoThfeh/ckBNTKc/h1mt4osGCv8BrkyPc9Yt7GPr6b3GiTQB89ro7KMwX2Ly3F7VdB6EAPjW/hq3HCNlhQGa5s4LRQp4GcjFbKNEWTXHTqjVU6vOMV87zse7VoMLw6CG+sPJzLOq+1V9GVQVbX3oQrd3AF1DxKixzlgJkwgAnnO16w710+lKxyDObfoZt2lyNvpL9EucvTvCTo7tQW3V0TSWi6wCOrMD3fRqEbnD6vTGGTx2U8P9HPS3dWLqJbkawNZOIZhCyNQQ5H39tWMXI1LscGDsEeoONg99k/S33ggKKoiACh7tjNrGy/Tr+WycKJ3jyb0/R0uGAoWCrUUzDAMhpKBTPVMY4WzzHgdHXQVcgpTL4r+cZHHkBoQl0VQ0yNVJWC7/76gtU3QaLOnnhJA/8uRdriYmIqIQHvSbSzqxbBCiGAcMHzx1cp5RNEAoIQAcSKoqpoGoamqfRXE6w557n6GlezlzNAwjaeYodw98m3m1hWAaKAl6jQafdwVvjfwcYFii8mJs9QlM0QSrWIkOkVeQuhEDU4L4bNpJxljNfa0gfD9rZ99pDxDM2zc0JHCsWOE463k4q2syx6RzAiwoAAzz7Cev2DdQ1Do0fBlMBS6AaAkPTicxp3Nuznt6bHwbgTOkUT7z5CE0ZiyYngR0JL1WXd5TWuhgtjLHz8MAgm9koAFDoz1UPF5usGKvCCxRIK4SXK1DjGn8Z3cvuN3fyy6NP8fhfH8Ts1LHjloQnojbNdoJliQ9haVF+886eItCPxAD0kq9Q3v5O9QjXtmRYkVyGlJwgELqg1uby0uTveXnmD6idQvZcUzVZYdSIkLG7Sdsd7Hn7eaYq09vZTP5SgNT9DJ5xTw8enXuD5UHALemb5GkWpWgKWouOkYzIQAWkDUWnU1+Cozbz40M/5ZXRA2FrBi//ZD5Nb5PePHBD8mZazCQT81OU6kU8pY6qKcRNi9ZYC+2xVrriHYHT5Eun+fU/ngumKh+e/MkrP/q7yAID11hda5cmPkza7iIeiWHqBqYRIapHUESDc3P/5sjEW+Qmjx0AQnju6v8qAHbLoPUorI3piWzCSMixvejOUqoWc0AI/pUEX0b/AfE4VpRFbkl6AAAAAElFTkSuQmCC" alt="Right" style="color:black; width:24px; height: 24px;"  class="fleche"/><!--
<input class="fleche" value="&#8678;" type="button"/>	
<input class="fleche" value="&#8680;" type="button"/>
-->
</th>
<td>
Navigate through windows
</td>
</tr>
</table>
</div>
	</form>
<div style="visibility: hidden;" id="weboutput"><iframe id="frameweboutput"></iframe></div>
<div style="visibility: hidden;" id="credits">
<h1>Developer</h1>
<ul>
<li>J&eacute;r&eacute;mie Bourdon</li>
</ul>
<h1>Contributors</h1>
<h1>External libraries</h1>
<ul>
<li><a target="_blank" href="http://codemirror.net/">CodeMirror</a></li>
<li><a target="_blank" href="http://jsbeautifier.org/">JS Beautifier</a></li>
<li><a target="_blank" href="http://codebase.es/riffwave/">RIFFWave</a></li>
</ul>
<h1>Known bugs</h1>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
</div>
    <script>
      var editor = CodeMirror.fromTextArea(GEBID("lecode"), {
        lineNumbers: true,
        matchBrackets: true
      });
    </script>
<div id="filebox"></div>
<div style="display: none">
<textarea id="Libraries">
Examples/Demos.js
--------------
// Appuyez sur la touche exécuter [>]
// Indentez votre code avec [Indentation]

// Voici une petite visite guidée en attendant...
// Quelques exemples
// Se placer sur la fenêtre CodeJS
MontreFenetre(0);

// 1] Utiliser la bibliothèque graphique
// Aller directement sur la sortie graphique
MontreFenetre(2);
// Effacer l'écran
Initialiser();

// Lui donner une résolution indépendante de la taille de l'écran
Viewport(0, 0, 600, 400, 1);

// Quelques Rectangles
for (var i = 0; i < 20; i++) {
  var x = Hasard(600);
  var y = Hasard(400);
  RectanglePlein(x, y, Hasard(600 - x), Hasard(400 - y), rgb(Hasard(256), Hasard(256), Hasard(256)));
}
// Quelques Lignes
for (var i = 0; i < 100; i++) {
  Ligne(Hasard(600), Hasard(400), Hasard(600), Hasard(400), rgb(Hasard(256), Hasard(256), Hasard(256)));
}

alert('Quelques dessins\nContinuez la démonstration');

// 2] Utiliser la bibliothèque graphique via la tortue
Initialiser();
Viewport(0, 0, 600, 400, 1);

// Placer la tortue au centre de l'écran
Deplacer(100, 100);
for (var i = 0; i < 5; i++) {
  Avancer(100);
  Droite(720 / 5);
}

alert('Quelques dessins avec la tortue\nContinuez la démonstration');

// 3] Utiliser la bibliothèque graphique pour tracer des courbes
var data1 = new Array();
var data2 = new Array();
for (var i = 0; i < 360; i++) {
  data1[i] = Math.sin(4 * i * Math.PI / 180);
  data2[i] = 1.5 * Math.sin(6 * i * Math.PI / 180);
}
AfficherCourbe(data2);
AfficherCourbe(data1, true, false, '.', 'green', 2);

alert('Deux courbes\nContinuez la démonstration');


// 4] Utiliser la bibliothèque de son (sauf sur smartphones et tablettes)
MontreFenetre(-2);
// Charger un son à partir de son url
var unson = ChargerSon('http://dl.dropbox.com/u/1961350/jazzy.wav');
// Jouer le son
unson.play();

alert('Attendez la fin de la musique et\nContinuez la démonstration');

// Créer un son de toute pièce, par exemple un LA (440Hz), fréquence d'échantillonnage 11025Hz
var data = new Array();
for (var i = 0; i < 11025; i++) data[i] = Math.round(128 + 127 * Math.sin(i * 440 / 11025 * 2 * Math.PI));
var unautreson = CreerSon(data, 11025);
// Jouer ce son
unautreson.play();

alert('Attendez la fin du LA et\nContinuez la démonstration');

// 5] Utiliser la sortie HTML
// Aller automatiquement sur la fenêtre de sortie HTML
MontreFenetre(4);

alert('Continuez la démonstration');
HTMLoutput('<h1>Venez voir ce qui sort sur la sortie HTML</h1>');


alert('Continuez la démonstration');

// Taper maintenant quelques lignes d'HTML dans l'onglet "Entrée Texte", elles seront affichées par la commande
HTMLoutput(texte_a_etudier());

alert('Continuez la démonstration');

MontreFenetre(-3);
Ecrire('Allez voir sur le Memento pour d\'autres démos !');

setTimeout('MontreFenetre(-1);', 1500);
------------------
Library/libTALN.js
------------------
function code(car)
{// renvoie le code du caractère car
 return car.charCodeAt(0);
}

function caractere(c)
 {// renvoie le caractère dont le code est c
  return (String.fromCharCode(c));
 }

function ordre (a, b)
{ // renvoie un indicateur d ordre pour le tri du tableau
   var t1 = a.match(/[0-9]+/);
   var t2 = b.match(/[0-9]+/);
   return (t2[0] - t1[0]);
}

function majuscule(car)
{// écrite pour le français, l allemand (sans ß) et l espagnol
  if ("éèêë".indexOf(car) != -1) {car = "e";}
  else if ("àâäá".indexOf(car) != -1) {car = "a";}
  else if ("îïí".indexOf(car) != -1) {car = "i";}
  else if ("ôöó".indexOf(car) != -1) {car = "o";}
  else if ("ùûüú".indexOf(car) != -1) {car = "u";}
  else if ("ç".indexOf(car) != -1) {car = "c";}
  else if ("ñ".indexOf(car) != -1) {car = "n";}
  return(car.toUpperCase());
}
------------------
Library/libRS.js
------------------
//Ne pas modifier la suite
//Bibliothèque de fonctions pour le TP RS

/*Remplissage de la table*/
var aime_bien=[
[true, true, false, true, false, false, true, false, false, false, false, true, false, true, false],
[true, true, true, true, false, false, true, false, true, true, false, true, false, true, false],
[true, true, true, false, false, false, true, false, true, false, false, true, false, true, false],
[true, true, false, true, false, false, true, false, false, true, true, true, false, true, false],
[true, true, false, true, false, false, true, false, false, true, false, true, true, true, true],
[true, true, false, true, true, false, true, false, false, false, false, true, true, false, false],
[true, false, false, false, true, true, true, true, true, false, true, true, false, true, false],
[true, false, false, true, true, false, false, true, false, false, true, false, false, true, false],
[true, true, false, true, false, true, false, true, true, false, true, true, false, true, false],
[true, false, true, false, false, true, true, true, false, true, false, false, true, true, true],
[true, false, false, false, true, true, true, true, true, false, false, true, true, false, true],
[true, false, false, true, true, false, true, false, true, true, false, true, false, false, true],
[true, false, true, true, true, false, false, false, true, true, false, true, false, false, true],
[true, false, true, false, false, true, true, true, false, true, true, false, false, false, false],
[false, true, false, false, true, false, true, false, true, true, false, false, true, false, true]
];

/*Remplissage de la table des noms*/
var noms=new Array ('alice', 'bob', 'colin', 'denis', 'eudes', 'francoise', 'greg', 'henri', 'irene', 'jean', 'kamel', 'lauriane', 'marc', 'norbert', 'octave') ;

/* Quelques fonctions basiques*/
function a_pour_ami(i,j)/*résultat est un booléen*/
/*retourne un Booléen indiquant si i a j pour ami*/
{ return(aime_bien[i][j]);}

function jolie_phrase(i,j)/*résultat est une chaîne*/
/*retourne un message indiquant si i aime j*/
{ var message;
  if (aime_bien[i][j])
     {message=noms[i]+ ' aime bien '+ noms[j];}
  else {message=noms[i]+" n'aime pas "+ noms[j];}
  return message
}

function prenom(i)/*résultat est une chaîne*/
/*retourne un message avec le prénom numéro i*/
{ return noms[i]}

function tous_les_prenoms()/*résultat est une chaîne*/
/*retourne un message avec tous les prénoms*/
{ var message = '';
  for (var j=0;j<Taille(noms);j++)
      {message=message+' '+noms[j];}
  return message
}

function numero(prenom)/*résultat est une chaine*/
/*retourne le numéro correpondant à prenom*/
{ var le_numero=-1;
  for (var j=0;j<Taille(noms);j++)
      {if (prenom==noms[j])
          {le_numero=j;}
      }
  return le_numero
}

function amis(i)/*résultat est une chaîne*/
/*retourne un message avec tous les prénoms des amis de i*/
{ var message='';
  for (var j=0;j<Taille(noms);j++)
      { test=aime_bien[i][j];
        if( test ){message=message+' '+noms[j];}
	  }
  return message
}

function compte_amis(i)/*résultat est un entier*/
/*retourne le nombre des amis de i*/
{ var accumulateur=0;
  for (var j=0;j<Taille(noms);j++)
      {test=aime_bien[i][j];
       if (test){accumulateur++;}
	  }
  return accumulateur
}
-----------------
Library/libBioInfo.js
-----------------
function ElementTableau2D(T,i,j) {return T[i][j];}
var TabExo30=[10,35,82,60,80,105,100,120,146,122,151,133,146,140,112,87,95,58,41,64,20,15,41,30,44,84,78,82,94,158,140,150,142,171,160,198,159,216,200,196];
var TabExo3=TabExo30;
var TabExo31=[[1,15],[8,3],[21,38],[24,18],[50,94],[55,68],[58,76],[61,68],[63,70],[70,47],[77,65],[80,57],[85,67],[98,53],[108,102],[132,54],[135,60],[153,25]];
var TabExo4=TabExo31;
var TabExo34=[[0,0.04],[0,0.02],[30,0],[40,0.02],[80,0.12],[100,0.08],[120,0.06],[120,0.15],[140,0.16],[150,0.11],[170,0.17],[180,0.12]];
var TabExo7=TabExo34;
var TabExo35=[[7,5.5],[8,9.9],[9,4.2],[10,8.7],[12,10.7],[13,15.1],[14,13.9],[15,7.1],[17,13.7],[18,18.1],[19,11.3],[19,21.4],[20,15.7],[21,19],[23,17.7]];
var TabExo8=TabExo35;

-----------------
Examples/Mandelbrot.js
-----------------
Initialiser();
Viewport(0, 0, 300, 200, 1);
HideTurtle();
AfficheGraphique();
Mandelbrot();
DrawTurtle();

function TranslateX(x) {
  return x * 3 / 300 - 2;
}

function TranslateY(y) {
  return (y - 100) * 3 / 200;
}


function Mandelbrot() {
  var i;
  var j;
  for (i = 0; i < 300; i++) {
    for (j = 0; j < 200; j++) {
      var macouleur = CouleurMandelbrot(TranslateX(i), TranslateY(j));
      var chcouleur = 'rgb(' + ((macouleur * 4) % 256) + ',0,0)';
      RectanglePlein(i, j, 1, 1, chcouleur);
    }
  }
}

function module(x, y) {
  return Math.sqrt(x * x + y * y);
}

function CouleurMandelbrot(a, b) {
  var i = 0;
  var x = a;
  var y = b;
  do {
    var tmp = x;
    x = x * x - y * y + a;
    y = 2 * tmp * y + b;
    i++;
  }
  while ((module(x, y) < 2) && (i < 50));
  return 50 - i;
}
-----------------
Examples/LSYSTEMS_anime.js
-----------------
Initialiser();
Couleur('green');

var ch = Lsystems2('F', [
  ['F', 'FF-[-F+F+F]+[+F-F-F]']
], 3);

var t = 0;

function UnCran(ch, t) {
  Deplacer(0, 0);
  RectanglePlein(10, 10, 500, 350, 'white');
  Deplacer(300, 300);
  interprete(ch, 10, 40 * Math.cos(t * 3.14 / 180));
  HideTurtle();
}

function Animation(ch, t) {
  UnCran(ch, t);
  t = (t + 15) % 360;
  setTimeout('Animation("' + ch + '",' + t + ')', 20);
}

Animation(ch, t);


function Lsystems2(current, regles, n) {
  if (n < 1) return current;
  else {
    var res = '';
    var i;
    for (i = 0; i < Longueur(current); i++) {
      var flag = false;
      for (var j = 0; j < Taille(regles); j++) {
        if (current.charAt(i) == regles[j][0]) {
          res = res + regles[j][1];
          flag = true;
        }
      }
      if (!flag) res = res + current.charAt(i);
    }
    return Lsystems2(res, regles, n - 1);
  }
}


function interprete(ch, l, a) {
  var PositionsHeapX = Tableau(0);
  var PositionsHeapY = Tableau(0);
  var AngleHeap = Tableau(0);
  for (var i = 0; i < Longueur(ch); i++) {
    switch (ch.charAt(i)) {
    case 'F':
      Avancer(l);
      break;
    case '+':
      Droite(a);
      break;
    case '-':
      Gauche(a);
      break;
    case '[':
      PositionsHeapX.push(currentx);
      PositionsHeapY.push(currenty);
      AngleHeap.push(currentangle);
      break;
    case ']':
      Deplacer(PositionsHeapX.pop(), PositionsHeapY.pop());
      currentangle = AngleHeap.pop();
      break;
    }
  }
}
-----------------
Examples/LSYSTEMS_Foret.js
-----------------
Initialiser();
Deplacer(300, 300);
var ch = Lsystems2('F', [
  ['F', 'FF-[-F+F+F]+[+F-F-F]']
], 4);
Couleur('green');
interprete(ch, 5, 22.5);
Deplacer(400, 300);
interprete(ch, 4, -15);
Deplacer(100, 300);
interprete(ch, 3.5, 20);


function Lsystems2(current, regles, n) {
  if (n < 1) return current;
  else {
    var res = '';
    var i;
    for (i = 0; i < Longueur(current); i++) {
      var flag = false;
      for (var j = 0; j < Taille(regles); j++) {
        if (current.charAt(i) == regles[j][0]) {
          res = res + regles[j][1];
          flag = true;
        }
      }
      if (!flag) res = res + current.charAt(i);
    }
    return Lsystems2(res, regles, n - 1);
  }
}


function interprete(ch, l, a) {
  var PositionsHeapX = Tableau(0);
  var PositionsHeapY = Tableau(0);
  var AngleHeap = Tableau(0);
  for (var i = 0; i < Longueur(ch); i++) {
    switch (ch.charAt(i)) {
    case 'F':
      Avancer(l);
      break;
    case '+':
      Droite(a);
      break;
    case '-':
      Gauche(a);
      break;
    case '[':
      PositionsHeapX.push(currentx);
      PositionsHeapY.push(currenty);
      AngleHeap.push(currentangle);
      break;
    case ']':
      Deplacer(PositionsHeapX.pop(), PositionsHeapY.pop());
      currentangle = AngleHeap.pop();
      break;


    }
  }
}
-----------------
Examples/Tours_Hanoi_Animees.js
-----------------
var SequenceDeplacements=Tableau(0);

function Hanoi(n,tige1,tige2,tige3) {
   if (n > 0) {
      Hanoi(n-1, tige1, tige3, tige2);
      DeplacerCyl(tige1,tige3);
      Hanoi(n-1, tige2, tige1, tige3);
   }
}

function DeplacerCyl(T1,T2) {
	SequenceDeplacements.push(new Array(T1,T2));
}

var n=SaisieEntier();

Hanoi(n,0,1,2);

var Tiges=Tableau(0);
Tiges.push(Tableau(0));
Tiges.push(Tableau(0));
Tiges.push(Tableau(0));

for (var i=0; i < n; i++) {Tiges[0].push(n-i);}

function AfficheTiges() {
Ligne(50,90,350,90,'black');
	for(var i=0; i<3; i++) {
		var x=100*(i+1);
		Ligne(x,90,x,250);
		for (var j=0; j < Taille(Tiges[i]); j++) {
			var taillecyl=6*Tiges[i][j];
			RectanglePlein(x-taillecyl,100+j*15,taillecyl*2,12,rgb(255-Tiges[i][j]*30,0,0));
		}
	}
}

function AnimeUnCran(dep1,dep2) {
	Initialiser();
	ShadowOn();
	Viewport(0,0,400,300);
	AfficheTiges();
}

function Animation(i) {
	if (i < Taille(SequenceDeplacements)) {
		AnimeUnCran();
		var depl=SequenceDeplacements[i];
		Tiges[depl[1]].push(Tiges[depl[0]].pop());
		setTimeout(function () {Animation(i+1)},150);
	} else {AnimeUnCran(); Ecrire('fini !');}
}	

Animation(0);
-----------------
Examples/EffetPlasma.js
-----------------
var palette = Tableau();
var cosTbl = Tableau();
var p1, p2, p3, p4, t1, t2, t3, t4;

function createPalette() {
  var i;
  for (i = 0; i < 64; i++) {
    palette[i] = rgb(4 * i, 4 * i, 0);
    palette[i + 64] = rgb(255, 255 - 4 * i, 0);
    palette[i + 128] = rgb(255 - 4 * i, 0, 4 * i);
    palette[i + 192] = rgb(0, 4 * i, 255 - 4 * i);
  }
}

function precalcCosinus() {
  var i;
  for (i = 0; i < 256; i++)
  cosTbl[i] = Math.floor(Math.cos(i * Math.PI / 128) * 32) + 32;
}

function dessinePlasma(qualite) {
  var x, y, col, pos;

  pos = 0;
  t1 = p1;
  t2 = p2;
  for (y = 0; y < 200; y += qualite) {
    t3 = p3;
    t4 = p4;
    for (x = 0; x < 320; x += qualite) {
      col = cosTbl[t1] + cosTbl[t2] + cosTbl[t3] + cosTbl[t4];
      RectanglePlein(x, y, qualite, qualite, palette[col]);
      pos++;
      t3 = (t3 + 255 - qualite) % 256;
      t4 = (t4 + 2 * qualite) % 256;
    }
    t1 = (t1 + 255 - 2 * qualite) % 256;
    t2 = (t2 + 2 * qualite) % 256;
  }
  p1 = (p1 + qualite) % 256;
  p2 = (p2 + 2 * qualite) % 256;
  p3 = (p3 + 255 - qualite) % 256;
  p4 = (p4 + 255 - 2 * qualite) % 256;
}

Initialiser();
Viewport(0, 0, 320, 200, 1);
createPalette();
precalcCosinus();
p1 = Hasard(256);
p2 = Hasard(256);
p3 = Hasard(256);
p4 = Hasard(256);

// Animation
function draw() {
  dessinePlasma(4);
}

Loop(10000);


-----------------
Examples/EffetPlasma_fast.js
-----------------

var palette = [];
var cosTbl = [];
var p1, p2, p3, p4, t1, t2, t3, t4;

function createPalette() {
  var i;
  for (i = 0; i < 64; i++) {
    palette[i] = [4 * i, 4 * i, 0];
    palette[i + 64] = [255, 255 - 4 * i, 0];
    palette[i + 128] = [255 - 4 * i, 0, 4 * i];
    palette[i + 192] = [0, 4 * i, 255 - 4 * i];
  }
}

function precalcCosinus() {
  var i;
  for (i = 0; i < 256; i++)
  cosTbl[i] = Math.floor(Math.cos(i * Math.PI / 128) * 32) + 32;
}


function dessinePlasma(qualite) {
  var x, y, col, pos;

  pos = 0;
  t1 = p1;
  t2 = p2;
  for (y = 0; y < 200; y += qualite) {
    t3 = p3;
    t4 = p4;
    for (x = 0; x < 320; x += qualite) {
      col = cosTbl[t1] + cosTbl[t2] + cosTbl[t3] + cosTbl[t4];
      
      image.data[4*pos]=palette[col][0];
      image.data[4*pos+1]=palette[col][1];
      image.data[4*pos+2]=palette[col][2];
      image.data[4*pos+3]=255;
      //RectanglePlein(x, y, qualite, qualite, palette[col]);
      pos++;
      t3 = (t3 + 255 - qualite) % 256;
      t4 = (t4 + 2 * qualite) % 256;
    }
    t1 = (t1 + 255 - 2 * qualite) % 256;
    t2 = (t2 + 2 * qualite) % 256;
  }
  p1 = (p1 + qualite) % 256;
  p2 = (p2 + 2 * qualite) % 256;
  p3 = (p3 + 255 - qualite) % 256;
  p4 = (p4 + 255 - 2 * qualite) % 256;
}

Initialiser();
Viewport(0, 0, 640, 400, 1);
createPalette();
precalcCosinus();
p1 = Hasard(256);
p2 = Hasard(256);
p3 = Hasard(256);
p4 = Hasard(256);
var image=ctx.createImageData(320,200);

function draw() {
  dessinePlasma(1);
  ctx.putImageData(image,0,0);
}

Loop(10000);

------------------
TP/Sons/exercice_2.js
--------
// LA à la guitare
var data = Tableau();
var note = 440;

// Q2 Tableau au hasard
var Decalage = Math.floor(22050 / note);
for (var i = 0; i < Decalage; i++) {
  data[i] = Hasard(200000) / 100000 - 1;
}

// Q3
var Attenuation = 0.995;

for (var i = Decalage; i < 22050; i++) {
  data[i] = Attenuation * (data[i - Decalage] + data[i - Decalage + 1]) / 2;
}

// Q4 => 8bits non signé
for (var i = 0; i < Taille(data); i++) {
  data[i] = 128 + Math.floor(128 * data[i]);
}

var son = CreerSon(data, 22050);
son.play();
-------------------
Examples/smallpaint.js
-------------------
Initialiser();
// Trace palette
var Couleurs = ['white', 'black', 'blue', 'red', 'yellow', 'green', 'orange', 'purple'];
RectanglePlein(0, 0, 50, size_canvas_y, rgb(200, 200, 200));
for (var i = 0; i < Taille(Couleurs); i = i + 1) {
  RectanglePlein(5, 5 + 50 * i, 40, 40, Couleurs[i]);
}

var CouleurCourante = 1;
MouseClick(5, 55);

function MouseMove(x, y) {
  if (x >= 50) {
    RectanglePlein(x - 5, y - 5, 10, 10, Couleurs[CouleurCourante]);
  }
}

function MouseClick(x, y) {
  if (x < 50) {
    RectanglePlein(0, 50 * CouleurCourante, 50, 50, rgb(200, 200, 200));
    RectanglePlein(5, 5 + 50 * CouleurCourante, 40, 40, Couleurs[CouleurCourante]);
    CouleurCourante = Math.min(Math.floor(y / 50), Taille(Couleurs) - 1);
    RectanglePlein(0, 50 * CouleurCourante, 50, 50, rgb(200, 100, 100));
    RectanglePlein(5, 5 + 50 * CouleurCourante, 40, 40, Couleurs[CouleurCourante]);
  } else {
    RectanglePlein(x - 5, y - 5, 10, 10, Couleurs[CouleurCourante]);
  }
}
--------------------
Play_with_clasp_nqueens.js
--------------------
includeFile('Library/Lparse_clasp.js');

// How lines generated by the grounding part must be interpreted
window.Interprete_grounding = function(ch) {
  // Do nothing
}

// How lines generated by the solving part must be interpreted
window.Interprete = function(ch) {
  if (PositionDans(ch, 'Answer') >= 0) {
    answerno++;
    Damier(n);
  }
  if (PositionDans(ch, 'occupied') >= 0) {
    var Tinst = ch.split(' ');
    for (var i = 0; i < Taille(Tinst); i++) {
      eval(Tinst[i]);
    }
    Ecrire(ch);
  }
}

function occupied(i, j) {
  DrawQueen(i - 1, j - 1);
}

function column(i) {}

function row(i) {}


// Graphical part
var taille = 20;
var nbanswersperlines = 6;

function Damier(n) {
  var decX = (n + 1) * taille * ((answerno - 1) % nbanswersperlines);
  var decY = (n + 1) * taille * Math.floor((answerno - 1) / nbanswersperlines);
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      if ((i + j) % 2 == 0) {
        Rectangle(decX + 50 + i * taille, decY + 50 + j * taille, taille, taille, 'black');
      } else {
        RectanglePlein(decX + 50 + i * taille, decY + 50 + j * taille, taille, taille, 'black');
      }
    }
  }
}

function DrawQueen(i, j) {
  var decX = (n + 1) * taille * ((answerno - 1) % nbanswersperlines);
  var decY = (n + 1) * taille * Math.floor((answerno - 1) / nbanswersperlines);
  setCanvasFont('Helvetica', taille + 'px', '');
  var color = ((i + j) % 2 == 1) ? 'white' : 'black';
  Texte(decX + 50 + 5 + i * taille, decY + 50 + taille - 5 + j * taille, Ascii_vers_Caractere(9819), color);
}

// Main part
var n = SaisieEntier('Size of the chessboard');
var answerno = 0;

groundandsolve('nqueens.lp', '"-cn=' + n + '"', '"10"');

--------------------
Play_with_clasp_sudoku.js
--------------------
includeFile('Library/Lparse_clasp.js');

var answerno = 0;

window.Interprete = function(ch) {
  Ecrire(ch);
  if (PositionDans(ch, 'Answer') >= 0) {
    answerno++;
  }
  if (PositionDans(ch, 'x(') >= 0) {
    var Tinst = ch.split(' ');
    for (var i = 0; i < Taille(Tinst); i++) {
      eval(Tinst[i]);
    }
  }
}

window.Interprete_grounder = function(ch) {
}

Initialiser();
setCanvasFont('helvetica', '30px', '');
for (var i = 0; i < 10; i++) {
  Ligne((i + 1) * 50, 0, (i + 1) * 50, 450, (i % 3 == 0) ? 'red' : 'black');
  Ligne(50, i * 50, 500, i * 50, (i % 3 == 0) ? 'red' : 'black');
}

Texte(500, 500, 'Solve', 'black')

var Tpos = [];
for (var i = 1; i <= 9; i++) {
  for (var j = 1; j <= 9; j++) {
    Tpos[i + ',' + j] = 0;
  }
}


function g_x(i, j, k) {

}

function x(i, j, k) {
  if (Tpos[i + ',' + j] ==0) {
    Texte(j * 50 + 10, i * 50 - 10, k, 'blue');
  	Tpos[i + ',' + j] = k;
  }
}

function MouseClick(x, y) {
  var j = Math.floor((x - 10) / 50);
  var i = Math.floor((y - 10) / 50) + 1;

  if (i > 0 && i <= 9 && j > 0 && j <= 9) {
    Tpos[i + ',' + j] = (Tpos[i + ',' + j] + 1) % 10;
    RectanglePlein(j * 50 + 1, i * 50 - 49, 48, 48, 'white');
    Texte(j * 50 + 10, i * 50 - 10, (Tpos[i + ',' + j]==0)?'':Tpos[i + ',' + j], 'black');
  } else if (i == 10 && j == 10) {
    var pb = ''
    for (var ii = 1; ii <= 9; ii++) {
      for (var ji = 1; ji <= 9; ji++) {
        if (Tpos[ii + ',' + ji] != 0) pb += 'x(' + ii + ',' + ji + ',' + Tpos[ii + ',' + ji] + ').\n';
      }
    }
    pb += readFile('sudokuvierge.lp');
    writeFile('tmpsudoku.lp', pb);
    groundandsolve('tmpsudoku.lp', '', '"1"');
  }
}



function val(i) {}

function border(i) {}


--------------------
nqueens.lp
--------------------
% THE N-QUEENS PROBLEM

% DOMAIN PREDICATES
row(1..n).
column(1..n).

% GENERATE
1{occupied(R,C):row(R)}1 :- column(C).

% TEST
:- occupied(R,C), occupied(R,C1),
   row(R), column(C), column(C1), C < C1.

:- occupied(R,C), occupied(R1,C1), 
   row(R), column(C), row(R1), column(C1), 
   C < C1, abs(R - R1) == abs(C - C1).
--------------------
sudokuvierge.lp
--------------------
%
% domains
%
val(1..9).
border(1;4;7).

% alldifferent boxes
1 { x(X,Y,N) : val(X;Y):
    X1<=X:X<=X1+2:Y1<=Y:Y<=Y1+2 } 1 :- val(N), border(X1;Y1).

% alldifferent rows, columns, values
1 { x(X,Y,N) : val(N) } 1 :- val(X;Y).
1 { x(X,Y,N) : val(X) } 1 :- val(N;Y).
1 { x(X,Y,N) : val(Y) } 1 :- val(N;X). 

% alternative:
% :- 2 { x(X,Y,N) : val(N) }, val(X;Y).
% :- 2 { x(X,Y,N) : val(X) }, val(N;Y).
% :- 2 { x(X,Y,N) : val(Y) }, val(N;X). 
--------------------
Library/Lparse_clasp.js
--------------------
function solve(_fn, _args) {

  var worker = new Worker("worker.js");

  worker.onmessage = function(event) {
    //Ecrire(event.data);
    switch (event.data.type) {
    case "ready":
      Ecrire("Go solving");
      break;
    case "output":
      //if (PositionDans(event.data.data,'edge')>=0) {
      Interprete(event.data.data);
      //}
      break;
    case "done":
      event.target.terminate();
      break;
    }
  };

  var filename = _fn;
  if (res_for_groundandsolve == '') {
    var filedata = readFile(filename);
  } else {
    var filedata = res_for_groundandsolve; // readFile(filename);
  }
  var args = JSON.parse(_args);

  worker.postMessage({
    'type': 'solve',
    'filename': filename,
    'filedata': filedata,
    'args': args
  });
}

var res_for_groundandsolve = '';

function groundandsolve() {
  //  if(Taille(arguments)<1) {Ecrire('Error: not enough arguments'); return;}
  var _fn = arguments[0];
  var _argsground = '';
  if (Taille(arguments) >= 2) {
    _argsground = arguments[1];
  }
  var _argssolve = '';
  if (Taille(arguments) >= 3 && arguments[2] != '') {
    _argssolve = arguments[2];
  } else {
    _argssolve = '"0"'
  }
  var _args = '[' + ((_argsground != '') ? '' + _argsground + ',' : '') + '"' + _fn + '"]';
  var worker = new Worker("worker_2.js");

  worker.onmessage = function(event) {
    //Ecrire(event.data);
    switch (event.data.type) {
    case "ready":
      Ecrire("Go grounding");
      res_for_groundandsolve = '';
      break;
    case "output":
      //if (PositionDans(event.data.data,'edge')>=0) {
      //Ecrire(event.data.data);
      var ch = event.data.data;
      var tch = ch.split(' ');
      ch = tch[0];
      for (var i = 1; i < Taille(tch); i++) if (tch[i] != '') ch += ' ' + tch[i];
      //Ecrire(ch);
      if (res_for_groundandsolve == '') res_for_groundandsolve = ch;
      else res_for_groundandsolve += '\n' + ch;
      //}
      Interprete_grounder(event.data.data);

      break;
    case "done":
      event.target.terminate();
      //window.localStorage['tmpfileforclasp.sm']=res_for_groundandsolve;
      //alert('Ready to solve ?');
      solve('tmpfileforclasp.sm', '["tmpfileforclasp.sm",' + _argssolve + ']');
      break;
    }
  };

  var filename = _fn;
  var filedata = readFile(filename);
  var args = JSON.parse(_args);

  worker.postMessage({
    'type': 'ground',
    'filename': filename,
    'filedata': filedata,
    'args': args
  });
}

function Interprete(ch) {
  Ecrire(ch);
}

function Interprete_grounder(ch) {}
</textarea>
</div>
<div id="GestionFichiers">
<span class="bonglet" id="bonglet1" style="background-color: rgb(150,150,150);" onclick="builtin_ong.style.display='none'; builtin_bong.style.backgroundColor='rgb(255,255,255)'; builtin_ong=GEBID('onglet1'); builtin_bong=GEBID('bonglet1'); builtin_ong.style.display='block'; builtin_bong.style.backgroundColor='rgb(150,150,150)';">Internal FS</span><span class="bonglet" id="bonglet2" onclick="builtin_ong.style.display='none'; builtin_bong.style.backgroundColor='rgb(255,255,255)'; builtin_ong=GEBID('onglet2'); builtin_bong=GEBID('bonglet2'); builtin_ong.style.display='block'; builtin_bong.style.backgroundColor='rgb(150,150,150)';">Mail</span><span class="bonglet" id="bonglet3" onclick="builtin_ong.style.display='none'; builtin_bong.style.backgroundColor='rgb(255,255,255)'; builtin_ong=GEBID('onglet3'); builtin_bong=GEBID('bonglet3'); builtin_ong.style.display='block'; builtin_bong.style.backgroundColor='rgb(150,150,150)';">External FS</span><span class="bonglet" id="bonglet4" onclick="builtin_ong.style.display='none'; builtin_bong.style.backgroundColor='rgb(255,255,255)'; builtin_ong=GEBID('onglet4'); builtin_bong=GEBID('bonglet4'); builtin_ong.style.display='block'; builtin_bong.style.backgroundColor='rgb(150,150,150)';">Create App</span>
<div id="onglet1">
<h1>Internal Filesystem</h1>
<div>
<table>
<tr>
<td>
<select id="internalFS" size="20" style="width: 300px;" ondblclick="if (GEBID('internalFS').value != '') {editor.setValue(readFile(GEBID('internalFS').value)); builtin_oldfilename=GEBID('internalFS').value; GEBID('lecode').value=editor.getValue(); MontreFenetre(-8);}"
onchange="GEBID('filecontent').innerHTML='<pre>'+window.localStorage[GEBID('internalFS').value]+'</pre>'">
</select></td><td style="vertical-align: top;">
<input type="button" value="Load selected" onclick="editor.setValue(readFile(GEBID('internalFS').value)); GEBID('lecode').value=editor.getValue(); MontreFenetre(-8);" /><br/>
<input type="button" value="Load as Text Entry" onclick="setEntreetexte(readFile(GEBID('internalFS').value));  MontreFenetre(-5);" /><br/>
<input type="button" value="Remove selected" onclick="removeFile(GEBID('internalFS').value); UpdateFS();" /><br/>
<input type="button" value="Rename selected" onclick="renameFile(GEBID('internalFS').value,prompt('Enter your filename with directories',GEBID('internalFS').value)); UpdateFS();" /><br/>
<input type="button" value="Save to" onclick="builtin_oldfilename=prompt('Enter your filename with directories',builtin_oldfilename); writeFile(prompt('Enter your filename with directories',builtin_oldfilename),editor.getValue()); UpdateFS();" /><br/><br/>
<input type="button" value="Export Entire FS to Text Entry" onclick="var flag=false; var res=''; for(p in window.localStorage) {if (flag) res+='--------\n'; flag=true; res+=p+'\n--------\n'+window.localStorage[p]+'\n';} setEntreetexte(res);"/><br/>
<input type="button" value="Export Entire FS to Dropbox" onclick="if (DropboxSync) exportAllFStoDropboxFS();"/>
</td>
<td>
<div id="filecontent" style="background-color: rgb(100,100,100); color: yellow; font-family: fixed; font-size: 0.8em; width:600px; height:300px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;"></div>
</td>
</tr></table></div>
</div>
<div id="onglet2" style="display: none;">
<h1>Send by e-mail</h1>
<div>
<input type="text" value="your mail address" id="sendmail" /><input type="button" value="Send" onclick="if (GEBID('sendmail').value.indexOf('@')) {GEBID('lecode').value = editor.getValue();; window.open('mailto:'+GEBID('sendmail').value+'?subject=[AlgoScript%20project]&body='+window.encodeURIComponent(GEBID('lecode').value));} else alert('Error: Invalid mail address !');"/>
<br /><br /></div>
</div>
<div id="onglet3" style="display: none;">
<h1>Load from an external filesystem</h1>
<div>
<input type="file" id="ExternalFilename" /><input type="button" value="Load" onclick="readExternal(GEBID('ExternalFilename'),1); MontreFenetre(-8);"/><input type="button" value="Load in Text Entry" onclick="readExternal(GEBID('ExternalFilename'),2); MontreFenetre(-5);"/><input type="button" value="Data file to Internal FS" onclick="readDataToIFS(GEBID('ExternalFilename')); UpdateFS();"/><input type="button" value="Import as Library" onclick="readExternal(GEBID('ExternalFilename'),3); setTimeout('UpdateFS()',1000);"/>
<br /><br /></div>
</div>
<div id="onglet4" style="display: none; color:white;">
<h1>Create a standalone application</h1>
<div>
<h2>Application title</h2><input type="text" id="name_standalone" value="Standalone application"/><br/>
<h2>Application style</h2>
<input type="radio" id="style_standalone1" name="style_standalone" checked>Text only<br/>
<input type="radio" id="style_standalone2" name="style_standalone">Text + Graphics<br/>
<input type="radio" id="style_standalone3" name="style_standalone">Graphics only<br/>
<input type="radio" id="style_standalone4" name="style_standalone">HTML output div only<br/>
<h2>Files to be included</h2>
<select id="internalFS_standalone" size="10" style="width: 300px;" multiple="multiple"></select>
<br/><br/><br/>
<input type="button" value="Create App" onclick="var style_standalone=1; if (GEBID('style_standalone2').checked) style_standalone=2; if (GEBID('style_standalone3').checked) style_standalone=3; if (GEBID('style_standalone4').checked) style_standalone=4; var options_standalone=GEBID('internalFS_standalone').options; var allselected=[]; var nbselected=0; for(var i=0; i<options_standalone.length; i++) if (options_standalone[i].selected) allselected[nbselected++]=options_standalone[i].value; var w=window.open(); w.document.write(createStandaloneApp(editor.getValue(),GEBID('name_standalone').value,style_standalone, allselected)); w.document.close();"/>
<input type="button" value="Create only a standalone Library" onclick="var style_standalone=1; var options_standalone=GEBID('internalFS_standalone').options; var allselected=[]; var nbselected=0; for(var i=0; i<options_standalone.length; i++) if (options_standalone[i].selected) allselected[nbselected++]=options_standalone[i].value; var w=window.open(); w.document.open('text/plain'); w.document.write(createLibraryApp(editor.getValue(),GEBID('name_standalone').value,style_standalone, allselected)); w.document.close();"/><br /><br /></div>
</div>
<br />
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
</div>
</body></html>
